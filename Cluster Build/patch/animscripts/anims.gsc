// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include animscripts\utility;
#include common_scripts\utility;
#include animscripts\shared;

animarray( animname, scriptoverride, errorifmissing )
{
    return animarraygeneric( animname, scriptoverride, errorifmissing, self.anim_array, anim.anim_array, 1 );
}

angledeltaarray( animname, scriptoverride, errorifmissing )
{
    return animarraygeneric( animname, scriptoverride, errorifmissing, self.angle_delta_array, anim.angle_delta_array, 0 );
}

movedeltaarray( animname, scriptoverride, errorifmissing )
{
    return animarraygeneric( animname, scriptoverride, errorifmissing, self.move_delta_array, anim.move_delta_array, 0 );
}

premovedeltaarray( animname, scriptoverride, errorifmissing )
{
    return animarraygeneric( animname, scriptoverride, errorifmissing, self.pre_move_delta_array, anim.pre_move_delta_array, 0 );
}

postmovedeltaarray( animname, scriptoverride, errorifmissing )
{
    return animarraygeneric( animname, scriptoverride, errorifmissing, self.post_move_delta_array, anim.post_move_delta_array, 0 );
}

longestexposedapproachdist()
{
    if ( isdefined( self.longestexposedapproachdist ) )
    {
        assert( isdefined( self.longestexposedapproachdist[self.animtype] ) );
        return self.longestexposedapproachdist[self.animtype];
    }

    assert( isdefined( anim.longestexposedapproachdist ) );

    if ( self.subclass != "regular" && isdefined( anim.longestexposedapproachdist[self.subclass] ) )
        return anim.longestexposedapproachdist[self.subclass];

    if ( isdefined( anim.longestexposedapproachdist[self.animtype] ) )
        return anim.longestexposedapproachdist[self.animtype];

    return anim.longestexposedapproachdist["default"];
}

longestapproachdist( animname )
{
    if ( isdefined( self.longestapproachdist ) )
    {
        if ( isdefined( self.longestapproachdist[self.animtype][animname] ) )
            return self.longestapproachdist[self.animtype][animname];
    }

    assert( isdefined( anim.longestapproachdist ) );

    if ( self.subclass != "regular" && isdefined( anim.longestapproachdist[self.subclass] ) && isdefined( anim.longestapproachdist[self.subclass][animname] ) )
        return anim.longestapproachdist[self.subclass][animname];

    if ( isdefined( anim.longestapproachdist[self.animtype] ) && isdefined( anim.longestapproachdist[self.animtype][animname] ) )
        return anim.longestapproachdist[self.animtype][animname];

    return anim.longestapproachdist["default"][animname];
}

setidleanimoverride( overrideanim )
{
    if ( !isdefined( self.anim_array ) )
        self.anim_array = [];

    if ( !isdefined( overrideanim ) )
    {
        self.anim_array[self.animtype]["stop"]["stand"]["none"]["idle"] = undefined;
        self.anim_array[self.animtype]["stop"]["stand"][self weaponanims()]["idle"] = undefined;
    }
    else if ( isarray( overrideanim ) )
    {
        self.anim_array[self.animtype]["stop"]["stand"]["none"]["idle"] = array( overrideanim );
        self.anim_array[self.animtype]["stop"]["stand"][self weaponanims()]["idle"] = array( overrideanim );
    }
    else
    {
        self.anim_array[self.animtype]["stop"]["stand"]["none"]["idle"] = array( array( overrideanim ) );
        self.anim_array[self.animtype]["stop"]["stand"][self weaponanims()]["idle"] = array( array( overrideanim ) );
    }
}

#using_animtree("generic_human");

animarraygeneric( animname, scriptoverride, errorifmissing, my_anim_array, global_anim_array, usecache )
{
    if ( self.a.pose != self.a.prevpose )
    {
        clearanimcache();
        self.a.prevpose = self.a.pose;
    }

    if ( usecache )
    {
        cacheentry = self.anim_array_cache[animname];

        if ( isdefined( cacheentry ) )
            return cacheentry;
    }

    theanim = %void;
    animtype = self.animtype;
    animscript = self.a.script;
    animpose = self.a.pose;
    animweaponanims = self weaponanims();

    if ( isai( self ) && !self holdingweapon() )
        animweaponanims = "none";

    errorifmissingoverride = errorifmissing;

    if ( isdefined( scriptoverride ) )
        animscript = scriptoverride;
    else if ( isdefined( self.a.script_suffix ) )
        animscript = animscript + self.a.script_suffix;

    if ( isdefined( my_anim_array ) )
        theanim = self animarrayinternal( my_anim_array, animtype, animscript, animpose, animweaponanims, animname, 0, 0 );

    assert( isdefined( global_anim_array ) );

    if ( !isdefined( errorifmissing ) )
    {
        if ( animtype != "default" || self.subclass != "regular" )
        {
            errorifmissing = 1;
            errorifmissingoverride = 0;
        }
        else
        {
            errorifmissing = 1;
            errorifmissingoverride = 1;
        }
    }

    if ( isdefined( global_anim_array ) && ( !isdefined( theanim ) || !isarray( theanim ) && theanim == %void ) )
    {
        if ( self.subclass != "regular" )
            theanim = self animarrayinternal( global_anim_array, self.subclass, animscript, animpose, animweaponanims, animname, errorifmissingoverride, 1 );

        if ( !isdefined( theanim ) || !isarray( theanim ) && theanim == %void )
            theanim = self animarrayinternal( global_anim_array, animtype, animscript, animpose, animweaponanims, animname, errorifmissingoverride, 1 );

        if ( animtype != "default" && ( !isdefined( theanim ) || !isarray( theanim ) && theanim == %void ) )
            theanim = self animarrayinternal( global_anim_array, "default", animscript, animpose, animweaponanims, animname, errorifmissing, 1 );
    }

    if ( usecache && isdefined( theanim ) )
        self.anim_array_cache[animname] = theanim;

    return theanim;
}

animarrayexist( animname, scriptoverride )
{
    theanim = animarray( animname, scriptoverride, 0 );

    if ( !isdefined( theanim ) || theanim == %void )
        return false;

    return true;
}

animarrayanyexist( animname, scriptoverride )
{
    animarray = animarray( animname, scriptoverride, 0 );

    if ( !isdefined( animarray ) || !isarray( animarray ) && animarray == %void )
        return false;
    else if ( !isarray( animarray ) )
        return true;

    return animarray.size > 0;
}

animarraypickrandom( animname, scriptoverride, oncepercache )
{
    animarray = animarray( animname, scriptoverride );

    if ( !isarray( animarray ) )
        return animarray;

    assert( animarray.size > 0 );

    if ( animarray.size > 1 )
        index = randomint( animarray.size );
    else
        index = 0;

    if ( isdefined( oncepercache ) )
        self.anim_array_cache[animname] = animarray[index];

    return animarray[index];
}

animarrayinternal( anim_array, animtype, animscript, animpose, animweaponanims, animname, errorifmissing, globalarraylookup )
{
    animtype_array = anim_array[animtype];

    if ( !isdefined( animtype_array ) )
    {
/#
        if ( errorifmissing )
        {
            errormsg = "Missing anim: " + animtype + "/" + animscript + "/" + animpose + "/" + animweaponanims + "/" + animname + ". AnimType '" + animtype + "' not part of anim array. ";
            assert( isdefined( animtype_array ), errormsg );
        }
#/
        return %void;
    }

    script_array = animtype_array[animscript];

    if ( !isdefined( script_array ) )
    {
        if ( isdefined( self.covernode ) && animscript != "combat" && animscripts\shared::isexposed() )
            return animarrayinternal( anim_array, animtype, "combat", animpose, animweaponanims, animname, errorifmissing, globalarraylookup );

/#
        if ( errorifmissing )
        {
            errormsg = "Missing anim: " + animtype + "/" + animscript + "/" + animpose + "/" + animweaponanims + "/" + animname + ". Script '" + animscript + "' not part of anim array. ";
            assert( isdefined( script_array ), errormsg );
        }
#/
        return %void;
    }

    pose_array = script_array[animpose];

    if ( !isdefined( pose_array ) )
    {
/#
        if ( errorifmissing )
        {
            errormsg = "Missing anim: " + animtype + "/" + animscript + "/" + animpose + "/" + animweaponanims + "/" + animname + ". Pose '" + animpose + "' not part of anim array. ";
            assert( isdefined( pose_array ), errormsg );
        }
#/
        return %void;
    }

    weapon_array = pose_array[animweaponanims];

    if ( !isdefined( weapon_array ) )
    {
        if ( animweaponanims != "rifle" && globalarraylookup )
            return animarrayinternal( anim_array, animtype, animscript, animpose, "rifle", animname, errorifmissing, globalarraylookup );

        if ( errorifmissing )
        {
/#
            errormsg = "Missing anim: " + animtype + "/" + animscript + "/" + animpose + "/" + animweaponanims + "/" + animname + ". WeaponType '" + animweaponanims + "' not part of anim array. ";
            assertmsg( errormsg );
#/
        }

        return %void;
    }

    theanim = weapon_array[animname];

    if ( !isdefined( theanim ) )
    {
        if ( animweaponanims != "rifle" )
            theanim = animarrayinternal( anim_array, animtype, animscript, animpose, "rifle", animname, errorifmissing, globalarraylookup );
        else if ( isdefined( self.covernode ) && animscript != "combat" && globalarraylookup )
            theanim = animarrayinternal( anim_array, animtype, "combat", animpose, animweaponanims, animname, errorifmissing, globalarraylookup );

        if ( ( !isdefined( theanim ) || !isarray( theanim ) && theanim == %void ) && errorifmissing )
        {
/#
            errormsg = "Missing anim: " + animtype + "/" + animscript + "/" + animpose + "/" + animweaponanims + "/" + animname + ". Anim '" + animname + "' not part of anim array. Cur: " + self.a.script + "Prev: " + self.a.prevscript;
            assert( isdefined( theanim ) && theanim != %void, errormsg );
#/
        }
    }

    return theanim;
}

dumpanimarray()
{
/#
    println( "self.a.array:" );
    keys = getarraykeys( self.a.array );

    for ( i = 0; i < keys.size; i++ )
    {
        if ( isarray( self.a.array[keys[i]] ) )
        {
            println( " array[ \"" + keys[i] + "\" ] = {array of size " + self.a.array[keys[i]].size + "}" );
            continue;
        }

        println( " array[ \"" + keys[i] + "\" ] = ", self.a.array[keys[i]] );
    }
#/
}

clearanimcache()
{
    self.anim_array_cache = [];
}
