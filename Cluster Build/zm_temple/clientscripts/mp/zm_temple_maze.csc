// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\_utility;
#include clientscripts\_music;
#include clientscripts\_zombiemode_weapons;

maze_trap_move_wall( localclientnum, active )
{
    if ( !isdefined( self.wall ) )
        self set_maze_trap_wall( localclientnum );

    wall = self.wall;

    if ( isdefined( wall ) )
    {
        wall thread maze_wall_init( localclientnum );
        wall thread move_maze_wall( active );
    }
}

maze_wall_init( localclientnum )
{
    if ( !isdefined( self.init ) || !self.init )
    {
        self init_maze_mover( -128, 0.25, 1.0, 1, "evt_maze_wall_down", "evt_maze_wall_up" );
        self.script_fxid = level._effect["maze_wall_impact"];
        self.script_fxid2 = level._effect["maze_wall_raise"];
        self.fx_active_offset = vectorscale( ( 0, 0, -1 ), 60.0 );
        self.fx_active2_offset = vectorscale( ( 0, 0, -1 ), 60.0 );
        self.init = 1;
        self.client_num = localclientnum;
    }
}

init_maze_mover( movedist, moveuptime, movedowntime, blockspaths, moveupsound, movedownsound )
{
    self.isactive = 0;
    self.activecount = 0;
    self.ismoving = 0;
    self.movedist = movedist;
    self.activeheight = self.origin[2] + movedist;
    self.moveuptime = moveuptime;
    self.movedowntime = movedowntime;
    self.pathblocker = 0;
    self.alwaysactive = 0;
    self.moveupsound = moveupsound;
    self.movedownsound = movedownsound;
    self.startangles = self.angles;
}

move_maze_wall( active )
{
    if ( active && isdefined( self.moveupsound ) )
    {

    }

    if ( !active && isdefined( self.movedownsound ) )
    {

    }

    goalpos = ( self.origin[0], self.origin[1], self.activeheight );

    if ( !active )
        goalpos = ( goalpos[0], goalpos[1], goalpos[2] - self.movedist );

    movetime = self.moveuptime;

    if ( !active )
        movetime = self.movedowntime;

    if ( self.ismoving )
    {
        currentz = self.origin[2];
        goalz = goalpos[2];
        ratio = abs( goalz - currentz ) / abs( self.movedist );
        movetime = movetime * ratio;
    }

    self notify( "stop_maze_mover" );
    self.isactive = active;
    self thread _maze_mover_move( goalpos, movetime );
}

set_maze_trap_wall( localclientnum )
{
    walls = getentarray( localclientnum, "maze_trap_wall", "targetname" );
    bestwall = undefined;
    bestdist = undefined;

    for ( i = 0; i < walls.size; i++ )
    {
        wall = walls[i];

        if ( isdefined( wall.assigned ) )
            continue;

        dist = distancesquared( self.origin, wall.origin );

        if ( !isdefined( bestdist ) || dist < bestdist )
        {
            bestdist = dist;
            bestwall = wall;
        }
    }

    self.wall = bestwall;

    if ( isdefined( self.wall ) )
        self.wall.assigned = 1;
}

_maze_mover_move( goal, time )
{
    self endon( "stop_maze_mover" );
    self.ismoving = 1;

    if ( time == 0 )
        time = 0.01;

    self moveto( goal, time );
    self waittill( "movedone" );
    self.ismoving = 0;

    if ( self.isactive )
        _maze_mover_play_fx( self.script_fxid, self.fx_active_offset );
    else
        _maze_mover_play_fx( self.script_fxid2, self.fx_active2_offset );
}

_maze_mover_play_fx( fx_name, offset )
{
    if ( isdefined( fx_name ) )
    {
        vfwd = anglestoforward( self.angles );
        org = self.origin;

        if ( isdefined( offset ) )
            org = org + offset;

        playfx( self.client_num, fx_name, org, vfwd, ( 0, 0, 1 ) );
    }
}
