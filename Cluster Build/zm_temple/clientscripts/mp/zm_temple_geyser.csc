// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_music;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;

main()
{
    register_clientflag_callback( "player", level._cf_player_geyser_fake_player_setup_prone, ::geyser_player_setup_prone );
    register_clientflag_callback( "player", level._cf_player_geyser_fake_player_setup_stand, ::geyser_player_setup_stand );
}

init_player_geyser_anims()
{

}

geyser_player_setup_prone( localclientnum, set, newent )
{
    if ( isspectating( localclientnum, 0 ) )
        return;

    player = getlocalplayers()[localclientnum];

    if ( player getentitynumber() == self getentitynumber() )
    {
        if ( set )
            self playrumbleonentity( localclientnum, "slide_rumble" );
        else
            self stoprumble( localclientnum, "slide_rumble" );

        return;
    }

    if ( set )
    {
        if ( localclientnum == 0 )
            self thread player_disconnect_tracker();

        fake_player = spawn( localclientnum, self.origin + vectorscale( ( 0, 0, -1 ), 800.0 ), "script_model" );
        fake_player.angles = self.angles;
        fake_player setmodel( self.model );

        if ( self.model == "c_ger_richtofen_body" )
        {
            fake_player attach( "c_ger_richtofen_head", "J_Spine4" );
            fake_player attach( "c_ger_richtofen_offcap", "J_Head" );
        }

        fake_player.fake_weapon = spawn( localclientnum, self.origin, "script_model" );

        if ( self.weapon != "none" && self.weapon != "syrette_sp" )
        {
            fake_player.fake_weapon setmodel( getweaponmodel( self.weapon ) );
            fake_player.fake_weapon useweaponhidetags( self.weapon );
        }
        else
            self thread geyser_weapon_monitor( fake_player.fake_weapon );

        fake_player.fake_weapon linkto( fake_player, "tag_weapon_right" );
        wait 0.016;
        fake_player linkto( self, "tag_origin" );
        fake_player useanimtree( level.geyser_animtree );
        fake_player setanim( level.geyser_anims["player_geyser_prone"], 1.0, 0.0, 1.0 );

        if ( !isdefined( self.fake_player ) )
            self.fake_player = [];

        self.fake_player[localclientnum] = fake_player;
        self thread wait_for_geyser_player_to_disconnect( localclientnum );
    }
    else
    {
        if ( !isdefined( self.fake_player ) && !isdefined( self.fake_player[localclientnum] ) )
            return;

        str_notify = "player_geyser" + localclientnum;
        self notify( str_notify );
        self notify( "end_geyser" );

        if ( isdefined( self.fake_player[localclientnum].fake_weapon ) )
        {
            self.fake_player[localclientnum].fake_weapon delete();
            self.fake_player[localclientnum].fake_weapon = undefined;
        }

        self.fake_player[localclientnum] delete();
        self.fake_player[localclientnum] = undefined;
    }
}

geyser_player_setup_stand( localclientnum, set, newent )
{
    if ( isspectating( localclientnum, 0 ) )
        return;

    player = getlocalplayers()[localclientnum];

    if ( player getentitynumber() == self getentitynumber() )
    {
        if ( set )
            self playrumbleonentity( localclientnum, "slide_rumble" );
        else
            self stoprumble( localclientnum, "slide_rumble" );

        return;
    }

    if ( set )
    {
        if ( localclientnum == 0 )
            self thread player_disconnect_tracker();

        fake_player = spawn( localclientnum, self.origin + vectorscale( ( 0, 0, -1 ), 800.0 ), "script_model" );
        fake_player.angles = self.angles;
        fake_player setmodel( self.model );

        if ( self.model == "c_ger_richtofen_body" )
        {
            fake_player attach( "c_ger_richtofen_head", "J_Spine4" );
            fake_player attach( "c_ger_richtofen_offcap", "J_Head" );
        }

        fake_player.fake_weapon = spawn( localclientnum, self.origin, "script_model" );

        if ( self.weapon != "none" && self.weapon != "syrette_sp" )
        {
            fake_player.fake_weapon setmodel( getweaponmodel( self.weapon ) );
            fake_player.fake_weapon useweaponhidetags( self.weapon );
        }
        else
            self thread geyser_weapon_monitor( fake_player.fake_weapon );

        fake_player.fake_weapon linkto( fake_player, "tag_weapon_right" );
        wait 0.016;
        fake_player linkto( self, "tag_origin" );
        fake_player useanimtree( level.geyser_animtree );
        fake_player setanim( level.geyser_anims["player_geyser_stand_crouch"], 1.0, 0.0, 1.0 );

        if ( !isdefined( self.fake_player ) )
            self.fake_player = [];

        self.fake_player[localclientnum] = fake_player;
        self thread wait_for_geyser_player_to_disconnect( localclientnum );
    }
    else
    {
        if ( !isdefined( self.fake_player ) && !isdefined( self.fake_player[localclientnum] ) )
            return;

        str_notify = "player_geyser" + localclientnum;
        self notify( str_notify );
        self notify( "end_geyser" );

        if ( isdefined( self.fake_player[localclientnum].fake_weapon ) )
        {
            self.fake_player[localclientnum].fake_weapon delete();
            self.fake_player[localclientnum].fake_weapon = undefined;
        }

        self.fake_player[localclientnum] delete();
        self.fake_player[localclientnum] = undefined;
    }
}

geyser_weapon_monitor( fake_weapon )
{
    self endon( "end_geyser" );
    self endon( "disconnect" );

    while ( self.weapon == "none" )
        wait 0.05;

    if ( self.weapon != "syrette_sp" )
    {
        fake_weapon setmodel( getweaponmodel( self.weapon ) );
        fake_weapon useweaponhidetags( self.weapon );
    }
}

player_disconnect_tracker()
{
    self notify( "stop_tracking" );
    self endon( "stop_tracking" );
    ent_num = self getentitynumber();

    while ( isdefined( self ) )
        wait 0.05;

    level notify( "player_disconnected", ent_num );
}

geyser_model_remover( str_endon, player )
{
    player endon( str_endon );
    level waittill( "player_disconnected", client );

    if ( isdefined( self.fake_weapon ) )
        self.fake_weapon delete();

    self delete();
}

wait_for_geyser_player_to_disconnect( localclientnum )
{
    str_endon = "player_geyser" + localclientnum;
    self.fake_player[localclientnum] thread geyser_model_remover( str_endon, self );
}
