// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_music;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\zm_temple_fx;
#include clientscripts\mp\zombies\_zm;
#include clientscripts\mp\zm_temple_amb;
#include clientscripts\mp\zm_temple_geyser;

main()
{
    thread clientscripts\mp\zm_temple_fx::main();
    level._uses_crossbow = 1;
    level._temple_vision_set = "zombie_temple";
    level._temple_vision_set_priority = 1;
    level._temple_caves_vision_set = "zombie_temple_caves";
    level._temple_caves_vision_set_priority = 2;
    level._temple_water_vision_set = "zombie_temple";
    level._temple_eclipse_vision_set = "zombie_temple_eclipse";
    level._temple_eclipse_vision_set_priority = 3;
    level._temple_caves_eclipse_vision_set = "zombie_temple_eclipseCave";
    level._temple_caves_eclipse_vision_set_priority = 3;
    init_client_flags();
    level.riser_fx_on_client = 1;
    level.use_new_riser_water = 1;
    level.use_clientside_rock_tearin_fx = 1;
    level.use_clientside_board_fx = 1;
    level.zombiemode_using_doubletap_perk = 1;
    level.zombiemode_using_juggernaut_perk = 1;
    level.zombiemode_using_revive_perk = 1;
    level.zombiemode_using_sleightofhand_perk = 1;
    level.zombiemode_using_marathon_perk = 1;
    level.zombiemode_using_divetonuke_perk = 1;
    level.zombiemode_using_deadshot_perk = 1;

    if ( !is_true( getdvar( #"createfx" ) != "" ) )
        include_weapons();

    include_powerups();
    clientscripts\mp\zombies\_zm::init();
    thread clientscripts\mp\zm_temple_amb::main();
    clientscripts\mp\zm_temple_geyser::main();
    level thread power_watch();
    level thread waterfall_triggers_init();
    watch_power_water();
    register_zombie_types();
    _init_pap_indicators();
    register_flag_handlers();
    level thread cave_vision_trigger_init();
    level thread sq_std_watcher();
    level thread timetravel_watcher();
    level thread time_travel_vision();
/#
    setdvar( "player_sliding_wishspeed", "450" );
#/
}

include_powerups()
{
    include_powerup( "nuke" );
    include_powerup( "insta_kill" );
    include_powerup( "double_points" );
    include_powerup( "full_ammo" );
    include_powerup( "carpenter" );
    include_powerup( "fire_sale" );
}

init_client_flags()
{
    level._cf_actor_is_napalm_zombie = 0;
    level._cf_actor_do_not_use = 1;
    level._cf_actor_napalm_zombie_explode = 2;
    level._cf_actor_is_sonic_zombie = 3;
    level._cf_actor_napalm_zombie_wet = 4;
    level._cf_actor_client_flag_spikemore = 5;
    level._cf_actor_ragdoll_impact_gib = 6;
    level._cf_player_geyser_fake_player_setup_prone = 0;
    level._cf_player_geyser_fake_player_setup_stand = 1;
    level._cf_player_maze_floor_rumble = 3;
    level._cf_scriptmover_client_flag_spikes = 3;
    level._cf_scriptmover_client_flag_maze_wall = 4;
    level._cf_scriptmover_client_flag_spikemore = 5;
    level._cf_scriptmover_client_flag_weaksauce_start = 6;
    level._cf_scriptmover_client_flag_hotsauce_start = 7;
    level._cf_scriptmover_client_flag_sauce_end = 8;
    level._cf_scriptmover_client_flag_water_trail = 9;
}

register_flag_handlers()
{
    register_clientflag_callback( "scriptmover", level._cf_scriptmover_client_flag_spikes, ::spike_trap_move );
}

spike_trap_move( localclientnum, set, newent )
{
    spike_trap_move_spikes( localclientnum, set );
}

maze_wall_move( localclientnum, set, newent )
{

}

delete_water_trail()
{
    for ( i = 0; i < self.fx_ents.size; i++ )
        self.fx_ents[i] delete();

    self.fx_ents = undefined;
}

water_trail_monitor( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    if ( set )
    {
        players = getlocalplayers();
        self.fx_ents = [];

        for ( i = 0; i < players.size; i++ )
        {
            self.fx_ents[i] = spawn( i, ( 0, 0, 0 ), "script_model" );
            self.fx_ents[i] setmodel( "tag_origin" );
            self.fx_ents[i] linkto( self, "tag_origin" );
            playfxontag( i, level._effect["fx_crystal_water_trail"], self.fx_ents[i], "tag_origin" );
        }
    }
    else if ( isdefined( self.fx_ents ) )
        self thread delete_water_trail();
}

crystal_weaksauce_start( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    if ( !set )
        return;

    s = spawnstruct();
    s.fx = "fx_weak_sauce_trail";
    s.origin = self.origin + vectorscale( ( 0, 0, 1 ), 134.0 );
    level._crystal_sauce_start = s;
}

crystal_hotsauce_start( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    if ( !set )
        return;

    s = spawnstruct();
    s.fx = "fx_hot_sauce_trail";
    s.origin = self.origin + vectorscale( ( 0, 0, 1 ), 134.0 );
    level._crystal_sauce_start = s;
}

crystal_sauce_end( localclientnum, set, newent )
{
    if ( localclientnum != 0 )
        return;

    if ( !set )
        return;

    level._crystal_sauce_end = self.origin;

    if ( self.model == "p_ztem_crystal_and_holder" )
        level._crystal_sauce_end = level._crystal_sauce_end + vectorscale( ( 0, 0, 1 ), 134.0 );
}

crystal_trail_runner( localclientnum, fx_name, dest )
{
    playfxontag( localclientnum, level._effect[fx_name], self, "tag_origin" );
    self playloopsound( "evt_sq_bag_crystal_bounce_loop", 0.05 );
    self moveto( dest, 0.5 );
    self waittill( "movedone" );
    self delete();
}

crystal_sauce_monitor()
{
    num_players = getlocalplayers().size;

    while ( true )
    {
        if ( !isdefined( level._crystal_sauce_start ) || !isdefined( level._crystal_sauce_end ) )
            continue;

        for ( i = 0; i < num_players; i++ )
        {
            e = spawn( i, level._crystal_sauce_start.origin, "script_model" );
            e setmodel( "tag_origin" );
            e thread crystal_trail_runner( i, level._crystal_sauce_start.fx, level._crystal_sauce_end );
        }

        level._crystal_sauce_start = undefined;
        level._crystal_sauce_end = undefined;
    }
}

power_watch()
{
    level.power = 0;
    level waittill( "ZPO" );
    level.power = 1;
    level thread start_generator_movement();
}

timetravel_watcher()
{
    level._in_eclipse = 0;
    level thread eclipse_watcher();
    level thread daybreak_watcher();
}

time_travel_vision()
{
    level waittill( "time_travel" );

    while ( true )
    {
        level waittill( "time_travel" );
        setdvarfloat( "r_poisonFX_debug_amount", 0 );
        setdvar( "r_poisonFX_debug_enable", 1 );
        setdvarfloat( "r_poisonFX_pulse", 2 );
        setdvarfloat( "r_poisonFX_warpX", -0.3 );
        setdvarfloat( "r_poisonFX_warpY", 0.15 );
        setdvarfloat( "r_poisonFX_dvisionA", 0 );
        setdvarfloat( "r_poisonFX_dvisionX", 0 );
        setdvarfloat( "r_poisonFX_dvisionY", 0 );
        setdvarfloat( "r_poisonFX_blurMin", 0 );
        setdvarfloat( "r_poisonFX_blurMax", 3 );
        delta = 0.064;
        amount = 1;
        setdvarfloat( "r_poisonFX_debug_amount", amount );

        while ( amount > 0 )
        {
            amount = max( amount - delta, 0 );
            setdvarfloat( "r_poisonFX_debug_amount", amount );
            wait 0.016;
        }

        setdvarfloat( "r_poisonFX_debug_amount", 0 );
        setdvar( "r_poisonFX_debug_enable", 0 );
    }
}

eclipse_watcher()
{
    while ( true )
    {
        level waittill( "ec", lcn );

        if ( isdefined( lcn ) && lcn != 0 )
            continue;

        level._in_eclipse = 1;
        level notify( "time_travel", level._in_eclipse );
        players = getlocalplayers();

        for ( i = 0; i < players.size; i++ )
        {
            players[i] thread temple_set_eclipse_visionset( i );

            if ( isdefined( players[i]._in_cave ) && players[i]._in_cave )
                players[i] thread temple_set_visionset_caves( i );
        }

        setsaveddvar( "r_lightTweakSunLight", 11 );
        level thread strobe_sky_and_transition( 1.0 );
    }
}

strobe_sky_and_transition( end_val )
{
    val = end_val;
    delay = 0.016;

    for ( i = 0; i < 10; i++ )
    {
        setsaveddvar( "r_skyTransition", val );
        val = 1.0 - val;
        delay = delay * 1.1;
    }

    step = 0.00833333;
    val = 1 - end_val;

    if ( val == 0 )
        step = step * -1;

    for ( i = 0; i < 120; i++ )
    {
        setsaveddvar( "r_skyTransition", val );
        val = val - step;
        wait 0.016;
    }

    setsaveddvar( "r_skyTransition", end_val );
}

daybreak_watcher()
{
    while ( true )
    {
        level waittill( "db", lcn );

        if ( isdefined( lcn ) && lcn != 0 )
            continue;

        level._in_eclipse = 0;
        level notify( "time_travel", level._in_eclipse );
        players = getlocalplayers();

        for ( i = 0; i < players.size; i++ )
        {

        }

        if ( isdefined( players[0]._in_cave ) && players[0]._in_cave )
        {

        }
        else
        {

        }

        setsaveddvar( "r_lightTweakSunLight", 13 );

        if ( !isdefined( level.first_sky_trans ) )
        {
            level.first_sky_trans = 0;
            setsaveddvar( "r_skyTransition", 0.0 );
        }
        else
            level thread strobe_sky_and_transition( 0.0 );
    }
}

start_generator_movement()
{
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        ent = getent( i, "power_generator", "targetname" );
        ent thread generator_move();
    }
}

generator_move()
{
    offsetangle = 0.25;
    rottime = 0.1;
    total = 0;
    self rotateroll( 0 - offsetangle, rottime );

    while ( true )
    {
        self waittill( "rotatedone" );
        self rotateroll( offsetangle * 2, rottime );
        self waittill( "rotatedone" );
        self rotateroll( 0 - offsetangle * 2, rottime );
    }
}

watch_power_water()
{
    level thread water_wheel_watch( "wwr", "water_wheel_right", 120, 2.2 );
    level thread water_wheel_watch( "wwl", "water_wheel_left", 120, 1.8 );
}

water_wheel_watch( waitfor, entname, rotate, time )
{
    level waittill( waitfor );
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        wheel = getent( i, entname, "targetname" );
        wheel thread rotatewheel( rotate, time );
    }
}

rotatewheel( rotate, time )
{
    spinuptime = time - 0.5;
    self rotatepitch( rotate, time, spinuptime, 0.1 );
    self waittill( "rotatedone" );

    while ( true )
    {
        self rotatepitch( rotate, time, 0, 0 );
        self waittill( "rotatedone" );
    }
}

disable_deadshot( i_local_client_num )
{
    while ( !self hasdobj( i_local_client_num ) )
        wait 0.05;

    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        if ( self == players[i] )
            self clearalternateaimparams();
    }
}

water_gush_debug()
{
    scale = 0.1;
    offset = ( 0, 0, 0 );
    dir = anglestoforward( self.angles );

    for ( i = 0; i < 5; i++ )
    {
        scale = scale * 1.7;
        offset = offset + dir * 6;
    }
}

waterfall_watcher()
{
    targets = getstructarray( "sq_sad", "targetname" );

    while ( true )
    {
        level waittill( "WF" );

        for ( i = 0; i < 4; i++ )
        {
            if ( !isdefined( level._sq_std_status ) || !isdefined( level._sq_std_status[i] ) )
                continue;

            if ( level._sq_std_status[i] == 0 )
            {

            }

            wait 0.25;
        }
    }
}

sq_std_watcher()
{
    players = getlocalplayers();
    level waittill( "SR" );
    targets = getstructarray( "sq_sad", "targetname" );

    for ( i = 0; i < targets.size; i++ )
        targets[i] thread sq_std_struct_watcher( players.size );
}

sq_std_watch_for_restart( num_local_players )
{
    level waittill( "SR" );

    if ( isdefined( level._sq_std_array[self.script_int - 1] ) )
    {
        for ( i = 0; i < level._sq_std_array[self.script_int - 1].size; i++ )
        {
            if ( isdefined( level._sq_std_array[self.script_int - 1][i] ) )
                level._sq_std_array[self.script_int - 1][i] delete();
        }

        level._sq_std_array[self.script_int - 1] = undefined;
    }

    level._sq_std_status[self.script_int - 1] = 0;
    self thread sq_std_struct_watcher( num_local_players );
}

sq_struct_debug()
{
    level endon( "SR" );
    level endon( "ksd" );

    while ( true )
        wait 0.1;
}

sq_std_struct_watcher( num_local_players )
{
    if ( !isdefined( level._sq_std_array ) )
    {
        level._sq_std_array = [];
        level._sq_std_status = [];

        for ( i = 0; i < 4; i++ )
            level._sq_std_status[i] = 0;
    }

    level endon( "SR" );
    self thread sq_std_watch_for_restart( num_local_players );

    while ( true )
    {
        level waittill( "S" + self.script_int );
        self thread sq_struct_debug();
        level._sq_std_status[self.script_int - 1] = 1;
        level._sq_std_array[self.script_int - 1] = [];

        for ( i = 0; i < num_local_players; i++ )
        {
            e = spawn( i, self.origin, "script_model" );
            e.angles = self.angles;
            e setmodel( "p_ztem_spikemore_spike" );
            level._sq_std_array[self.script_int - 1][level._sq_std_array[self.script_int - 1].size] = e;
        }
    }
}

temple_player_connect( i_local_client_num )
{
    self endon( "disconnect" );

    while ( !clienthassnapshot( i_local_client_num ) )
        wait 0.05;

    while ( !self hasdobj( i_local_client_num ) )
        wait 0.05;

    if ( getlocalplayers().size == 1 )
    {

    }

    self thread init_arms();

    if ( i_local_client_num != 0 )
        return;

    thread floating_boards_init();
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
        players[i] thread temple_set_visionset( i );
}

temple_player_spawned( i_local_client_num )
{
    self endon( "disconnect" );

    while ( !self hasdobj( i_local_client_num ) )
        wait 0.05;

    if ( i_local_client_num != 0 )
        return;

    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        players[i] thread temple_set_visionset( i );
        players[i] thread temple_remove_visionset_caves( i );
    }
}

init_arms()
{
    wait 5;

    switch ( self.model )
    {
        case "c_usa_dempsey_body":
            self.viewmodel = "viewmodel_usa_pow_arms";
            break;
        case "c_rus_nikolai_body":
            self.viewmodel = "viewmodel_rus_prisoner_arms";
            break;
        case "c_jap_takeo_body":
            self.viewmodel = "viewmodel_vtn_nva_standard_arms";
            break;
        case "c_ger_richtofen_body":
            self.viewmodel = "viewmodel_usa_hazmat_arms";
            break;
        default:
            break;
    }
}

cave_vision_trigger_init()
{
    cavetrigger = getent( 0, "cave_vision_trig", "targetname" );

    if ( isdefined( cavetrigger ) )
        cavetrigger thread cave_vision_trigger_watch();
}

cave_vision_trigger_watch()
{
    while ( true )
    {
        self waittill( "trigger", who );

        if ( who islocalplayer() )
        {
            who = getlocalplayers()[who getlocalclientnumber()];
            self thread trigger_thread( who, ::cave_vision_on, ::cave_vision_off );
        }
    }
}

cave_vision_on( player )
{
    if ( !player isplayer() )
        return;

    i_local_client_num = player getlocalclientnumber();
    player._in_cave = 1;
    player temple_set_visionset_caves( i_local_client_num );

    if ( level._in_eclipse )
    {

    }
    else
    {

    }
}

cave_vision_off( player )
{
    if ( !isdefined( player ) )
        return;

    player._in_cave = 0;

    if ( !player isplayer() )
        return;

    i_local_client_num = player getlocalclientnumber();
    player temple_remove_visionset_caves( i_local_client_num );

    if ( level._in_eclipse )
    {

    }
    else
    {

    }
}

temple_set_visionset( i_local_client_num )
{

}

temple_set_eclipse_visionset( i_local_client_num )
{

}

temple_set_visionset_caves( i_local_client_num )
{
    if ( level._in_eclipse )
    {

    }
}

temple_remove_visionset_caves( i_local_client_num )
{
    if ( level._in_eclipse )
    {

    }
}

include_weapons()
{
    include_weapon( "frag_grenade_zm", 0 );
    include_weapon( "claymore_zm", 0 );
    include_weapon( "m1911_zm", 0 );
    include_weapon( "m1911_upgraded_zm", 0 );
    include_weapon( "python_zm" );
    include_weapon( "python_upgraded_zm", 0 );
    include_weapon( "cz75_zm" );
    include_weapon( "cz75_upgraded_zm", 0 );
    include_weapon( "m14_zm", 0 );
    include_weapon( "m14_upgraded_zm", 0 );
    include_weapon( "m16_zm", 0 );
    include_weapon( "m16_gl_upgraded_zm", 0 );
    include_weapon( "g11_lps_zm" );
    include_weapon( "g11_lps_upgraded_zm", 0 );
    include_weapon( "famas_zm" );
    include_weapon( "famas_upgraded_zm", 0 );
    include_weapon( "ak74u_zm", 0 );
    include_weapon( "ak74u_upgraded_zm", 0 );
    include_weapon( "mp5k_zm", 0 );
    include_weapon( "mp5k_upgraded_zm", 0 );
    include_weapon( "mpl_zm", 0 );
    include_weapon( "mpl_upgraded_zm", 0 );
    include_weapon( "pm63_zm", 0 );
    include_weapon( "pm63_upgraded_zm", 0 );
    include_weapon( "spectre_zm" );
    include_weapon( "spectre_upgraded_zm", 0 );
    include_weapon( "cz75dw_zm" );
    include_weapon( "cz75dw_upgraded_zm", 0 );
    include_weapon( "ithaca_zm", 0 );
    include_weapon( "ithaca_upgraded_zm", 0 );
    include_weapon( "rottweil72_zm", 0 );
    include_weapon( "rottweil72_upgraded_zm", 0 );
    include_weapon( "spas_zm" );
    include_weapon( "spas_upgraded_zm", 0 );
    include_weapon( "hs10_zm" );
    include_weapon( "hs10_upgraded_zm", 0 );
    include_weapon( "aug_acog_zm", 1 );
    include_weapon( "aug_acog_mk_upgraded_zm", 0 );
    include_weapon( "galil_zm" );
    include_weapon( "galil_upgraded_zm", 0 );
    include_weapon( "commando_zm" );
    include_weapon( "commando_upgraded_zm", 0 );
    include_weapon( "fnfal_zm" );
    include_weapon( "fnfal_upgraded_zm", 0 );
    include_weapon( "dragunov_zm" );
    include_weapon( "dragunov_upgraded_zm", 0 );
    include_weapon( "l96a1_zm" );
    include_weapon( "l96a1_upgraded_zm", 0 );
    include_weapon( "rpk_zm" );
    include_weapon( "rpk_upgraded_zm", 0 );
    include_weapon( "hk21_zm" );
    include_weapon( "hk21_upgraded_zm", 0 );
    include_weapon( "m72_law_zm" );
    include_weapon( "m72_law_upgraded_zm", 0 );
    include_weapon( "china_lake_zm" );
    include_weapon( "china_lake_upgraded_zm", 0 );
    include_weapon( "cymbal_monkey_zm" );
    include_weapon( "crossbow_explosive_zm" );
    include_weapon( "crossbow_explosive_upgraded_zm", 0 );
    include_weapon( "knife_ballistic_zm", 1 );
    include_weapon( "knife_ballistic_upgraded_zm", 0 );
    include_weapon( "knife_ballistic_bowie_zm", 0 );
    include_weapon( "knife_ballistic_bowie_upgraded_zm", 0 );
}

register_zombie_types()
{

}

_init_magic_box()
{
    level._custom_box_monitor = ::temple_box_monitor;
    level._box_locations = array( "waterfall_upper_chest", "blender_chest", "pressure_chest", "bridge_chest", "caves_water_chest", "power_chest", "caves1_chest", "caves2_chest", "caves3_chest" );
    level.cachedinfo = [];
    level.initialized = [];
}

_init_indicators( clientnum )
{
    structs = getstructarray( "magic_box_indicator", "targetname" );

    for ( i = 0; i < structs.size; i++ )
    {
        s = structs[i];

        if ( !isdefined( s.viewmodels ) )
            s.viewmodels = [];

        s.viewmodels[clientnum] = undefined;
    }

    level.initialized[clientnum] = 1;
    keys = getarraykeys( level.cachedinfo );

    for ( i = 0; i < keys.size; i++ )
    {
        key = keys[i];
        state = level.cachedinfo[key];
        temple_box_monitor( i, state, "" );
    }
}

temple_box_monitor( clientnum, state, oldstate )
{
    if ( !isdefined( level.initialized[clientnum] ) )
    {
        level.cachedinfo[clientnum] = state;
        return;
    }

    switch ( state )
    {
        case "fire_sale":
            _all_locations( clientnum );
            break;
        case "moving":
            level thread _random_location( clientnum );
            break;
        default:
            level notify( "location_set" + clientnum );
            _setup_location( clientnum, state );
            break;
    }
}

_delete_location( clientnum, location )
{
    structs = getstructarray( location, "script_noteworthy" );
    array_thread( structs, ::_setup_view_model, clientnum, undefined );
}

_delete_all_locations( clientnum )
{
    for ( i = 0; i < level._box_locations.size; i++ )
    {
        location = level._box_locations[i];
        _delete_location( clientnum, location );
    }
}

_show_location( clientnum, location )
{
    structs = getstructarray( location, "script_noteworthy" );
    array_thread( structs, ::_setup_view_model, clientnum, "zt_map_knife" );
}

_setup_location( clientnum, location )
{
    _delete_all_locations( clientnum );
    _show_location( clientnum, location );
}

_setup_view_model( clientnum, viewmodel )
{
    if ( isdefined( self.viewmodels[clientnum] ) )
    {
        self.viewmodels[clientnum] delete();
        self.viewmodels[clientnum] = undefined;
    }

    if ( isdefined( viewmodel ) )
    {
        self.viewmodels[clientnum] = spawn( clientnum, self.origin, "script_model" );
        self.viewmodels[clientnum].angles = self.angles;
        self.viewmodels[clientnum] setmodel( viewmodel );
    }
}

_random_location( clientnum )
{
    level endon( "location_set" + clientnum );
    index = 0;

    while ( true )
    {
        location = level._box_locations[index];
        _setup_location( clientnum, location );
        index++;

        if ( index >= level._box_locations.size )
            index = 0;

        wait 0.25;
    }
}

_all_locations( clientnum )
{
    for ( i = 0; i < level._box_locations.size; i++ )
    {
        location = level._box_locations[i];
        _show_location( clientnum, location );
    }
}

_init_pap_indicators()
{
    local_players = getlocalplayers();

    for ( index = 0; index < local_players.size; index++ )
    {
        level thread _init_pap_spinners( index );
        level thread _set_num_visible_spinners( index, 0 );
    }
}

temple_pap_monitor_spinners( clientnum, state, oldstate )
{
    getlocalplayers()[clientnum] _set_num_visible_spinners( clientnum, int( state ) );
}

power( base, exp )
{
    assert( exp >= 0 );

    if ( exp == 0 )
        return 1;

    return base * power( base, exp - 1 );
}

_set_num_visible_spinners( clientnum, num )
{
    for ( i = 3; i >= 0; i-- )
    {
        pow = power( 2, i );

        if ( num >= pow )
        {
            num = num - pow;
            array_thread( level.spinners[clientnum][i], ::spin_to_start );
            continue;
        }

        array_thread( level.spinners[clientnum][i], ::spin_forever );
    }
}

spike_trap_move_spikes( localclientnum, active )
{
    if ( !isdefined( self.spears ) )
        self set_trap_spears( localclientnum );

    spears = self.spears;

    if ( isdefined( spears ) )
    {
        for ( i = 0; i < spears.size; i++ )
        {
            playsound = i == 0;
            spears[i] thread spear_init( localclientnum );
            spears[i] thread spear_move( localclientnum, active, playsound );
        }
    }
}

set_trap_spears( localclientnum )
{
    allspears = getentarray( localclientnum, "spear_trap_spear", "targetname" );
    self.spears = [];

    for ( i = 0; i < allspears.size; i++ )
    {
        spear = allspears[i];

        if ( isdefined( spear.assigned ) && spear.assigned )
            continue;

        delta = abs( self.origin[0] - spear.origin[0] );

        if ( abs( self.origin[0] - spear.origin[0] ) < 21 )
        {
            spear.assigned = 1;
            self.spears[self.spears.size] = spear;
        }
    }
}

spear_init( localclientnum )
{
    if ( !isdefined( self.init ) || !self.init )
    {
        self.movedistmin = 90;
        self.movedistmax = 120;
        self.start = self.origin;
        self.movedir = -1 * anglestoright( self.angles );
        self.init = 1;
    }
}

spear_move( localclientnum, active, playsound )
{
    if ( active )
    {
        if ( playsound )
            play_sound_in_space( 0, "evt_spiketrap_warn", self.origin );

        movedist = randomfloatrange( self.movedistmin, self.movedistmax );
        endpos = self.start + self.movedir * movedist;
        playsound( 0, "evt_spiketrap", self.origin );
        movetime = randomfloatrange( 0.08, 0.22 );
        self moveto( endpos, movetime );
    }
    else
    {
        if ( playsound )
            playsound( 0, "evt_spiketrap_retract", self.origin );

        movetime = randomfloatrange( 0.1, 0.2 );
        self moveto( self.start, movetime );
    }
}

floating_boards_init()
{
    boards = [];
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {

    }

    array_thread( boards, ::float_board );
}

float_board()
{
    wait( randomfloat( 1.0 ) );
    self.start_origin = self.origin;
    self.start_angles = self.angles;
    self.moment_move = self.origin;
    self thread board_bob();
    self thread board_rotate();
}

board_bob()
{
    dist = randomfloatrange( 2.5, 3.0 );
    movetime = randomfloatrange( 3.5, 4.5 );
    minz = self.start_origin[2] - dist;
    maxz = self.start_origin[2] + dist;

    while ( true )
    {
        toz = minz - self.origin[2];
        self movez( toz, movetime );
        self waittill( "movedone" );
        toz = maxz - self.origin[2];
        self movez( toz, movetime );
        self waittill( "movedone" );
    }
}

board_rotate()
{
    while ( true )
    {
        yaw = randomfloatrange( -360.0, 360.0 );
        self rotateyaw( yaw, randomfloatrange( 60.0, 90.0 ) );
        self waittill( "rotatedone" );
    }
}

board_move()
{
    dist = randomfloatrange( 20.0, 30.0 );
    movetime = randomfloatrange( 5.0, 10.0 );

    while ( true )
    {
        yaw = randomfloatrange( 0, 360.0 );
        tovector = anglestoforward( ( 0, yaw, 0 ) );
        newloc = self.start_origin + tovector * dist;
        tox = newloc[0] - self.origin[0];
        self movex( tox, movetime );
        toy = newloc[1] - self.origin[1];
        self movey( toy, movetime );
    }
}

_init_pap_spinners( cnum )
{
    if ( !isdefined( level.spinners ) )
        level.spinners = [];

    if ( level.spinners.size <= cnum )
        level.spinners[level.spinners.size] = array( [], [], [], [] );

    for ( i = 0; i < level.spinners[cnum].size; i++ )
    {
        spinners = getentarray( cnum, "pap_spinner" + ( i + 1 ), "targetname" );
        array_thread( spinners, ::init_spinner, i + 1 );
        level.spinners[cnum][i] = spinners;
    }
}

init_spinner( listnum )
{
    self.spinner = listnum;
    self.startangles = self.angles;
    self.spin_sound = "evt_pap_spinner0" + listnum;
    self.spin_stop_sound = "evt_pap_timer_stop";
    self.angles = ( 0, 90 * ( listnum - 1 ) + randomfloatrange( 10, 80 ), 0 );
}

spin_forever()
{
    if ( !level.power )
        return;

    if ( isdefined( self.spin_forever ) && self.spin_forever )
        return;

    self.spin_forever = 1;
    self.spin_to_start = 0;
    self notify( "stop_spinning" );
    self endon( "death" );
    self endon( "stop_spinning" );
    spintime = self spinner_get_spin_time();
    self start_spinner_sound();
    self rotateyaw( 360, spintime, 0.25 );
    self waittill( "rotatedone" );

    while ( true )
    {
        self rotateyaw( 360, spintime );
        self waittill( "rotatedone" );
    }
}

spinner_get_spin_time()
{
    spintime = 1.7;

    if ( self.spinner == 2 )
        spintime = 1.5;
    else if ( self.spinner == 3 )
        spintime = 1.2;
    else if ( self.spinner == 4 )
        spintime = 0.8;

    return spintime;
}

spin_to_start()
{
    if ( !level.power )
        return;

    if ( isdefined( self.spin_to_start ) && self.spin_to_start )
        return;

    self.spin_forever = 0;
    self.spin_to_start = 1;
    self notify( "stop_spinning" );
    self endon( "death" );
    self endon( "stop_spinning" );
    endyaw = self.startangles[1];
    currentyaw = self.angles[1];

    for ( deltayaw = endyaw - currentyaw; deltayaw < 0; deltayaw = deltayaw + 360 )
    {

    }

    spintime = self spinner_get_spin_time();
    spintime = spintime * ( deltayaw / 360 );

    if ( spintime > 0 )
    {
        self rotateyaw( deltayaw, spintime, 0.0 );
        self waittill( "rotatedone" );
    }

    self stop_spinner_sound();
    self.angles = self.startangles;
}

start_spinner_sound()
{
    self playloopsound( self.spin_sound );
}

stop_spinner_sound()
{
    self stoploopsound();
    self playsound( 0, self.spin_stop_sound );
}

temple_light_model_swap_init()
{
    level waittill( "ZPO" );
    level notify( "pl1" );
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        light_models = getentarray( i, "model_lights_on", "targetname" );

        for ( x = 0; x < light_models.size; x++ )
        {
            light = light_models[x];

            if ( isdefined( light.script_string ) )
            {
                light setmodel( light.script_string );
                continue;
            }

            if ( light.model == "p_ztem_power_hanging_light_off" )
            {
                light setmodel( "p_ztem_power_hanging_light" );
                continue;
            }

            if ( light.model == "p_lights_cagelight02_off" )
                light setmodel( "p_lights_cagelight02_on" );
        }
    }
}

ragdoll_impact_watch_start( localclientnum, set, newent )
{
    if ( set )
        self thread ragdoll_impact_watch( localclientnum );
}

ragdoll_impact_watch( localclientnum )
{
    self endon( "entityshutdown" );
    waittime = 0.016;
    gibspeed = 500;
    prevorigin = self.origin;
    prevvel = self.origin - prevorigin;
    prevspeed = length( prevvel );
    prevorigin = self.origin;

    for ( firstloop = 1; 1; firstloop = 0 )
    {
        vel = self.origin - prevorigin;
        speed = length( vel );

        if ( speed < prevspeed * 0.5 && prevspeed > gibspeed * waittime )
        {
            dir = vectornormalize( prevvel );
            self gib_ragdoll( localclientnum, dir );
            break;
        }

        if ( prevspeed < gibspeed * waittime && !firstloop )
            break;

        prevorigin = self.origin;
        prevvel = vel;
        prevspeed = speed;
    }
}

gib_ragdoll( localclientnum, hitdir )
{

}

maze_floor_controller_rumble( localclientnum, set, newent )
{
    player = getlocalplayers()[localclientnum];

    if ( player getentitynumber() != self getentitynumber() )
        return;

    if ( set )
        self thread maze_rumble_while_floor_shakes( localclientnum );
    else
    {
        self notify( "stop_maze_rumble" );
        self stoprumble( localclientnum, "slide_rumble" );
    }
}

maze_rumble_while_floor_shakes( int_client_num )
{
    self endon( "stop_maze_rumble" );

    while ( isdefined( self ) )
    {
        self playrumbleonentity( int_client_num, "slide_rumble" );
        wait 0.05;
    }
}

waterfall_triggers_init()
{
    trigs = getentarray( 0, "waterfall_fog_change", "targetname" );

    if ( !isdefined( trigs ) )
        return;

    for ( i = 0; i < trigs.size; i++ )
        trigs[i] thread waterfall_fog_trigger();
}

waterfall_fog_trigger()
{

}
