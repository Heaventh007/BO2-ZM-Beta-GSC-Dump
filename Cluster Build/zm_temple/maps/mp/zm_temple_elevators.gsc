// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include animscripts\zombie_utility;
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zm_temple;
#include maps\mp\zm_temple_pack_a_punch;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_blockers;

init_elevator()
{
    init_temple_geyser();
}

init_temple_geyser()
{
    level.geysers = getentarray( "temple_geyser", "targetname" );

    for ( i = 0; i < level.geysers.size; i++ )
    {
        level.geysers[i].enabled = 0;
        level.geysers[i].line_emitter = i;
        geysertrigger = level.geysers[i];
        parms = strtok( geysertrigger.script_parameters, "," );
        geysertrigger.push_x = float( parms[0] );
        geysertrigger.push_y = float( parms[1] );
        geysertrigger.push_z = float( parms[2] );
        geysertrigger.push_time = float( parms[3] );
        geysertrigger.lift = getent( geysertrigger.target, "targetname" );
        geysertrigger.bottom = getstruct( geysertrigger.target, "targetname" );

        if ( !isdefined( geysertrigger.bottom.angles ) )
            geysertrigger.bottom.angles = ( 0, 0, 0 );

        geysertrigger.top = getstruct( geysertrigger.bottom.target, "targetname" );

        if ( !isdefined( geysertrigger.top.angles ) )
            geysertrigger.top.angles = ( 0, 0, 0 );

        geysertrigger.trigger_dust = getent( "trigger_" + geysertrigger.script_noteworthy + "_dust", "targetname" );

        if ( isdefined( geysertrigger.trigger_dust ) )
            geysertrigger.trigger_dust thread geyser_trigger_dust_think();

        if ( isdefined( geysertrigger.script_noteworthy ) )
        {
            flag_init( geysertrigger.script_noteworthy + "_active" );
            blocker = getent( geysertrigger.script_noteworthy + "_blocker", "targetname" );

            if ( isdefined( blocker ) )
                geysertrigger thread geyser_blocker_think( blocker );

            geysertrigger.jump_down_start = getnode( geysertrigger.script_noteworthy + "_jump_down", "targetname" );

            if ( isdefined( geysertrigger.jump_down_start ) )
                geysertrigger.jump_down_end = getnode( geysertrigger.jump_down_start.target, "targetname" );
        }
    }
}

alternate_geysers()
{
    currentgeyser = undefined;
    level waittill( "geyser_enabled" );

    while ( true )
    {
        geysers = [];

        for ( i = 0; i < level.geysers.size; i++ )
        {
            g = level.geysers[i];

            if ( ( !isdefined( currentgeyser ) || g != currentgeyser ) && g.enabled )
                geysers[geysers.size] = g;
        }

        if ( isdefined( currentgeyser ) )
        {
            currentgeyser notify( "geyser_end" );
            currentgeyser = undefined;
        }

        if ( geysers.size > 0 )
        {
            currentgeyser = random( geysers );
            currentgeyser thread geyser_start();
        }

        level waittill( "between_round_over" );
    }
}

geyser_start()
{
    self.geyser_active = 0;
    self thread geyser_watch_for_player();
}

geyser_watch_for_zombies()
{
    self endon( "geyser_end" );

    while ( true )
    {
        self waittill( "trigger", who );

        if ( !self.geyser_active )
            continue;

        if ( isai( who ) )
            who zombie_geyser_kill();
    }
}

geyser_watch_for_player()
{
    self endon( "geyser_end" );
    level endon( "intermission" );
    level endon( "fake_death" );

    while ( true )
    {
        self waittill( "trigger", who );

        if ( !isplayer( who ) )
            continue;

        if ( who.sessionstate == "spectator" )
            continue;

        if ( !self.geyser_active )
        {
            if ( who.origin[2] - self.bottom.origin[2] > 70 )
                continue;
        }

        if ( self.geyser_active )
        {
            who thread player_geyser_move( self );
            continue;
        }

        self playsound( "evt_geyser_buildup" );
        starttime = gettime();
        players = get_players();

        while ( true )
        {
            playerstouching = [];

            for ( i = 0; i < players.size; i++ )
            {
                if ( players[i] istouching( self ) )
                    playerstouching[playerstouching.size] = players[i];
            }

            if ( playerstouching.size == 0 )
                break;

            earthquake( 0.2, 0.1, self.bottom.origin, 100 );

            if ( gettime() - starttime > 1800 )
            {
                self thread geyser_activate( playerstouching );
                break;
            }

            wait 0.1;
        }
    }
}

geyser_activate( playerstouching )
{
    self geyser_erupt( playerstouching );
    wait 5;
}

geyser_erupt( playerstouching )
{
    self.geyser_active = 1;

    if ( isdefined( self.trigger_dust ) )
        self.trigger_dust thread geyser_trigger_dust_activate();

    self thread geyser_fx();

    if ( isdefined( self.line_emitter ) )
        clientnotify( "ge" + self.line_emitter );

    for ( i = 0; i < playerstouching.size; i++ )
    {
        playerstouching[i] thread player_geyser_move( self );
        playerstouching[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "geyser" );
    }

    if ( isdefined( self.jump_down_start ) && isdefined( self.jump_down_end ) )
        unlinknodes( self.jump_down_start, self.jump_down_end );

    flag_set( self.script_noteworthy + "_active" );
    wait 10;
    self notify( "stop_geyser_fx" );
    flag_clear( self.script_noteworthy + "_active" );

    if ( isdefined( self.jump_down_start ) && isdefined( self.jump_down_end ) )
        linknodes( self.jump_down_start, self.jump_down_end );

    self.geyser_active = 0;
}

player_geyser_move( geyser )
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "spawned_spectator" );

    if ( is_true( self.riding_geyser ) || is_true( self.intermission ) )
        return;

    self.riding_geyser = 1;

    if ( self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
        self.geyser_anim = level._cf_player_geyser_fake_player_setup_prone;
    else if ( self getstance() == "prone" )
    {
        self setclientflag( level._cf_player_geyser_fake_player_setup_prone );
        self.geyser_anim = level._cf_player_geyser_fake_player_setup_prone;
    }
    else
    {
        self setclientflag( level._cf_player_geyser_fake_player_setup_stand );
        self.geyser_anim = level._cf_player_geyser_fake_player_setup_stand;
    }

    if ( !self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
        self ghost();

    self.geyser_dust_time = gettime() + 2000;
    scale = ( geyser.top.origin[2] - self.origin[2] ) / ( geyser.top.origin[2] - geyser.bottom.origin[2] );
    scale = clamp( scale, 0.4, 1.0 );
    mover = spawn( "script_origin", self.origin );
    self playerlinkto( mover );
    x = geyser.push_x;
    y = geyser.push_y;
    z = geyser.push_z * scale;
    time = geyser.push_time * scale;
/#
    if ( getdvarint( #"_id_1EBA666E" ) )
    {
        x = getdvarfloat( #"_id_0B8472AB" );
        y = getdvarfloat( #"_id_0B8472AC" );
        z = getdvarfloat( #"_id_0B8472AD" );
        time = getdvarfloat( #"_id_CBE49262" );
    }
    else
        setdvar( "geyser_tweak_push", "0" );
#/

    if ( self.sessionstate == "playing" )
    {

    }

    mover movegravity( ( x, y, z ), time );
    self player_geyser_move_wait( time );
    vel = self getvelocity();

    if ( isdefined( self ) )
    {
        self clearclientflag( self.geyser_anim );
        wait_network_frame();
        self show();
    }

    self unlink();
    mover delete();

    if ( y > 0 )
        self setvelocity( vel + vectorscale( ( 0, 1, 0 ), 175.0 ) );
    else
        self setvelocity( vel + vectorscale( ( 0, -1, 0 ), 175.0 ) );

    wait 0.1;
    self.riding_geyser = 0;
}

player_geyser_move_wait( waittime )
{
    self endon( "death" );
    self endon( "player_downed" );
    wait( waittime );
}

geyser_erupt_old( playerstouching )
{
    self.geyser_active = 1;
    self thread geyser_fx();
    moveuptime = 0.5;
    movedowntime = 0.1;
    movedist = 500;
    lift = getent( "geyser_lift", "targetname" );
    wait 0.1;
    start_origin = self.lift.origin;
    start_angles = self.lift.angles;

    for ( i = 0; i < playerstouching.size; i++ )
        playerstouching[i] setplayerangles( self.bottom.angles );

    self.lift movez( movedist, moveuptime, 0.1, 0.3 );
    wait( moveuptime );
    bouncetime = 0.3;
    bouncedist = 20;

    for ( i = 0; i < 2; i++ )
    {
        self.lift movez( bouncedist, bouncetime, bouncetime / 2, bouncetime / 2 );
        wait( bouncetime );
        self.lift movez( -1 * bouncedist, bouncetime, bouncetime / 2, bouncetime / 2 );
        wait( bouncetime );
    }

    self.lift movez( -250, 3, 0.2, 0.2 );
    wait 3;
    self.lift notsolid();
    self.lift.angles = start_angles;
    self.lift.origin = start_origin;
    wait 0.1;
    self.lift solid();
    wait 5;
    self notify( "stop_geyser_fx" );
    self.geyser_active = 0;
}

geyser_fx()
{
    self thread geyser_earthquake();
    fxobj = spawnfx( level._effect["fx_ztem_geyser"], self.bottom.origin );
    triggerfx( fxobj );
    self waittill( "stop_geyser_fx" );
    wait 5;
    fxobj delete();
}

geyser_earthquake()
{
    self endon( "stop_geyser_fx" );

    while ( true )
    {
        earthquake( 0.2, 0.1, self.origin, 100 );
        wait 0.1;
    }
}

zombie_geyser_kill()
{
    self startragdoll();
    self launchragdoll( ( 0, 0, 1 ) * 300 );
    wait_network_frame();
    self dodamage( self.health + 666, self.origin );
}

geyser_blocker_think( blocker )
{
    switch ( self.script_noteworthy )
    {
        case "start_geyser":
            flag_wait_any( "cave02_to_cave_water", "cave_water_to_power", "cave_water_to_waterfall" );
            exploder( 8 );
            geyser_sounds( "geyser02", "evt_water_spout02", "evt_geyser_amb", 1.0 );
            break;
        case "minecart_geyser":
            flag_wait_any( "start_to_pressure", "pressure_to_cave01" );
            flag_wait_any( "cave01_to_cave02", "pressure_to_cave01" );
            exploder( 9 );
            geyser_sounds( "geyser01", "evt_water_spout01", "evt_geyser_amb", 1.0 );
        default:
            break;
    }

    blocker thread geyser_blocker_remove();
    self thread geyser_start();
    self.enabled = 1;
    level notify( "geyser_enabled", self );
}

geyser_sounds( struct_name, sfx_start, sfx_loop, sfx_loop_delay )
{
    sound_struct = getstruct( struct_name, "targetname" );

    if ( isdefined( sound_struct ) )
    {
        level thread play_sound_in_space( sfx_start, sound_struct.origin );

        if ( isdefined( sfx_loop_delay ) && sfx_loop_delay > 0.0 )
            wait( sfx_loop_delay );

        ambient_ent = spawn( "script_origin", ( 0, 0, 1 ) );

        if ( isdefined( ambient_ent ) )
            ambient_ent.origin = sound_struct.origin;
    }
}

geyser_blocker_remove()
{
    clip = getent( self.target, "targetname" );
    clip delete();
    struct = spawnstruct();
    struct.origin = self.origin + vectorscale( ( 0, 0, 1 ), 500.0 );
    struct.angles = self.angles + vectorscale( ( 0, 1, 0 ), 180.0 );
    self.script_noteworthy = "jiggle";
    self.script_firefx = "poltergeist";
    self.script_fxid = "large_ceiling_dust";
    self maps\mp\zombies\_zm_blockers::debris_move( struct );
}

geyser_trigger_dust_activate()
{
    self trigger_on();
    wait 3;
    self trigger_off();
}

geyser_trigger_dust_think()
{
    while ( true )
    {
        self waittill( "trigger", player );

        if ( isdefined( player ) && isdefined( player.geyser_dust_time ) && player.geyser_dust_time > gettime() )
        {
            playfx( level._effect["player_land_dust"], player.origin );
            player playsound( "fly_bodyfall_large_dirt" );
            player.geyser_dust_time = 0;
        }
    }
}
