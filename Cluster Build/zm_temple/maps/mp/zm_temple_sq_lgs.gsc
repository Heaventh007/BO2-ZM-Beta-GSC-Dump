// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include common_scripts\utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_temple_sq_brock;
#include maps\mp\zm_temple_sq_skits;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_weap_shrink_ray;

init()
{
    precachevehicle( "misc_freefall" );
    precachemodel( "p_ztem_glyphs_00" );
    precachemodel( "fxanim_zom_ztem_crystal_small_mod" );
    precachemodel( "p_ztem_crystal" );
    flag_init( "meteor_impact" );
    declare_sidequest_stage( "sq", "LGS", ::init_stage, ::stage_logic, ::exit_stage );
    set_stage_time_limit( "sq", "LGS", 300 );
    declare_stage_asset_from_struct( "sq", "LGS", "sq_lgs_crystal", ::lgs_crystal );
}

init_stage()
{
    maps\mp\zm_temple_sq_brock::delete_radio();
    flag_clear( "meteor_impact" );
    level thread lgs_intro();
/#
    if ( get_players().size == 1 )
        get_players()[0] giveweapon( "shrink_ray_upgraded_zm" );
#/
}

lgs_intro()
{
    exploder( 600 );
    wait 4.0;
    level thread play_intro_audio();
    exploder( 601 );
    level thread maps\mp\zm_temple_sq_skits::start_skit( "tt3" );
    level thread play_nikolai_farting();
    wait 2.0;
    wait 1.5;
    earthquake( 1, 0.8, get_players()[0].origin, 200 );
    wait 1.0;
    flag_set( "meteor_impact" );
}

play_nikolai_farting()
{
    level endon( "sq_LGS_over" );
    wait 2;
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] getentitynumber() == 1 )
        {
            players[i] playsound( "evt_sq_lgs_fart" );
            return;
        }
    }
}

play_intro_audio()
{
    playsoundatposition( "evt_sq_lgs_meteor_incoming", ( -1680, -780, 147 ) );
    wait 3.3;
    playsoundatposition( "evt_sq_lgs_meteor_impact", ( -1229, -1642, 198 ) );
}

first_damage()
{
    self endon( "death" );
    self endon( "first_damage_done" );

    while ( true )
    {
        self waittill( "damage", amount, attacker, direction, point, dmg_type, modelname, tagname );

        if ( isplayer( attacker ) && ( dmg_type == "MOD_PROJECTILE" || dmg_type == "MOD_PROJECTILE_SPLASH" || dmg_type == "MOD_EXPLOSIVE" || dmg_type == "MOD_EXPLOSIVE_SPLASH" || dmg_type == "MOD_GRENADE" || dmg_type == "MOD_GRENADE_SPLASH" ) )
        {
            self.owner_ent notify( "triggered" );
            attacker thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 1 );
            return;
        }

        if ( isplayer( attacker ) )
            attacker thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 2 );
    }
}

wait_for_player_to_get_close()
{
    self endon( "death" );
    self endon( "first_damage_done" );

    while ( true )
    {
        players = get_players();

        for ( i = 0; i < players.size; i++ )
        {
            if ( distancesquared( self.origin, players[i].origin ) <= 250000 )
            {
                players[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 0 );
                return;
            }
        }

        wait 0.1;
    }
}

report_melee_early()
{
    self endon( "death" );
    self endon( "shrunk" );

    while ( true )
    {
        self waittill( "damage", amount, attacker, direction, point, dmg_type, modelname, tagname );

        if ( isplayer( attacker ) && dmg_type == "MOD_MELEE" )
        {
            attacker thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 3 );
            wait 5.0;
        }
    }
}

wait_for_melee()
{
    self endon( "death" );

    while ( true )
    {
        self waittill( "damage", amount, attacker, direction, point, dmg_type, modelname, tagname );

        if ( isplayer( attacker ) && dmg_type == "MOD_MELEE" )
        {
            self.owner_ent notify( "triggered" );
            attacker thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 6 );
            return;
        }
    }
}

check_for_closed_slide( ent )
{
    if ( !flag( "waterslide_open" ) )
    {
        self endon( "death" );
        self endon( "reached_end_node" );

        while ( true )
        {
            self waittill( "reached_node", node );

            if ( isdefined( node.script_noteworthy ) && node.script_noteworthy == "pre_gate" )
            {
                if ( !flag( "waterslide_open" ) )
                {
                    players = get_players();

                    for ( i = 0; i < players.size; i++ )
                    {
                        if ( distancesquared( self.origin, players[i].origin ) <= 250000 )
                            players[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 7 );
                    }

                    self._crystal stopanimscripted();

                    while ( !flag( "waterslide_open" ) )
                    {
                        self setspeedimmediate( 0 );
                        wait 0.05;
                    }

                    wait 0.5;
                    self resumespeed( 12 );
                    return;
                }
            }
        }
    }
}

water_trail( ent )
{
    self endon( "death" );

    while ( true )
    {
        self waittill( "reached_node", node );

        if ( isdefined( node.script_int ) )
        {
            if ( node.script_int == 1 )
                ent setclientflag( level._cf_scriptmover_client_flag_water_trail );
            else if ( node.script_int == 0 )
                ent clearclientflag( level._cf_scriptmover_client_flag_water_trail );
        }
    }
}

lgs_crystal()
{
    self endon( "death" );
    self hide();
    flag_wait( "meteor_impact" );
    self show();
    self.trigger = spawn( "trigger_damage", self.origin, 0, 32, 72 );
    self.trigger.owner_ent = self;
    self.trigger thread first_damage();
    self.trigger thread wait_for_player_to_get_close();
    exploder( 602 );
    self waittill( "triggered" );
    self.trigger notify( "first_damage_done" );
    stop_exploder( 602 );
    self playsound( "evt_sq_lgs_crystal_pry" );

    for ( target = self.target; isdefined( target ); target = struct.target )
    {
        struct = getstruct( target, "targetname" );
        time = struct.script_float;

        if ( !isdefined( time ) )
            time = 1.0;

        self moveto( struct.origin, time, time / 10 );
        self waittill( "movedone" );
        self playsound( "evt_sq_lgs_crystal_hit1" );
    }

    self playsound( "evt_sq_lgs_crystal_land" );
    self.trigger.origin = self.origin;
    self.trigger thread report_melee_early();
    maps\mp\zombies\_zm_weap_shrink_ray::add_shrinkable_object( self );
    self waittill( "shrunk" );
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        currentweapon = players[i] getcurrentweapon();

        if ( currentweapon == "shrink_ray_zm" || currentweapon == "shrink_ray_upgraded_zm" )
            players[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 4 );
    }

    self playsound( "evt_sq_lgs_crystal_shrink" );
    self setmodel( "fxanim_zom_ztem_crystal_small_mod" );
    vn = getvehiclenode( "sq_lgs_node_start", "targetname" );
    self.origin = vn.origin;
    self.trigger notify( "shrunk" );
    maps\mp\zombies\_zm_weap_shrink_ray::remove_shrinkable_object( self );
    self.trigger thread wait_for_melee();
    self waittill( "triggered" );
    self playsound( "evt_sq_lgs_crystal_knife" );
    self playloopsound( "evt_sq_lgs_crystal_roll", 2 );
    self.trigger trigger_off();
    self notsolid();
    vehicle = spawnvehicle( "p_ztem_glyphs_00", "crystal_mover", "misc_freefall", self.origin, self.angles );
    vehicle hide();
    vehicle._crystal = self;
    level._lgs_veh = vehicle;
    wait_network_frame();
    origin_animate = spawn( "script_model", vehicle.origin );
    origin_animate setmodel( "tag_origin_animate" );
    self linkto( origin_animate, "origin_animate_jnt", ( 0, 0, 0 ), vectorscale( ( 1, 0, 0 ), 90.0 ) );
    origin_animate linkto( vehicle );
    vehicle attachpath( getvehiclenode( "sq_lgs_node_start", "targetname" ) );
    vehicle startpath();
    vehicle._origin_animate = origin_animate;
    vehicle thread water_trail( self );
    vehicle thread check_for_closed_slide( self );
    vehicle waittill( "reached_end_node" );
    self stopanimscripted();
    self unlink();
    self thread crystal_bobble();
    vehicle delete();
    origin_animate delete();
    flag_wait( "minecart_geyser_active" );
    self notify( "kill_bobble" );
    self setclientflag( level._cf_scriptmover_client_flag_water_trail );
    self moveto( self.origin + vectorscale( ( 0, 0, 1 ), 4000.0 ), 2, 0.1 );
    level notify( "suspend_timer" );
    level notify( "raise_crystal_1" );
    level notify( "raise_crystal_2" );
    level notify( "raise_crystal_3", 1 );
    level waittill( "raised_crystal_3" );
    self clearclientflag( level._cf_scriptmover_client_flag_water_trail );
    wait 2;
    holder = getent( "empty_holder", "script_noteworthy" );
    self.origin = ( holder.origin[0], holder.origin[1], self.origin[2] );
    self setmodel( "p_ztem_crystal" );
    playsoundatposition( "evt_sq_lgs_crystal_incoming", ( holder.origin[0], holder.origin[1], holder.origin[2] + 134 ) );
    self moveto( ( holder.origin[0], holder.origin[1], holder.origin[2] + 134 ), 2 );
    self waittill( "movedone" );
    self stoploopsound( 1 );
    self playsound( "evt_sq_lgs_crystal_landinholder" );
    players = get_players();
    players[randomintrange( 0, players.size )] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest3", undefined, 8 );
    level notify( "crystal_dropped" );
    self hide();
    wait 5.0;
    stage_completed( "sq", "LGS" );
}

crystal_spin()
{
    self endon( "death" );
    self endon( "kill_bobble" );

    while ( true )
    {
        t = randomfloatrange( 0.2, 0.8 );
        self rotateto( ( 180 + randomfloat( 180 ), 300 + randomfloat( 60 ), 180 + randomfloat( 180 ) ), t );
        wait( t );
    }
}

crystal_bobble()
{
    self endon( "death" );
    self endon( "kill_bobble" );
    self thread crystal_spin();
    node = getvehiclenode( "crystal_end", "script_noteworthy" );
    bottom_pos = node.origin + vectorscale( ( 0, 0, 1 ), 4.0 );
    top_pos = bottom_pos + vectorscale( ( 0, 0, 1 ), 3.0 );

    while ( true )
    {
        self moveto( top_pos + ( 0, 0, randomfloat( 3 ) ), 0.2 + randomfloat( 0.1 ), 0.1 );
        self waittill( "movedone" );
        self moveto( bottom_pos + ( 0, 0, randomfloat( 5 ) ), 0.05 + randomfloat( 0.07 ), 0, 0.03 );
        self waittill( "movedone" );
    }
}

stage_logic()
{

}

exit_stage( success )
{
    if ( isdefined( level._lgs_veh ) )
    {
        if ( isdefined( level._lgs_veh._origin_animate ) )
            level._lgs_veh._origin_animate delete();

        level._lgs_veh delete();
    }

    level._lgs_veh = undefined;

    if ( success )
        maps\mp\zm_temple_sq_brock::create_radio( 4, maps\mp\zm_temple_sq_brock::radio4_override );
    else
    {
        maps\mp\zm_temple_sq_brock::create_radio( 3 );
        level thread maps\mp\zm_temple_sq_skits::fail_skit();
    }
}
