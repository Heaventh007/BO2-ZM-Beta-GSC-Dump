// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_utility_raven;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zombies\_zm_audio;

precache_assets()
{
    level._effect["fx_headlight"] = loadfx( "env/light/fx_flashlight_ai_spotlight" );
    precachemodel( "p6_zm_tm_veh_minecart" );
    precacherumble( "tank_rumble" );
    precacherumble( "damage_heavy" );
}

minecart_main()
{
    flag_init( "players_riding_minecart" );
    level.minecart_levers = getentarray( "minecart_lever_trigger", "targetname" );

    for ( i = 0; i < level.minecart_levers.size; i++ )
        level.minecart_levers[i] thread minecart_lever_think();

    if ( getdvar( #"_id_29B5091E" ) == "" )
        setdvar( "minecart_debug", "0" );
}

minecart_setup()
{
    self.drivepath = 0;
    self.accel = 5;
    self.decel = 30;
    self.loopingpath = isdefined( self.script_string ) && self.script_string == "loopingPath";
    self.away = 0;
    self.passengers = [];
    self.floorheight = 24;
    self.width = 20;
    self.linkents = [];
    minecart_add_linkent( ( 50, self.width, self.floorheight ) );
    minecart_add_linkent( ( 50, 0 - self.width, self.floorheight ) );
    minecart_add_linkent( ( -66, self.width, self.floorheight ) );
    minecart_add_linkent( ( -66, 0 - self.width, self.floorheight ) );
    minecart_add_linkent( ( -8, 0, self.floorheight ) );
    self.headlights_offset = ( 87, 0, 15 );
    self.headlights_angles = ( 0, 0, 0 );
    self.headlights_offset_reverse = ( 0 - self.headlights_offset[0], self.headlights_offset[1], self.headlights_offset[2] );
    self.headlights_angles_reverse = vectorscale( ( 0, 1, 0 ), 180.0 );
    self.start_switch = getent( self.targetname + "_start_switch", "targetname" );
    self.cage = getent( self.targetname + "_cage", "targetname" );

    if ( isdefined( self.cage ) )
        self.cage linkto( self );

    self.cage_door = getent( self.targetname + "_cage_door", "targetname" );

    if ( isdefined( self.cage_door ) )
    {
        self.cage_door linkto( self );
        self.cage_door notsolid();
    }

    self.door = getent( self.targetname + "_door", "targetname" );

    if ( isdefined( self.door ) )
    {
        self.door.closed = 1;
        self.door.clip = getent( self.targetname + "_door_clip", "targetname" );
        self thread _minecart_open_door( 1.0 );
    }

    self.pusher = getent( self.targetname + "_pusher", "targetname" );

    if ( isdefined( self.pusher ) )
        self.pusher.out = 0;

    self.floor = getent( self.targetname + "_floor", "targetname" );

    if ( isdefined( self.floor ) )
        self.floor linkto( self );

    self.front = getent( self.targetname + "_front", "targetname" );

    if ( isdefined( self.front ) )
        self.front linkto( self );

    self.front_doors = getentarray( self.targetname + "_front_door", "targetname" );
    self.front_doors_closed = 1;
    self.front_doors_clip = getent( self.targetname + "_front_door_clip", "targetname" );
    self.start_volume = getent( self.targetname + "_start_volume", "targetname" );

    if ( isdefined( self.start_volume ) )
    {
        self.start_volume.minecart = self;
        self.start_volume thread show_players_on_mine_cart();
    }

    self.trigger_splash = getent( "trigger_minecart_water_splash", "targetname" );

    if ( isdefined( self.trigger_splash ) )
        self.trigger_splash thread minecart_trigger_splash_think();

    self.speaker_left = spawn( "script_model", self.origin );
    self.speaker_left setmodel( "tag_origin" );
    self.speaker_left linkto( self, "tag_origin", ( 0, 32.0, 40.0 ) );
    wait_network_frame();
    self.speaker_right = spawn( "script_model", self.origin );
    self.speaker_right setmodel( "tag_origin" );
    self.speaker_right linkto( self, "tag_origin", ( 0, -32.0, 40.0 ) );
    blockers = getentarray( self.targetname + "_blocker", "targetname" );
    array_thread( blockers, ::blocker_init, self );
    level.minecart_force_zone_active = 0;
    self minecart_begin_path( "start" );
    self minecart_stop();
}

blocker_init( minecart )
{
    self.unbroken = getent( self.target, "targetname" );
    self.broken = getent( self.unbroken.target, "targetname" );

    if ( isdefined( self.broken ) )
        self.broken ghost();

    self thread blocker_think( minecart );
}

blocker_think( minecart )
{
    minecart endon( "minecart_end" );
    minecart waittill( "minecart_start" );

    while ( true )
    {
        if ( self blocker_is_mine_cart_touching( minecart ) )
        {
            self thread blocker_break();
            break;
        }

        wait 0.05;
    }
}

blocker_is_mine_cart_touching( minecart )
{
    dist2 = distance2dsquared( minecart.origin, self.origin );
    return dist2 < 4900;
}

blocker_is_any_player_touching()
{
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] istouching( self ) )
            return true;
    }

    return false;
}

blocker_break()
{
    self.unbroken delete();
    self.broken show();
    exploder( 400 );
    self playsound( "evt_minecart_barrier" );
}

minecart_add_linkent( offsetorigin )
{
    linkent = spawn( "script_model", ( 0, 0, 0 ) );
    linkent.offsetorigin = offsetorigin;
    linkent linkto( self, "", linkent.offsetorigin, ( 0, 0, 0 ) );
    linkent setmodel( "tag_origin_animate" );
    linkent.occupied = 0;
    self.linkents[self.linkents.size] = linkent;
    wait_network_frame();
}

minecart_link_passengers()
{
    wait 0.5;
    players = getplayers();

    if ( isdefined( self.cage_door ) )
        self.cage_door solid();

    for ( i = 0; i < self.linkents.size; i++ )
        self.linkents[i].claimed = 0;

    linkplayers = [];

    for ( p = 0; p < players.size; p++ )
    {
        player = players[p];
        closestent = undefined;
        closestdist = 0.0;
        playernear = self minecart_contains( player );

        if ( !playernear )
            continue;

        linkplayers[linkplayers.size] = player;

        for ( e = 0; e < self.linkents.size; e++ )
        {
            linkent = self.linkents[e];
            dist = distancesquared( player.origin, linkent.origin );

            if ( !linkent.claimed && ( !isdefined( closestent ) || dist < closestdist ) )
            {
                closestent = linkent;
                closestdist = dist;
            }
        }

        closestent.claimed = 1;
        player.minecart_link = closestent;
    }

    array_thread( linkplayers, ::player_minecart_ride, self );
    level thread delayed_player_response_to_minecart_ride( linkplayers );
    zombies = getaispeciesarray( "axis", "all" );
    zombie_sort = get_array_of_closest( self.origin, zombies, undefined, undefined, 300.0 );
    self.linkzombies = [];

    for ( i = 0; i < zombie_sort.size; i++ )
    {
        zombie = zombie_sort[i];
        closestent = undefined;
        closestdist = 0.0;

        if ( zombie.animname == "monkey_zombie" )
            continue;

        if ( is_true( zombie.shrinked ) )
            continue;

        zombienear = self minecart_contains( zombie );

        if ( !zombienear )
            continue;

        for ( e = 0; e < self.linkents.size; e++ )
        {
            linkent = self.linkents[e];
            dist = distancesquared( zombie.origin, linkent.origin );

            if ( !linkent.claimed && ( !isdefined( closestent ) || dist < closestdist ) )
            {
                closestent = linkent;
                closestdist = dist;
            }
        }

        if ( isdefined( closestent ) )
        {
            closestent.claimed = 1;
            zombie.minecart_link = closestent;
            self.linkzombies[self.linkzombies.size] = zombie;
        }
    }

    array_thread( self.linkzombies, ::zombie_minecart_ride, self );
}

player_minecart_ride( minecart )
{
    self endon( "death" );
    self endon( "disconnect" );
    level endon( "minecart_end" );
    self.is_on_minecart = 1;
    self allowsprint( 0 );
    turn_angle = 360;
    pitch_up = 90;
    pitch_down = 75;

    if ( self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
    {
        self setorigin( self.minecart_link.origin );

        while ( self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
            wait 0.1;
    }
    else
    {
        self enableinvulnerability();
        self playerlinktominecart( 360 );
        wait 1.0;
    }

    self enableinvulnerability();
    self playerlinktominecart( 360 );
    self thread minecart_screen_shake();
}

zombie_minecart_ride( minecart )
{
    level endon( "minecart_end" );
    self setplayercollision( 0 );
    self linkto( self.minecart_link, "tag_origin", ( 0, 0, 0 ), ( 0, 0, 0 ) );
    self waittill( "death" );
    self unlink();
}

minecart_screen_shake( activetime )
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "minecart_exit" );

    while ( true )
    {
        earthquake( randomfloatrange( 0.1, 0.2 ), randomfloatrange( 1, 2 ), self.origin, 100, self );
        wait( randomfloatrange( 0.1, 0.3 ) );
    }
}

playerlinktominecart( view_yaw )
{
    if ( !self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
    {
        self setstance( "crouch" );
        self allowstand( 0 );
        self allowprone( 0 );
    }

    self playerlinktodelta( self.minecart_link, undefined, 1, view_yaw, view_yaw, 90, 75, 1 );
}

minecart_unlink_passengers( throw_velocity )
{
    self notify( "minecart_end" );
    level notify( "minecart_end" );

    if ( isdefined( self.front ) )
        self.front notsolid();

    players = getplayers();

    for ( i = 0; i < players.size; i++ )
    {
        player = players[i];

        if ( isdefined( player.minecart_link ) )
        {
            player unlink();
            player setvelocity( throw_velocity );
            player.minecart_link = undefined;
            player.is_on_minecart = 0;
            inlaststand = player maps\mp\zombies\_zm_laststand::player_is_in_laststand();

            if ( !inlaststand )
            {
                player allowcrouch( 1 );
                player allowprone( 1 );
                player allowlean( 1 );
                player allowstand( 1 );
                player setstance( "stand" );
            }

            player allowsprint( 1 );
        }
    }
}

minecart_throw_zombie( zombie, vel )
{
    if ( !isdefined( zombie ) )
        return;

    zombie startragdoll();
    zombie launchragdoll( vel );
    wait_network_frame();
    level.zombie_total++;

    if ( isdefined( zombie ) )
        zombie dodamage( zombie.health + 666, zombie.origin );
}

minecart_contains( ent )
{
    if ( isdefined( self.start_volume ) )
        return ent istouching( self.start_volume );
    else
        return distance2d( ent.origin, self.origin ) < 120.0;
}

_minecart_fire_spikemores()
{
    if ( !isdefined( level.spikemores ) || level.spikemores.size <= 0 )
        return;

    minecart_spikemores = [];

    for ( i = 0; i < level.spikemores.size; i++ )
    {
        if ( !isdefined( level.spikemores[i] ) )
            continue;

        trace = groundtrace( level.spikemores[i].origin, level.spikemores[i].origin + vectorscale( ( 0, 0, -1 ), 24.0 ), 0, level.spikemores[i] );

        if ( isdefined( trace["entity"] ) )
        {
            if ( self == trace["entity"] || isdefined( self.floor ) && self.floor == trace["entity"] )
                minecart_spikemores[minecart_spikemores.size] = level.spikemores[i];
        }
    }

    if ( minecart_spikemores.size )
        array_thread( minecart_spikemores, ::minecart_spikemore_detonate );
}

minecart_spikemore_detonate()
{

}

minecart_begin_path( name )
{
    node = getvehiclenode( self.targetname + "_" + name, "targetname" );

    if ( isdefined( node ) )
    {
        self attachpath( node );
        self startpath();
    }
}

minecart_start( accel )
{
    self notify( "minecart_start" );

    if ( !isdefined( accel ) )
        accel = self.accel;

    self resumespeed( accel );
    self thread minecart_animate_wheels();
}

minecart_animate_wheels()
{
    self endon( "death" );

    if ( !isdefined( self.wheel_spin_scale ) )
        self.wheel_spin_scale = 1.0;

    self waittill( "wheels_turn_stop" );
}

minecart_stop( accel, decel )
{
    if ( !isdefined( accel ) )
        accel = self.accel;

    if ( !isdefined( decel ) )
        decel = self.decel;

    self setspeed( 0, accel, decel );
    self notify( "wheels_turn_stop" );
}

minecart_stop_instant()
{
    self setspeed( 0, 10000 );
    self notify( "wheels_turn_stop" );
}

minecart_lever_move( to_on_position )
{
    play_sound_at_pos( "grab_metal_bar", self.origin );

    if ( self.makeinvisible )
    {
        if ( to_on_position )
            self setvisibletoall();
        else
            self setinvisibletoall();
    }
}

minecart_lever_think()
{
    level endon( "fake_death" );

    if ( !isdefined( self.zombie_cost ) )
        self.zombie_cost = 250;

    self.cooldowntimer = 10.0;
    self.makeinvisible = 0;
    self setcursorhint( "HINT_NOICON" );
    self sethintstring( "" );
    self usetriggerrequirelookat();
    self.cost = 250;
    minecart_poi = getent( "minecart_poi", "targetname" );
    minecart_poi create_zombie_point_of_interest( undefined, 30, 0, 0 );
    minecart_poi thread create_zombie_point_of_interest_attractor_positions( 4, 45 );

    if ( isdefined( self.target ) )
        self.minecart = getent( self.target, "targetname" );
    else
        self.minecart = getent( "minecart", "targetname" );

    self.minecart minecart_setup();
    self minecart_lever_move( 0 );
    wait_for_flags = 1;
/#
    wait_for_flags = getdvarint( #"_id_29B5091E" ) == 0;
#/

    if ( wait_for_flags )
    {
        self sethintstring( &"ZOMBIE_NEED_POWER" );
        flag_wait( "power_on" );
        self sethintstring( &"ZOMBIE_TEMPLE_DESTINATION_NOT_OPEN" );
        flag_wait_any( "cave_water_to_waterfall", "waterfall_to_tunnel" );
    }

    wait 1.0;
    level notify( "mine_cart_ready" );

    while ( true )
    {
        self minecart_lever_move( 1 );

        if ( isdefined( self.minecart.cage ) )
            self.minecart.cage solid();

        if ( isdefined( self.minecart.cage_door ) )
            self.minecart.cage_door notsolid();

        if ( isdefined( self.minecart.front ) )
            self.minecart.front solid();

        self sethintstring( &"ZOMBIE_TEMPLE_MINECART_COST", self.zombie_cost );

        while ( true )
        {
            self waittill( "trigger", player );

            if ( player.score >= self.zombie_cost )
            {
                play_sound_at_pos( "purchase", self.origin );
                player maps\mp\zombies\_zm_score::minus_to_player_score( self.zombie_cost );
                break;
            }
        }

        flag_set( "players_riding_minecart" );
        level thread minecart_clean_up_corpses();
        self trigger_off();
        self sethintstring( &"ZOMBIE_TEMPLE_MINECART_UNAVAVILABLE" );

        if ( isdefined( self.minecart.start_switch ) )
        {
            self.minecart.start_switch rotateroll( 180, 0.3, 0.1, 0.1 );
            self.minecart.start_switch waittill( "rotatedone" );
        }

        frontdooropentime = 0.25;
        self.minecart thread _minecart_open_front_door( frontdooropentime );
        self.minecart thread _minecart_fire_spikemores();
        self.minecart thread _minecart_close_door();
        self.minecart thread _minecart_pusher_out();
        self.minecart.away = 1;
        self.minecart minecart_start();
        self.minecart.speaker_left playsound( "evt_minecart_l" );
        self.minecart.speaker_right playsound( "evt_minecart_r" );
        self.minecart.speaker_left playloopsound( "zmb_singing", 5 );
        self thread minecart_lever_move( 0 );
        self.minecart minecart_link_passengers();
        self.minecart thread _minecart_close_front_door_delay( 2.0 );
        cageopentime = 0.5;
        self.minecart thread _minecart_open_door_delay( cageopentime, 2.0 );
        should_activate_poi = check_should_activate_minecart_poi();
        self.minecart thread minecart_activate_zone();
        maps\mp\zombies\_zm_zonemgr::zone_init( "waterfall_lower_zone" );
        maps\mp\zombies\_zm_zonemgr::enable_zone( "waterfall_lower_zone" );

        if ( should_activate_poi )
            minecart_poi activate_zombie_point_of_interest();

        wait 1.0;
        self trigger_on();
        self.minecart waittill( "reached_end_node" );
        self.minecart minecart_crash();
        self.minecart.speaker_left stoploopsound( 1 );
        wait 1.0;
        flag_clear( "players_riding_minecart" );

        if ( should_activate_poi )
            minecart_poi deactivate_zombie_point_of_interest();

        if ( !getdvarint( #"_id_41464E83" ) )
        {
            backvehicle = spawnvehicle( "p6_zm_tm_veh_minecart", self.minecart.targetname + "_reverse", self.minecart.vehicletype, self.minecart.origin, self.minecart.angles );
            backvehicle.drivepath = 0;
            backvehicle.headlights_offset = self.minecart.headlights_offset_reverse;
            backvehicle.headlights_angles = self.minecart.headlights_angles_reverse;
            backvehicle minecart_stop_instant();
            backvehicle minecart_begin_path( "start" );
            backvehicle ghost();
            _minecart_lerp( self.minecart, backvehicle );
            self.minecart.away = 0;
            self.minecart minecart_begin_path( "start" );
            backvehicle waittill( "reached_end_node" );
            backvehicle minecart_stop( self.minecart.accel, self.minecart.decel );
            _minecart_lerp( backvehicle, self.minecart );
            self.minecart playsound( "evt_spiketrap_warn" );
            backvehicle delete();
        }
        else
        {
            self.minecart.away = 0;
            self.minecart minecart_begin_path( "start" );
        }

        if ( isdefined( self.minecart.start_switch ) )
        {
            self.minecart.start_switch rotateroll( -180, 0.3, 0.1, 0.1 );
            self.minecart.start_switch waittill( "rotatedone" );
        }
    }
}

check_should_activate_minecart_poi()
{
    all_players_riding = 1;
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
            continue;

        if ( !is_true( players[i].is_on_minecart ) )
            all_players_riding = 0;
    }

    return all_players_riding;
}

_minecart_lerp( start_vehicle, end_vehicle, time )
{
    model = spawn( "script_model", start_vehicle.origin );
    model setmodel( start_vehicle.model );
    model.angles = start_vehicle.angles;
    start_vehicle ghost();
    model moveto( end_vehicle.origin, 1.0, 0.1, 0.1 );
    rotateangles = ( 0 - end_vehicle.angles[0], end_vehicle.angles[1] - 180, 0 );
    model rotateto( rotateangles, 1.0, 0.1, 0.1 );
    model waittill( "movedone" );
    model delete();
    end_vehicle show();
}

minecart_crash()
{
    speed = 500.0;
    self minecart_stop_instant();
    exploder( 6 );

    if ( isdefined( self.trigger_splash ) )
        self.trigger_splash thread minecart_trigger_splash_activate();

    forward = anglestoforward( self.angles );
    forwarddist = 370.0;
    throw_velocity = forward * forwarddist + vectorscale( ( 0, 0, 1 ), 110.0 );
    time = forwarddist / speed;
    players = getplayers();
    crashed_players = [];

    if ( isdefined( self.front ) )
        self.front notsolid();

    for ( i = 0; i < self.linkzombies.size; i++ )
        self thread minecart_throw_zombie( self.linkzombies[i], throw_velocity / 2 );

    playersonminecart = [];

    for ( i = 0; i < players.size; i++ )
    {
        player = players[i];

        if ( !isdefined( player.minecart_link ) )
            continue;

        playersonminecart[playersonminecart.size] = player;
        crashed_players[crashed_players.size] = player;
        player notify( "minecart_exit" );
        player playrumbleonentity( "damage_heavy" );
        earthquake( 0.5, 2, player.origin, 100, player );
        player.minecart_splash_time = gettime() + 2000;
        player.minecart_link unlink();

        if ( !isdefined( player getlinkedent() ) )
            player playerlinktominecart( 360 );

        player enableinvulnerability();
        player.minecart_link movegravity( throw_velocity, time );
    }

    throw_velocity = ( 0, 0, 0 );
    wait( time * 0.9 - 0.1 );

    if ( playersonminecart.size > 0 )
    {
        old_origin = playersonminecart[0].minecart_link.origin;
        wait 0.1;
        throw_velocity = ( playersonminecart[0].minecart_link.origin - old_origin ) * 10;
    }
    else
        wait 0.1;

    self minecart_unlink_passengers( throw_velocity );
    wait 0.5;

    for ( i = 0; i < self.linkents.size; i++ )
    {
        e = self.linkents[i];
        e unlink();
        e.origin = ( 0, 0, 0 );
        e linkto( self, "", e.offsetorigin, ( 0, 0, 0 ) );
    }
}

minecart_remove_invulnerable()
{
    if ( isdefined( self ) )
        self disableinvulnerability();
}

_poi_ensure_off( minecart )
{
    minecart waittill( "reached_end_node" );
    self deactivate_zombie_point_of_interest();
}

minecart_activate_zone()
{
    trigger = getent( "force_waterfall_active", "script_noteworthy" );

    if ( isdefined( trigger ) )
    {
        trigger waittill( "trigger" );
        level.minecart_force_zone_active = 1;
        self waittill( "reached_end_node" );
        level.minecart_force_zone_active = 0;
    }
}

_minecart_open_door_delay( time, delay )
{
    wait( delay );
    self thread _minecart_open_door( time );
}

_minecart_open_door( time )
{
    if ( isdefined( self.door ) )
    {
        if ( self.door.closed )
        {
            self.door movez( -130, time, 0.1, 0.1 );
            self.door.clip movez( -130, time, 0.1, 0.1 );
            self.door waittill( "movedone" );
            self.door.closed = 0;
            self.door.clip connectpaths();
        }
    }
}

_minecart_close_door()
{
    if ( isdefined( self.door ) )
    {
        if ( !self.door.closed )
        {
            self.door movez( 130, 0.5, 0.1, 0.1 );
            self.door.clip movez( 130, 0.1 );
            self.door waittill( "movedone" );
            self.door.closed = 1;
            self.door.clip disconnectpaths();
        }
    }
}

_minecart_open_front_door( time )
{
    if ( self.front_doors_closed )
    {
        door = undefined;

        for ( i = 0; i < self.front_doors.size; i++ )
        {
            door = self.front_doors[i];
            door rotateyaw( door.script_angles[1], time, 0.1, 0.1 );
        }

        if ( isdefined( door ) )
            door waittill( "rotatedone" );

        self.front_doors_closed = 0;

        if ( isdefined( self.front_doors_clip ) )
            self.front_doors_clip notsolid();
    }
}

_minecart_close_front_door()
{
    if ( !self.front_doors_closed )
    {
        if ( isdefined( self.front_doors_clip ) )
            self.front_doors_clip solid();

        door = undefined;

        for ( i = 0; i < self.front_doors.size; i++ )
        {
            door = self.front_doors[i];
            door rotateyaw( -1 * door.script_angles[1], 1.0, 0.1, 0.1 );
        }

        if ( isdefined( door ) )
            door waittill( "rotatedone" );

        self.front_doors_closed = 1;
    }
}

_minecart_close_front_door_delay( delay )
{
    wait( delay );
    self thread _minecart_close_front_door();
}

_minecart_pusher_out()
{
    if ( isdefined( self.pusher ) )
    {
        if ( !self.pusher.out )
        {
            wait 0.3;
            self.pusher movey( 166, 2.0, 0.25, 0.1 );
            self.pusher waittill( "movedone" );
            self.pusher.out = 1;
            level waittill( "minecart_returned" );
            wait 2.7;
            self thread _minecart_pusher_in();
        }
    }
}

_minecart_pusher_in()
{
    if ( isdefined( self.pusher ) )
    {
        if ( self.pusher.out )
        {
            self.pusher movey( -166, 4.0, 0.25, 0.1 );
            self.pusher waittill( "movedone" );
            self.pusher.out = 0;
        }
    }
}

show_players_on_mine_cart()
{
    height = 0;
    scale = getent( "minecart1_scale", "targetname" );

    if ( !isdefined( scale ) )
        return;

    scale.origin = scale.origin + vectorscale( ( 0, 0, -1 ), 37.0 );
    level waittill( "mine_cart_ready" );

    while ( true )
    {
        count = 0;

        if ( isdefined( self.minecart ) && !self.minecart.away )
        {
            players = getplayers();

            for ( i = 0; i < players.size; i++ )
            {
                if ( players[i] istouching( self ) )
                    count++;
            }
        }

        if ( height < count )
        {
            while ( height < count )
            {
                play_sound_at_pos( "grab_metal_bar", self.origin );
                rise = 0;

                if ( height == 3 )
                    rise = 10;
                else if ( height == 0 )
                    rise = 11;
                else
                    rise = 8;

                height++;

                if ( height == count )
                    rise = rise + 1;

                scale movez( rise, 0.35, 0.05, 0 );
                scale waittill( "movedone" );
            }

            scale movez( -2, 0.2, 0, 0 );
            scale waittill( "movedone" );
            scale movez( 1, 0.1, 0, 0 );
            scale waittill( "movedone" );
        }
        else if ( height > count )
        {
            drop = 0;
            time = 0;
            pop = 2;
            dip = -1;

            while ( height > count )
            {
                if ( height == 4 )
                    drop = drop + -10;
                else if ( height == 1 )
                    drop = drop + -11;
                else
                    drop = drop + -8;

                time = time + 0.2;
                height--;
            }

            if ( height == 0 )
                pop = 1;
            else
                drop = drop + -1;

            play_sound_at_pos( "grab_metal_bar", self.origin );
            scale movez( drop, time, 0.1, 0 );
            scale waittill( "movedone" );
            play_sound_at_pos( "grab_metal_bar", self.origin );
            scale movez( pop, pop * 0.1, 0, 0 );
            scale waittill( "movedone" );
            scale movez( dip, abs( dip * 0.1 ), 0, 0 );
            scale waittill( "movedone" );
        }

        wait 0.1;
    }
}

minecart_trigger_splash_activate()
{
    self trigger_on();
    wait 3;
    self trigger_off();
}

minecart_trigger_splash_think()
{
    while ( true )
    {
        self waittill( "trigger", player );

        if ( isdefined( player ) && isdefined( player.minecart_splash_time ) && player.minecart_splash_time > gettime() )
        {
            playfx( level._effect["player_water_splash"], player.origin );
            player playsound( "fly_bodyfall_large_water" );
            player.minecart_splash_time = 0;
        }
    }
}

delayed_player_response_to_minecart_ride( array )
{
    if ( array.size == 0 )
        return;

    wait 6;
    player = array[randomintrange( 0, array.size )];

    if ( isdefined( player ) && isplayer( player ) )
        player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "mine_ride" );
}

minecart_clean_up_corpses()
{
    corpse_trig = getent( "minecart1_start_volume", "targetname" );
    corpses = getcorpsearray();

    if ( isdefined( corpses ) )
    {
        for ( i = 0; i < corpses.size; i++ )
        {
            if ( corpses[i] istouching( corpse_trig ) )
                corpses[i] thread minecart_remove_corpses();
        }
    }
}

minecart_remove_corpses()
{
    playfx( level._effect["corpse_gib"], self.origin );
    self delete();
}
