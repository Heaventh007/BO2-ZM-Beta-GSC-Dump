// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_utility_raven;
#include maps\mp\zombies\_zm_score;

main()
{
    level thread init_code_triggers();
    level thread init_corpse_triggers();
    level thread init_water_drop_triggers();
    level thread init_slow_trigger();
    level thread init_code_structs();
}

init_code_triggers()
{
    triggers = getentarray( "code_trigger", "targetname" );
    array_thread( triggers, ::trigger_code );
}

trigger_code()
{
    code = self.script_noteworthy;

    if ( !isdefined( code ) )
        code = "DPAD_UP DPAD_UP DPAD_DOWN DPAD_DOWN DPAD_LEFT DPAD_RIGHT DPAD_LEFT DPAD_RIGHT BUTTON_B BUTTON_A";

    if ( !isdefined( self.script_string ) )
        self.script_string = "cash";

    self.players = [];

    while ( true )
    {
        self waittill( "trigger", who );

        if ( is_in_array( self.players, who ) )
            continue;

        who thread watch_for_code_touching_trigger( code, self );
    }
}

watch_for_code_touching_trigger( code, trigger )
{
    trigger.players[trigger.players.size] = self;
    self thread watch_for_code( code );
    self thread touching_trigger( trigger );
    returnnotify = self waittill_any_return( "code_correct", "stopped_touching_trigger", "death" );
    self notify( "code_trigger_end" );

    if ( returnnotify == "code_correct" )
        trigger code_trigger_activated( self );
    else
        trigger.players = array_remove( trigger.players, self );
}

is_in_array( array, item )
{
    foreach ( index in array )
    {
        if ( index == item )
            return true;
    }

    return false;
}

array_remove( array, object )
{
    if ( !isdefined( array ) && !isdefined( object ) )
        return;

    new_array = [];

    foreach ( item in array )
    {
        if ( item != object )
            new_array[new_array.size] = item;
    }

    return new_array;
}

array_removeundefined( array )
{
    if ( !isdefined( array ) )
        return;

    new_array = [];

    foreach ( item in array )
    {
        if ( isdefined( item ) )
            new_array[new_array.size] = item;
    }

    return new_array;
}

code_trigger_activated( who )
{
    switch ( self.script_string )
    {
        case "cash":
            who maps\mp\zombies\_zm_score::add_to_player_score( 100 );
            break;
        default:
    }
}

touching_trigger( trigger )
{
    self endon( "code_trigger_end" );

    while ( self istouching( trigger ) )
        wait 0.1;

    self notify( "stopped_touching_trigger" );
}

watch_for_code( code )
{
    self endon( "code_trigger_end" );
    codes = strtok( code, " " );

    while ( true )
    {
        for ( i = 0; i < codes.size; i++ )
        {
            button = codes[i];

            if ( !self button_pressed( button, 0.3 ) )
                break;

            if ( !self button_not_pressed( button, 0.3 ) )
                break;

            if ( i == codes.size - 1 )
            {
                self notify( "code_correct" );
                return;
            }
        }

        wait 0.1;
    }
}

button_not_pressed( button, time )
{
    endtime = gettime() + time * 1000;

    while ( gettime() < endtime )
    {
        if ( !self buttonpressed( button ) )
            return true;

        wait 0.01;
    }

    return false;
}

button_pressed( button, time )
{
    endtime = gettime() + time * 1000;

    while ( gettime() < endtime )
    {
        if ( self buttonpressed( button ) )
            return true;

        wait 0.01;
    }

    return false;
}

init_slow_trigger()
{
    flag_wait( "all_players_connected" );
    players = get_players();

    for ( p = 0; p < players.size; p++ )
        players[p].movespeedscale = 1.0;

    slowtriggers = getentarray( "slow_trigger", "targetname" );

    for ( t = 0; t < slowtriggers.size; t++ )
    {
        trig = slowtriggers[t];

        if ( !isdefined( trig.script_float ) )
            trig.script_float = 0.5;

        trig.inturp_time = 1.0;
        trig.inturp_rate = trig.script_float / trig.inturp_time;
        trig thread trigger_slow_touched_wait();
    }
}

trigger_slow_touched_wait()
{
    while ( true )
    {
        self waittill( "trigger", player );
        player notify( "enter_slowTrigger" );
        self trigger_thread( player, ::trigger_slow_ent, ::trigger_unslow_ent );
        wait 0.1;
    }
}

trigger_slow_ent( player, endon_condition )
{
    player endon( endon_condition );

    if ( isdefined( player ) )
    {
        prevtime = gettime();

        while ( player.movespeedscale > self.script_float )
        {
            wait 0.05;
            delta = gettime() - prevtime;
            player.movespeedscale = player.movespeedscale - delta / 1000 * self.inturp_rate;
            prevtime = gettime();
            player setmovespeedscale( player.movespeedscale );
        }

        player.movespeedscale = self.script_float;
        player allowjump( 0 );
        player allowsprint( 0 );
        player setmovespeedscale( self.script_float );
        player setvelocity( ( 0, 0, 0 ) );
    }
}

trigger_unslow_ent( player )
{
    player endon( "enter_slowTrigger" );

    if ( isdefined( player ) )
    {
        prevtime = gettime();

        while ( player.movespeedscale < 1.0 )
        {
            wait 0.05;
            delta = gettime() - prevtime;
            player.movespeedscale = player.movespeedscale + delta / 1000 * self.inturp_rate;
            prevtime = gettime();
            player setmovespeedscale( player.movespeedscale );
        }

        player.movespeedscale = 1.0;
        player allowjump( 1 );
        player allowsprint( 1 );
        player setmovespeedscale( 1.0 );
    }
}

init_corpse_triggers()
{

}

trigger_corpse()
{
    if ( !isdefined( self.script_string ) )
        self.script_string = "";

    while ( true )
    {
/#
        box( self.origin, self.mins, self.maxs, 0, ( 1, 0, 0 ) );
#/
        corpses = getcorpsearray();

        for ( i = 0; i < corpses.size; i++ )
        {
            corpse = corpses[i];
/#
            box( corpse.orign, corpse.mins, corpse.maxs, 0, ( 1, 1, 0 ) );
#/

            if ( corpse istouching( self ) )
            {
                self trigger_corpse_activated();
                return;
            }
        }

        wait 0.3;
    }
}

trigger_corpse_activated()
{
    iprintlnbold( "Corpse Trigger Activated" );
}

init_water_drop_triggers()
{
    triggers = getentarray( "water_drop_trigger", "script_noteworthy" );

    for ( i = 0; i < triggers.size; i++ )
    {
        trig = triggers[i];
        trig.water_drop_time = 5;
        trig.waterdrops = 1;
        trig.watersheeting = 1;
        trig.watersheetingtime = 5;

        if ( isdefined( trig.script_string ) )
        {
            if ( trig.script_string == "sheetingonly" )
                trig.waterdrops = 0;
            else if ( trig.script_string == "dropsonly" )
                trig.watersheeting = 0;
        }

        trig thread water_drop_trigger_think();
    }
}

water_drop_trigger_think()
{
    flag_wait( "all_players_connected" );
    wait 1.0;

    if ( isdefined( self.script_flag ) )
        flag_wait( self.script_flag );

    if ( isdefined( self.script_float ) )
        wait( self.script_float );

    while ( true )
    {
        self waittill( "trigger", who );

        if ( isplayer( who ) )
            self trigger_thread( who, ::water_drop_trig_entered, ::water_drop_trig_exit );
        else if ( isdefined( who.water_trigger_func ) )
            who thread [[ who.water_trigger_func ]]( self );
    }
}

water_drop_trig_entered( player, endon_string )
{
    player endon( endon_string );
    player notify( "water_drop_trig_enter" );
    player endon( "death" );
    player endon( "disconnect" );
    player endon( "spawned_spectator" );

    if ( player.sessionstate == "spectator" )
        return;

    if ( !isdefined( player.water_drop_ents ) )
        player.water_drop_ents = [];

    if ( isdefined( self.script_sound ) )
        player playsound( self.script_sound );

    if ( self.waterdrops )
    {
        player.water_drop_ents[player.water_drop_ents.size] = self;

        if ( !self.watersheeting )
            player setwaterdrops( player player_get_num_water_drops() );
    }

    if ( self.watersheeting )
    {
        player setclientflag( level._cf_player_maze_floor_rumble );
        player thread intermission_rumble_clean_up();

        while ( true )
            wait( self.watersheetingtime );
    }
}

water_drop_trig_exit( player )
{
    if ( !isdefined( player.water_drop_ents ) )
        player.water_drop_ents = [];

    if ( self.waterdrops )
    {
        if ( self.watersheeting )
        {
            player notify( "irt" );
            player clearclientflag( level._cf_player_maze_floor_rumble );
            player setwaterdrops( player player_get_num_water_drops() );
        }

        player.water_drop_ents = array_remove( player.water_drop_ents, self );

        if ( player.water_drop_ents.size == 0 )
            player water_drop_remove( self.water_drop_time );
        else
            player setwaterdrops( player player_get_num_water_drops() );
    }
}

water_drop_remove( delay )
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "water_drop_trig_enter" );
    wait( delay );
    self setwaterdrops( 0 );
}

player_get_num_water_drops()
{
    if ( self.water_drop_ents.size > 0 )
        return 50;
    else
        return 0;
}

init_code_structs()
{
    structs = getstructarray( "code_struct", "targetname" );
    array_thread( structs, ::structs_code );
}

structs_code()
{
    code = self.script_noteworthy;

    if ( !isdefined( code ) )
        code = "DPAD_UP DPAD_DOWN DPAD_LEFT DPAD_RIGHT BUTTON_B BUTTON_A";

    self.codes = strtok( code, " " );

    if ( !isdefined( self.script_string ) )
        self.script_string = "cash";

    self.reward = self.script_string;

    if ( !isdefined( self.radius ) )
        self.radius = 32;

    self.radiussq = self.radius * self.radius;
    playersinradius = [];

    while ( true )
    {
        players = get_players();

        for ( i = playersinradius.size - 1; i >= 0; i-- )
        {
            player = playersinradius[i];

            if ( !self is_player_in_radius( player ) )
            {
                if ( isdefined( player ) )
                {
                    playersinradius = array_remove( playersinradius, player );
                    self notify( "end_code_struct" );
                }
                else
                    playersinradius = array_removeundefined( playersinradius );
            }

            players = array_remove( players, player );
        }

        for ( i = 0; i < players.size; i++ )
        {
            player = players[i];

            if ( self is_player_in_radius( player ) )
            {
                self thread code_entry( player );
                playersinradius[playersinradius.size] = player;
            }
        }

        wait 0.5;
    }
}

code_entry( player )
{
    self endon( "end_code_struct" );
    player endon( "death" );
    player endon( "disconnect" );

    while ( true )
    {
        for ( i = 0; i < self.codes.size; i++ )
        {
            button = self.codes[i];

            if ( !player button_pressed( button, 0.3 ) )
                break;

            if ( !player button_not_pressed( button, 0.3 ) )
                break;

            if ( i == self.codes.size - 1 )
            {
                self code_reward( player );
                return;
            }
        }

        wait 0.1;
    }
}

code_reward( player )
{
    switch ( self.reward )
    {
        case "cash":
            player maps\mp\zombies\_zm_score::add_to_player_score( 100 );
            break;
        default:
    }
}

is_player_in_radius( player )
{
    if ( !is_player_valid( player ) )
        return false;

    if ( abs( self.origin[2] - player.origin[2] ) > 30 )
        return false;

    if ( distance2dsquared( self.origin, player.origin ) > self.radiussq )
        return false;

    return true;
}

intermission_rumble_clean_up()
{
    self endon( "irt" );
    level waittill( "intermission" );
    self clearclientflag( level._cf_player_maze_floor_rumble );
}
