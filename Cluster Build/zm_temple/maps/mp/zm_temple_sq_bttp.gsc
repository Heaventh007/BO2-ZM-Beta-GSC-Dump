// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include common_scripts\utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_temple_sq_brock;
#include maps\mp\zm_temple_sq_skits;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zm_temple_sq;

init()
{
    declare_sidequest_stage( "sq", "bttp", ::init_stage, ::stage_logic, ::exit_stage );
    set_stage_time_limit( "sq", "bttp", 300 );
    declare_stage_asset_from_struct( "sq", "bttp", "sq_bttp_glyph", undefined, ::bttp_damage_thread );
    precachemodel( "p_ztem_glyphs_01_unfinished" );
    precachemodel( "p_ztem_glyphs_02_unfinished" );
    precachemodel( "p_ztem_glyphs_03_unfinished" );
    precachemodel( "p_ztem_glyphs_04_unfinished" );
    precachemodel( "p_ztem_glyphs_05_unfinished" );
    precachemodel( "p_ztem_glyphs_06_unfinished" );
    precachemodel( "p_ztem_glyphs_07_unfinished" );
    precachemodel( "p_ztem_glyphs_08_unfinished" );
    precachemodel( "p_ztem_glyphs_09_unfinished" );
    precachemodel( "p_ztem_glyphs_10_unfinished" );
    precachemodel( "p_ztem_glyphs_11_unfinished" );
    precachemodel( "p_ztem_glyphs_12_unfinished" );
}

init_stage()
{
    if ( isdefined( level._sq_skel ) )
        level._sq_skel hide();

    level._num_done = 0;
    maps\mp\zm_temple_sq_brock::delete_radio();
    trap = getent( "sq_spiketrap", "targetname" );
    trap thread trap_thread();
    level thread delayed_start_skit();
}

delayed_start_skit()
{
    wait 0.5;
    level thread maps\mp\zm_temple_sq_skits::start_skit( "tt6" );
}

trap_trigger()
{
    level endon( "sq_bttp_over" );

    while ( true )
    {
        self waittill( "damage", amount, attacker, direction, point, dmg_type, modelname, tagname );

        if ( isplayer( attacker ) && ( dmg_type == "MOD_EXPLOSIVE" || dmg_type == "MOD_EXPLOSIVE_SPLASH" || dmg_type == "MOD_GRENADE" || dmg_type == "MOD_GRENADE_SPLASH" ) )
        {
            self.owner_ent notify( "triggered", attacker );
            return;
        }
    }
}

trap_thread()
{
    level endon( "sq_bttp_over" );
    self.trigger = spawn( "trigger_damage", self.origin, 0, 32, 72 );
    self.trigger.height = 72;
    self.trigger.radius = 32;
    self.trigger.owner_ent = self;
    self.trigger thread trap_trigger();
    self waittill( "triggered", who );
    who thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest1", undefined, 7 );
    self.trigger playsound( "evt_sq_bttp_wood_explo" );
    self hide();
    flag_set( "trap_destroyed" );
}

bttp_debug()
{
/#
    self endon( "death" );
    self endon( "done" );
    level endon( "sq_bttp_over" );

    while ( true )
    {
        print3d( self.origin, "+", vectorscale( ( 0, 1, 0 ), 255.0 ), 1 );
        wait 0.1;
    }
#/
}

bttp_damage_thread()
{
    self endon( "death" );
    hits = 0;
    self.owner_ent thread bttp_debug();

    while ( true )
    {
        self waittill( "damage", amount, attacker, dir, point, type );
        self playsound( "evt_sq_bttp_carve" );

        if ( type == "MOD_MELEE" )
        {
            hits++;

            if ( hits >= 1 )
                break;
        }
    }

    self.owner_ent setmodel( self.owner_ent.tile );
    self.owner_ent notify( "done" );
    level._num_done++;

    if ( isdefined( attacker ) && isplayer( attacker ) )
    {
        if ( level._num_done < level._bttp_num_goal )
        {
            if ( randomintrange( 0, 101 ) <= 75 )
                attacker thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest6", undefined, randomintrange( 0, 4 ) );
        }
        else
            attacker thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest6", undefined, 4 );
    }
}

get_unfinished_tile_model( tile )
{
    retval = "p_ztem_glyphs_01_unfinished";

    switch ( tile )
    {
        case "p_ztem_glyphs_01_unlit":
            retval = "p_ztem_glyphs_01_unfinished";
            break;
        case "p_ztem_glyphs_02_unlit":
            retval = "p_ztem_glyphs_02_unfinished";
            break;
        case "p_ztem_glyphs_03_unlit":
            retval = "p_ztem_glyphs_03_unfinished";
            break;
        case "p_ztem_glyphs_04_unlit":
            retval = "p_ztem_glyphs_04_unfinished";
            break;
        case "p_ztem_glyphs_05_unlit":
            retval = "p_ztem_glyphs_05_unfinished";
            break;
        case "p_ztem_glyphs_06_unlit":
            retval = "p_ztem_glyphs_06_unfinished";
            break;
        case "p_ztem_glyphs_07_unlit":
            retval = "p_ztem_glyphs_07_unfinished";
            break;
        case "p_ztem_glyphs_08_unlit":
            retval = "p_ztem_glyphs_08_unfinished";
            break;
        case "p_ztem_glyphs_09_unlit":
            retval = "p_ztem_glyphs_09_unfinished";
            break;
        case "p_ztem_glyphs_10_unlit":
            retval = "p_ztem_glyphs_10_unfinished";
            break;
        case "p_ztem_glyphs_11_unlit":
            retval = "p_ztem_glyphs_11_unfinished";
            break;
        case "p_ztem_glyphs_12_unlit":
            retval = "p_ztem_glyphs_12_unfinished";
            break;
    }

    return retval;
}

stage_logic()
{
    level endon( "sq_bttp_over" );
    tile_models = array( "p_ztem_glyphs_01_unlit", "p_ztem_glyphs_02_unlit", "p_ztem_glyphs_03_unlit", "p_ztem_glyphs_04_unlit", "p_ztem_glyphs_05_unlit", "p_ztem_glyphs_06_unlit", "p_ztem_glyphs_07_unlit", "p_ztem_glyphs_08_unlit", "p_ztem_glyphs_09_unlit", "p_ztem_glyphs_10_unlit", "p_ztem_glyphs_11_unlit", "p_ztem_glyphs_12_unlit" );
    tile_models = array_randomize( tile_models );
    ents = getentarray( "sq_bttp_glyph", "targetname" );
    level._bttp_num_goal = ents.size;

    for ( i = 0; i < ents.size; i++ )
    {
        ents[i].tile = tile_models[i];
        ents[i] setmodel( get_unfinished_tile_model( tile_models[i] ) );
    }

    while ( true )
    {
        if ( level._num_done == ents.size )
            break;

        wait 0.1;
    }

    flag_wait( "trap_destroyed" );
    level notify( "suspend_timer" );
    wait 5;
    stage_completed( "sq", "bttp" );
}

exit_stage( success )
{
    trap = getent( "sq_spiketrap", "targetname" );

    if ( success )
    {
        maps\mp\zm_temple_sq::remove_skel();
        maps\mp\zm_temple_sq_brock::create_radio( 7, maps\mp\zm_temple_sq_brock::radio7_override );
    }
    else
    {
        if ( isdefined( level._sq_skel ) )
            level._sq_skel show();

        maps\mp\zm_temple_sq_brock::create_radio( 6 );
        trap show();
        level thread maps\mp\zm_temple_sq_skits::fail_skit();
    }

    if ( isdefined( trap.trigger ) )
        trap.trigger delete();
}
