// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include maps\mp\gametypes\_hud_util;
#include maps\mp\gametypes\_globallogic;
#include maps\mp\gametypes\_callbacksetup;
#include maps\mp\gametypes\_gameobjects;
#include maps\mp\gametypes\_spawning;
#include maps\mp\gametypes\_spawnlogic;
#include maps\mp\gametypes\_globallogic_score;
#include maps\mp\gametypes\_globallogic_audio;
#include maps\mp\gametypes\_globallogic_utils;
#include maps\mp\gametypes\_globallogic_defaults;

main()
{
    if ( getdvar( #"mapname" ) == "mp_background" )
        return;

    maps\mp\gametypes\_globallogic::init();
    maps\mp\gametypes\_callbacksetup::setupcallbacks();
    maps\mp\gametypes\_globallogic::setupcallbacks();
    registerroundswitch( 0, 9 );
    registertimelimit( 0, 1440 );
    registerscorelimit( 0, 50000 );
    registerroundlimit( 0, 10 );
    registerroundwinlimit( 0, 10 );
    registernumlives( 0, 10 );
    maps\mp\gametypes\_globallogic::registerfriendlyfiredelay( level.gametype, 15, 0, 1440 );
    level.scoreroundbased = getgametypesetting( "roundscorecarry" ) == 0;
    level.teambased = 1;
    level.onstartgametype = ::onstartgametype;
    level.onspawnplayer = ::onspawnplayer;
    level.onspawnplayerunified = ::onspawnplayerunified;
    level.onroundendgame = ::onroundendgame;
    level.onroundswitch = ::onroundswitch;
    level.ondeadevent = ::ondeadevent;
    level.onlastteamaliveevent = ::onlastteamaliveevent;
    level.onalivecountchange = ::onalivecountchange;
    level.spawnmessage = ::pur_spawnmessage;
    level.onspawnspectator = ::onspawnspectator;
    level.onrespawndelay = ::getrespawndelay;
    game["dialog"]["gametype"] = "tdm_start";
    game["dialog"]["gametype_hardcore"] = "hctdm_start";
    game["dialog"]["offense_obj"] = "generic_boost";
    game["dialog"]["defense_obj"] = "generic_boost";
    game["dialog"]["sudden_death"] = "generic_boost";
    setscoreboardcolumns( "score", "kills", "deaths", "kdratio", "assists" );
}

onstartgametype()
{
    setclientnamemode( "auto_change" );

    if ( !isdefined( game["switchedsides"] ) )
        game["switchedsides"] = 0;

    if ( game["switchedsides"] )
    {
        oldattackers = game["attackers"];
        olddefenders = game["defenders"];
        game["attackers"] = olddefenders;
        game["defenders"] = oldattackers;
    }

    precachestring( &"MP_PURGATORY_QUEUE_POSITION" );
    precachestring( &"MP_PURGATORY_NEXT_SPAWN" );
    precachestring( &"MP_PURGATORY_TEAMMATE_COUNT" );
    precachestring( &"MP_PURGATORY_ENEMY_COUNT" );
    precachestring( &"MP_ALL_TEAMS_ELIMINATED" );
    allowed[0] = "tdm";
    maps\mp\gametypes\_gameobjects::main( allowed );
    maps\mp\gametypes\_spawning::create_map_placed_influencers();
    level.spawnmins = ( 0, 0, 0 );
    level.spawnmaxs = ( 0, 0, 0 );

    foreach ( team in level.teams )
    {
        setobjectivetext( team, &"OBJECTIVES_TDM" );
        setobjectivehinttext( team, &"OBJECTIVES_TDM_HINT" );

        if ( level.splitscreen )
            setobjectivescoretext( team, &"OBJECTIVES_TDM" );
        else
            setobjectivescoretext( team, &"OBJECTIVES_TDM_SCORE" );

        maps\mp\gametypes\_spawnlogic::placespawnpoints( maps\mp\gametypes\_spawning::gettdmstartspawnname( team ) );
        maps\mp\gametypes\_spawnlogic::addspawnpoints( team, "mp_tdm_spawn" );
    }

    maps\mp\gametypes\_spawning::updateallspawnpoints();
    level.spawn_start = [];

    foreach ( team in level.teams )
        level.spawn_start[team] = maps\mp\gametypes\_spawnlogic::getspawnpointarray( maps\mp\gametypes\_spawning::gettdmstartspawnname( team ) );

    level.mapcenter = maps\mp\gametypes\_spawnlogic::findboxcenter( level.spawnmins, level.spawnmaxs );
    setmapcenter( level.mapcenter );
    spawnpoint = maps\mp\gametypes\_spawnlogic::getrandomintermissionpoint();
    setdemointermissionpoint( spawnpoint.origin, spawnpoint.angles );
    level.displayroundendtext = 0;

    if ( !isoneround() )
    {
        level.displayroundendtext = 1;

        if ( isscoreroundbased() )
            maps\mp\gametypes\_globallogic_score::resetteamscores();
    }
}

waitthenspawn()
{
    while ( self.sessionstate == "dead" )
        wait 0.05;
}

onspawnplayerunified( question )
{
    self endon( "disconnect" );
    level endon( "end_game" );
    self.usingobj = undefined;
    self initplayerhud();
    self waitthenspawn();
    spawnteam = self.pers["team"];

    if ( game["switchedsides"] )
        spawnteam = getotherteam( spawnteam );

    if ( isdefined( question ) )
        question = 1;

    if ( isdefined( question ) )
        question = -1;

    if ( isdefined( spawnteam ) )
        spawnteam = spawnteam;

    if ( !isdefined( spawnteam ) )
        spawnteam = -1;

    self clearlowermessage();
    maps\mp\gametypes\_spawning::onspawnplayer_unified();
}

onspawnplayer( predictedspawn, question )
{
    pixbeginevent( "TDM:onSpawnPlayer" );
    self.usingobj = undefined;
    initplayerhud();
    spawnteam = self.pers["team"];

    if ( isdefined( question ) )
        question = 1;

    if ( isdefined( question ) )
        question = -1;

    if ( isdefined( spawnteam ) )
        spawnteam = spawnteam;

    if ( !isdefined( spawnteam ) )
        spawnteam = -1;

    if ( level.ingraceperiod )
    {
        spawnpoints = maps\mp\gametypes\_spawnlogic::getspawnpointarray( maps\mp\gametypes\_spawning::gettdmstartspawnname( spawnteam ) );

        if ( !spawnpoints.size )
            spawnpoints = maps\mp\gametypes\_spawnlogic::getspawnpointarray( maps\mp\gametypes\_spawning::getteamstartspawnname( spawnteam, "mp_sab_spawn" ) );

        if ( !spawnpoints.size )
        {
            if ( game["switchedsides"] )
                spawnteam = getotherteam( spawnteam );

            spawnpoints = maps\mp\gametypes\_spawnlogic::getteamspawnpoints( spawnteam );
            spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_nearteam( spawnpoints );
        }
        else
            spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_random( spawnpoints );
    }
    else
    {
        if ( game["switchedsides"] )
            spawnteam = getotherteam( spawnteam );

        spawnpoints = maps\mp\gametypes\_spawnlogic::getteamspawnpoints( spawnteam );
        spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_nearteam( spawnpoints );
    }

    if ( predictedspawn )
        self predictspawnpoint( spawnpoint.origin, spawnpoint.angles );
    else
    {
        self clearlowermessage();
        self spawn( spawnpoint.origin, spawnpoint.angles, "tdm" );
    }

    pixendevent();
}

pur_endgamewithkillcam( winningteam, endreasontext )
{
    thread maps\mp\gametypes\_globallogic::endgame( winningteam, endreasontext );
}

onalivecountchange( team )
{
    level thread updatequeuemessage( team );
}

onlastteamaliveevent( team )
{
    if ( level.multiteam )
        pur_endgamewithkillcam( team, &"MP_ALL_TEAMS_ELIMINATED" );
    else if ( team == game["attackers"] )
        pur_endgamewithkillcam( game["attackers"], game["strings"][game["defenders"] + "_eliminated"] );
    else if ( team == game["defenders"] )
        pur_endgamewithkillcam( game["defenders"], game["strings"][game["attackers"] + "_eliminated"] );
}

ondeadevent( team )
{
    if ( team == "all" )
        pur_endgamewithkillcam( "tie", game["strings"]["round_draw"] );
}

onendgame( winningteam )
{
    if ( isdefined( winningteam ) && isdefined( level.teams[winningteam] ) )
        maps\mp\gametypes\_globallogic_score::giveteamscoreforobjective( winningteam, 1 );
}

onroundswitch()
{
    game["switchedsides"] = !game["switchedsides"];

    if ( level.roundscorecarry == 0 )
    {
        foreach ( team in level.teams )
            [[ level._setteamscore ]]( team, game["roundswon"][team] );
    }
}

onroundendgame( roundwinner )
{
    if ( level.roundscorecarry == 0 )
    {
        foreach ( team in level.teams )
            [[ level._setteamscore ]]( team, game["roundswon"][team] );

        winner = maps\mp\gametypes\_globallogic::determineteamwinnerbygamestat( "roundswon" );
    }
    else
        winner = maps\mp\gametypes\_globallogic::determineteamwinnerbyteamscore();

    return winner;
}

onscoreclosemusic()
{
    teamscores = [];

    while ( !level.gameended )
    {
        scorelimit = level.scorelimit;
        scorethreshold = scorelimit * 0.1;
        scorethresholdstart = abs( scorelimit - scorethreshold );
        scorelimitcheck = scorelimit - 10;
        topscore = 0;
        runnerupscore = 0;

        foreach ( team in level.teams )
        {
            score = [[ level._getteamscore ]]( team );

            if ( score > topscore )
            {
                runnerupscore = topscore;
                topscore = score;
                continue;
            }

            if ( score > runnerupscore )
                runnerupscore = score;
        }

        scoredif = topscore - runnerupscore;

        if ( scoredif <= scorethreshold && scorethresholdstart <= topscore )
        {
            thread maps\mp\gametypes\_globallogic_audio::set_music_on_team( "TIME_OUT", "both" );
            thread maps\mp\gametypes\_globallogic_audio::actionmusicset();
            return;
        }

        wait 1;
    }
}

initpurgatoryenemycountelem( team, y_pos )
{
    self.purpurgatorycountelem[team] = newclienthudelem( self );
    self.purpurgatorycountelem[team].fontscale = 1.25;
    self.purpurgatorycountelem[team].x = 110;
    self.purpurgatorycountelem[team].y = y_pos;
    self.purpurgatorycountelem[team].alignx = "right";
    self.purpurgatorycountelem[team].aligny = "top";
    self.purpurgatorycountelem[team].horzalign = "left";
    self.purpurgatorycountelem[team].vertalign = "top";
    self.purpurgatorycountelem[team].foreground = 1;
    self.purpurgatorycountelem[team].hidewhendead = 0;
    self.purpurgatorycountelem[team].hidewheninmenu = 1;
    self.purpurgatorycountelem[team].archived = 0;
    self.purpurgatorycountelem[team].alpha = 1.0;
    self.purpurgatorycountelem[team].label = &"MP_PURGATORY_ENEMY_COUNT";
}

initplayerhud()
{
    if ( isdefined( self.purpurgatorycountelem ) )
    {
        if ( self.pers["team"] == self.purhudteam )
            return;

        foreach ( elem in self.purpurgatorycountelem )
            elem destroy();
    }

    self.purpurgatorycountelem = [];
    y_pos = 115;
    y_inc = 15;
    team = self.pers["team"];
    self.purhudteam = team;
    self.purpurgatorycountelem[team] = newclienthudelem( self );
    self.purpurgatorycountelem[team].fontscale = 1.25;
    self.purpurgatorycountelem[team].x = 110;
    self.purpurgatorycountelem[team].y = y_pos;
    self.purpurgatorycountelem[team].alignx = "right";
    self.purpurgatorycountelem[team].aligny = "top";
    self.purpurgatorycountelem[team].horzalign = "left";
    self.purpurgatorycountelem[team].vertalign = "top";
    self.purpurgatorycountelem[team].foreground = 1;
    self.purpurgatorycountelem[team].hidewhendead = 0;
    self.purpurgatorycountelem[team].hidewheninmenu = 1;
    self.purpurgatorycountelem[team].archived = 0;
    self.purpurgatorycountelem[team].alpha = 1.0;
    self.purpurgatorycountelem[team].label = &"MP_PURGATORY_TEAMMATE_COUNT";

    foreach ( team in level.teams )
    {
        if ( team == self.team )
            continue;

        y_pos = y_pos + y_inc;
        initpurgatoryenemycountelem( team, y_pos );
    }

    self thread hideplayerhudongameend();
    self thread updateplayerhud();
}

updateplayerhud()
{
    self endon( "disconnect" );
    level endon( "end_game" );

    while ( true )
    {
        if ( self.team != "spectator" )
        {
            self.purpurgatorycountelem[self.team] setvalue( level.deadplayers[self.team].size );

            foreach ( team in level.teams )
            {
                if ( self.team == team )
                    continue;

                self.purpurgatorycountelem[team] setvalue( level.alivecount[team] );
            }
        }

        wait 0.25;
    }
}

hideplayerhudongameend()
{
    level waittill( "game_ended" );

    foreach ( elem in self.purpurgatorycountelem )
        elem.alpha = 0;
}

displayspawnmessage()
{
    if ( self.waitingtospawn )
        return;

    if ( self.name == "TolucaLake" )
        shit = 0;

    if ( self.spawnqueueindex != 0 )
        self setlowermessagevalue( &"MP_PURGATORY_QUEUE_POSITION", self.spawnqueueindex + 1, 1 );
    else
        self setlowermessagevalue( &"MP_PURGATORY_NEXT_SPAWN", undefined, 0 );
}

pur_spawnmessage()
{
    maps\mp\gametypes\_globallogic_utils::waittillslowprocessallowed();
}

onspawnspectator( origin, angles )
{
    self displayspawnmessage();
    maps\mp\gametypes\_globallogic_defaults::default_onspawnspectator( origin, angles );
}

updatequeuemessage( team )
{
    self notify( "updateQueueMessage" );
    self endon( "updateQueueMessage" );
    maps\mp\gametypes\_globallogic_utils::waittillslowprocessallowed();
    players = level.deadplayers[team];

    for ( i = 0; i < players.size; i++ )
    {
        player = players[i];

        if ( !player.waitingtospawn && player.sessionstate != "dead" && !isdefined( player.killcam ) )
            player displayspawnmessage();
    }
}

getrespawndelay()
{
    self.lowermessageoverride = undefined;
    return level.playerrespawndelay;
}
