// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\gametypes\_hud_util;
#include maps\mp\gametypes\_globallogic;
#include maps\mp\gametypes\_callbacksetup;
#include maps\mp\gametypes\_gameobjects;
#include maps\mp\gametypes\_spawning;
#include maps\mp\gametypes\_spawnlogic;
#include maps\mp\gametypes\_globallogic_audio;
#include maps\mp\killstreaks\_supplydrop;

main()
{
    maps\mp\gametypes\_globallogic::init();
    maps\mp\gametypes\_callbacksetup::setupcallbacks();
    maps\mp\gametypes\_globallogic::setupcallbacks();
    registertimelimit( 0, 1440 );
    registerscorelimit( 0, 50000 );
    registerroundlimit( 0, 10 );
    registerroundwinlimit( 0, 10 );
    registernumlives( 0, 100 );
    maps\mp\gametypes\_globallogic::registerfriendlyfiredelay( level.gametype, 0, 0, 1440 );
    level.scoreroundbased = 1;
    level.resetplayerscoreeveryround = 1;
    level.onstartgametype = ::onstartgametype;
    level.onspawnplayer = ::onspawnplayer;
    level.onspawnplayerunified = ::onspawnplayerunified;
    level.givecustomloadout = ::givecustomloadout;
    level.helitime = getgametypesetting( "objectiveSpawnTime" );
    game["dialog"]["gametype"] = "ffa_start";
    game["dialog"]["gametype_hardcore"] = "hcffa_start";
    game["dialog"]["offense_obj"] = "generic_boost";
    game["dialog"]["defense_obj"] = "generic_boost";
    setscoreboardcolumns( "score", "kills", "deaths", "kdratio", "headshots" );
}

onstartgametype()
{
    setclientnamemode( "auto_change" );
    setobjectivetext( "allies", &"OBJECTIVES_DM" );
    setobjectivetext( "axis", &"OBJECTIVES_DM" );

    if ( level.splitscreen )
    {
        setobjectivescoretext( "allies", &"OBJECTIVES_DM" );
        setobjectivescoretext( "axis", &"OBJECTIVES_DM" );
    }
    else
    {
        setobjectivescoretext( "allies", &"OBJECTIVES_DM_SCORE" );
        setobjectivescoretext( "axis", &"OBJECTIVES_DM_SCORE" );
    }

    setobjectivehinttext( "allies", &"OBJECTIVES_DM_HINT" );
    setobjectivehinttext( "axis", &"OBJECTIVES_DM_HINT" );
    allowed[0] = "dm";
    maps\mp\gametypes\_gameobjects::main( allowed );
    maps\mp\gametypes\_spawning::create_map_placed_influencers();
    level.spawnmins = ( 0, 0, 0 );
    level.spawnmaxs = ( 0, 0, 0 );
    maps\mp\gametypes\_spawnlogic::addspawnpoints( "allies", "mp_dm_spawn" );
    maps\mp\gametypes\_spawnlogic::addspawnpoints( "axis", "mp_dm_spawn" );
    maps\mp\gametypes\_spawning::updateallspawnpoints();
    level.mapcenter = maps\mp\gametypes\_spawnlogic::findboxcenter( level.spawnmins, level.spawnmaxs );
    setmapcenter( level.mapcenter );
    spawnpoint = maps\mp\gametypes\_spawnlogic::getrandomintermissionpoint();
    setdemointermissionpoint( spawnpoint.origin, spawnpoint.angles );
    level.usestartspawns = 0;
    level.displayroundendtext = 0;
    level thread onscoreclosemusic();

    if ( !isoneround() )
        level.displayroundendtext = 1;

    level.heliowner = spawn( "script_origin", ( 0, 0, 0 ) );
    initdroplocations();
    registercrates();
    thread cratedropper();
}

onspawnplayerunified()
{
    maps\mp\gametypes\_spawning::onspawnplayer_unified();
}

onspawnplayer( predictedspawn )
{
    spawnpoints = maps\mp\gametypes\_spawnlogic::getteamspawnpoints( self.pers["team"] );
    spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_dm( spawnpoints );

    if ( predictedspawn )
        self predictspawnpoint( spawnpoint.origin, spawnpoint.angles );
    else
        self spawn( spawnpoint.origin, spawnpoint.angles, "dm" );
}

onendgame( winningplayer )
{
    if ( isdefined( winningplayer ) && isplayer( winningplayer ) )
        [[ level._setplayerscore ]]( winningplayer, winningplayer [[ level._getplayerscore ]]() + 1 );
}

givecustomloadout()
{
    self takeallweapons();
    self clearperks();
    weapon = "judge_mp";
    self.primaryweapon = "judge_mp";
    self.lethalgrenade = "hatchet_mp";
    self.tacticalgrenade = undefined;
    self giveweapon( weapon );
    self giveweapon( "knife_mp" );
    self giveweapon( "knife_held_mp" );
    self giveweapon( self.lethalgrenade );
    self setweaponammostock( weapon, 0 );
    self setweaponammoclip( weapon, 5 );
    self switchtoweapon( weapon );
    self setspawnweapon( weapon );
    return weapon;
}

onscoreclosemusic()
{
    while ( !level.gameended )
    {
        scorelimit = level.scorelimit;
        scorethreshold = scorelimit * 0.9;

        for ( i = 0; i < level.players.size; i++ )
        {
            scorecheck = [[ level._getplayerscore ]]( level.players[i] );

            if ( scorecheck >= scorethreshold )
            {
                thread maps\mp\gametypes\_globallogic_audio::set_music_on_team( "TIME_OUT", "both" );
                thread maps\mp\gametypes\_globallogic_audio::actionmusicset();
                return;
            }
        }

        wait 0.5;
    }
}

inside_bounds( node_origin, bounds )
{
    mins = level.mapcenter - bounds;
    maxs = level.mapcenter + bounds;

    if ( node_origin[0] > maxs[0] )
        return false;

    if ( node_origin[0] < mins[0] )
        return false;

    if ( node_origin[1] > maxs[1] )
        return false;

    if ( node_origin[1] < mins[1] )
        return false;

    return true;
}

initdroplocations()
{
    scalar = 0.8;
    bound = ( level.spawnmaxs - level.mapcenter ) * scalar;
    possible_nodes = getallnodes();
    nodes = [];
    count = 0;

    foreach ( node in possible_nodes )
    {
        if ( inside_bounds( node.origin, bound ) )
        {
            nodes[nodes.size] = node;
            count++;
        }
    }

    level.dropnodes = nodes;
}

registercrates()
{
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "qcw05_mp", 1, &"WEAPON_QCW05", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "pdw57_mp", 1, &"WEAPON_PDW57", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "evoskorpion_mp", 1, &"WEAPON_EVOSKORPION", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "xm8_mp", 1, &"WEAPON_XM8", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "type95_mp", 1, &"WEAPON_TYPE95", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "lsat_mp", 1, &"WEAPON_LSAT", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "srm1216_mp", 1, &"WEAPON_SRM1216", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "kard_mp", 1, &"WEAPON_KARD", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "beretta93r_mp", 1, &"WEAPON_BERETTA93R", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "weapon", "fnp45_mp", 1, &"WEAPON_FNP45", undefined, undefined, ::givehuntedweapon, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "killstreak", "radar_mp", 4, &"KILLSTREAK_RADAR_CRATE", "MEDAL_SHARE_PACKAGE_RECON", ::givecratekillstreak, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "killstreak", "autoturret_mp", 3, &"KILLSTREAK_AUTO_TURRET_CRATE", "MEDAL_SHARE_PACKAGE_AUTO_TURRET", ::givecratekillstreak, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "killstreak", "remote_missile_mp", 4, &"KILLSTREAK_REMOTE_MISSILE_CRATE", "MEDAL_SHARE_PACKAGE_REMOTE_MISSILE", ::givecratekillstreak, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "killstreak", "planemortar_mp", 4, &"KILLSTREAK_PLANE_MORTAR_CRATE", "MEDAL_SHARE_PACKAGE_PLANE_MORTAR", ::givecratekillstreak, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "killstreak", "rcbomb_mp", 4, &"KILLSTREAK_RCBOMB_CRATE", "MEDAL_SHARE_PACKAGE_RCBOMB", ::givecratekillstreak, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "killstreak", "radardirection_mp", 2, &"KILLSTREAK_SATELLITE_CRATE", "MEDAL_SHARE_PACKAGE_SATELLITE", ::givecratekillstreak, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::registercratetype( "hunted", "killstreak", "inventory_ai_tank_drop_mp", 1, &"KILLSTREAK_AI_TANK_CRATE", "MEDAL_SHARE_PACKAGE_AI_TANK", ::givecratekillstreak, ::huntedcratelandoverride );
    maps\mp\killstreaks\_supplydrop::setcategorytypeweight( "hunted", "weapon", 4 );
    maps\mp\killstreaks\_supplydrop::setcategorytypeweight( "hunted", "killstreak", 1 );
    maps\mp\killstreaks\_supplydrop::advancedfinalizecratecategory( "hunted" );
}

givehuntedweapon( weapon )
{
    if ( isdefined( self.primaryweapon ) )
        self takeweapon( self.primaryweapon );

    self.primaryweapon = weapon;
    self giveweapon( weapon );
    self switchtoweapon( weapon );
    self setweaponammostock( weapon, 0 );
}

givehuntedlethalgrenade( weapon )
{
    if ( self.lethalgrenade == weapon )
    {
        currstock = self getammocount( weapon );
        self setweaponammostock( weapon, currstock + 1 );
        return;
    }

    if ( isdefined( self.lethalgrenade ) )
        self takeweapon( self.lethalgrenade );

    self.lethalgrenade = weapon;
    self giveweapon( weapon );
    self setoffhandprimaryclass( weapon );
}

givehuntedtacticalgrenade( weapon )
{
    if ( self.tacticalgrenade == weapon )
    {
        currstock = self getammocount( weapon );
        self setweaponammostock( weapon, currstock + 1 );
        return;
    }

    if ( isdefined( self.tacticalgrenade ) )
        self takeweapon( self.tacticalgrenade );

    self.tacticalgrenade = weapon;
    self giveweapon( weapon );
    self setoffhandsecondaryclass( weapon );
}

huntedcratelandoverride( crate, category, owner, team )
{
    crate.visibletoall = 1;
    crate maps\mp\killstreaks\_supplydrop::crateactivate();
    crate thread maps\mp\killstreaks\_supplydrop::crateusethink();
    crate thread maps\mp\killstreaks\_supplydrop::crateusethinkowner();
    maps\mp\killstreaks\_supplydrop::default_land_function( crate, category, owner, team );
}

getcratedroporigin()
{
    node = undefined;
    time = 10000;

    while ( !isdefined( node ) )
    {
        random_index = randomint( level.dropnodes.size );

        if ( !isdefined( level.dropnodes[random_index] ) )
            continue;

        node_origin = level.dropnodes[random_index].origin;

        if ( !bullettracepassed( node_origin + vectorscale( ( 0, 0, 1 ), 1000.0 ), node_origin, 0, undefined ) )
        {
            level.dropnodes[random_index] = undefined;
            continue;
        }

        node = level.dropnodes[random_index];
        break;
    }

    return node.origin;
}

cratedropper()
{
    wait_time = level.helitime;
    time = 10000;

    while ( true )
    {
        wait( wait_time );
        origin = getcratedroporigin();
        self thread maps\mp\killstreaks\_supplydrop::helidelivercrate( origin, "hunted", level.heliowner, "free", 0, 0 );
    }
}
