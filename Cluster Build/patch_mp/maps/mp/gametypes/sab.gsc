// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include maps\mp\gametypes\_hud_util;
#include maps\mp\gametypes\_globallogic;
#include maps\mp\gametypes\_callbacksetup;
#include maps\mp\gametypes\_globallogic_utils;
#include maps\mp\gametypes\_gameobjects;
#include maps\mp\gametypes\_spawning;
#include maps\mp\gametypes\_spawnlogic;
#include maps\mp\gametypes\_globallogic_audio;
#include maps\mp\gametypes\_hud_message;
#include maps\mp\gametypes\_globallogic_score;
#include maps\mp\gametypes\_battlechatter_mp;
#include maps\mp\_demo;
#include maps\mp\_popups;
#include maps\mp\_scoreevents;
#include maps\mp\gametypes\_hostmigration;
#include maps\mp\_medals;

main()
{
    if ( getdvar( #"mapname" ) == "mp_background" )
        return;

    maps\mp\gametypes\_globallogic::init();
    maps\mp\gametypes\_callbacksetup::setupcallbacks();
    maps\mp\gametypes\_globallogic::setupcallbacks();
    level.teambased = 1;
    level.overrideteamscore = 1;
    registerroundswitch( 0, 9 );
    registertimelimit( 0, 1440 );
    registerscorelimit( 0, 500 );
    registerroundlimit( 0, 10 );
    registernumlives( 0, 100 );
    registerroundwinlimit( 0, 10 );
    maps\mp\gametypes\_globallogic::registerfriendlyfiredelay( level.gametype, 15, 0, 1440 );
    level.onstartgametype = ::onstartgametype;
    level.onspawnplayer = ::onspawnplayer;
    level.onspawnplayerunified = ::onspawnplayerunified;
    level.gamemodespawndvars = ::sab_gamemodespawndvars;
    level.onroundendgame = ::onroundendgame;

    if ( !game["tiebreaker"] )
    {
        level.onprecachegametype = ::onprecachegametype;
        level.ontimelimit = ::ontimelimit;
        level.ondeadevent = ::ondeadevent;
        level.onroundswitch = ::onroundswitch;
        level.onplayerkilled = ::onplayerkilled;
        level.endgameonscorelimit = 0;
        game["dialog"]["gametype"] = "sab_start";
        game["dialog"]["gametype_hardcore"] = "hcsab_start";
        game["dialog"]["offense_obj"] = "destroy_start";
        game["dialog"]["defense_obj"] = "destroy_start";
        game["dialog"]["sudden_death"] = "suddendeath";
        game["dialog"]["sudden_death_boost"] = "generic_boost";
    }
    else
    {
        level.onendgame = ::onendgame;
        level.endgameonscorelimit = 0;
        game["dialog"]["gametype"] = "sab_start";
        game["dialog"]["gametype_hardcore"] = "hcsab_start";
        game["dialog"]["offense_obj"] = "generic_boost";
        game["dialog"]["defense_obj"] = "generic_boost";
        game["dialog"]["sudden_death"] = "suddendeath";
        game["dialog"]["sudden_death_boost"] = "generic_boost";
        maps\mp\gametypes\_globallogic_utils::registernumlives( 1, 1 );
        maps\mp\gametypes\_globallogic_utils::registertimelimit( 0, 0 );
    }

    badtrig = getent( "sab_bomb_defuse_allies", "targetname" );

    if ( isdefined( badtrig ) )
        badtrig delete();

    badtrig = getent( "sab_bomb_defuse_axis", "targetname" );

    if ( isdefined( badtrig ) )
        badtrig delete();

    level.lastdialogtime = 0;
    setscoreboardcolumns( "score", "kills", "deaths", "plants", "defuses" );
}

onprecachegametype()
{
    game["bomb_dropped_sound"] = "mp_war_objective_lost";
    game["bomb_recovered_sound"] = "mp_war_objective_taken";
    precacheshader( "waypoint_bomb" );
    precacheshader( "waypoint_kill" );
    precacheshader( "waypoint_bomb_enemy" );
    precacheshader( "waypoint_defend" );
    precacheshader( "waypoint_defuse" );
    precacheshader( "waypoint_target" );
    precacheshader( "compass_waypoint_bomb" );
    precacheshader( "compass_waypoint_defend" );
    precacheshader( "compass_waypoint_defuse" );
    precacheshader( "compass_waypoint_target" );
    precacheshader( "hud_suitcase_bomb" );
    precachestring( &"MP_EXPLOSIVES_RECOVERED_BY" );
    precachestring( &"MP_EXPLOSIVES_RECOVERED_BY" );
    precachestring( &"MP_EXPLOSIVES_DROPPED_BY" );
    precachestring( &"MP_EXPLOSIVES_PLANTED_BY" );
    precachestring( &"MP_EXPLOSIVES_DEFUSED_BY" );
    precachestring( &"MP_YOU_HAVE_RECOVERED_THE_BOMB" );
    precachestring( &"PLATFORM_HOLD_TO_PLANT_EXPLOSIVES" );
    precachestring( &"PLATFORM_HOLD_TO_DEFUSE_EXPLOSIVES" );
    precachestring( &"MP_PLANTING_EXPLOSIVE" );
    precachestring( &"MP_DEFUSING_EXPLOSIVE" );
    precachestring( &"MP_TARGET_DESTROYED" );
    precachestring( &"MP_NO_RESPAWN" );
    precachestring( &"MP_TIE_BREAKER" );
    precachestring( &"MP_NO_RESPAWN" );
    precachestring( &"MP_SUDDEN_DEATH" );
}

onroundswitch()
{
    if ( !isdefined( game["switchedsides"] ) )
        game["switchedsides"] = 0;

    if ( game["teamScores"]["allies"] == level.scorelimit - 1 && game["teamScores"]["axis"] == level.scorelimit - 1 )
    {
        level.halftimetype = "overtime";
        level.halftimesubcaption = &"MP_TIE_BREAKER";
        game["tiebreaker"] = 1;
    }
    else
    {
        level.halftimetype = "halftime";
        game["switchedsides"] = !game["switchedsides"];
    }
}

onstartgametype()
{
    if ( !isdefined( game["switchedsides"] ) )
        game["switchedsides"] = 0;

    setclientnamemode( "auto_change" );
    game["strings"]["target_destroyed"] = &"MP_TARGET_DESTROYED";

    if ( !game["tiebreaker"] )
    {
        setobjectivetext( "allies", &"OBJECTIVES_SAB" );
        setobjectivetext( "axis", &"OBJECTIVES_SAB" );

        if ( level.splitscreen )
        {
            setobjectivescoretext( "allies", &"OBJECTIVES_SAB" );
            setobjectivescoretext( "axis", &"OBJECTIVES_SAB" );
        }
        else
        {
            setobjectivescoretext( "allies", &"OBJECTIVES_SAB_SCORE" );
            setobjectivescoretext( "axis", &"OBJECTIVES_SAB_SCORE" );
        }

        setobjectivehinttext( "allies", &"OBJECTIVES_SAB_HINT" );
        setobjectivehinttext( "axis", &"OBJECTIVES_SAB_HINT" );
    }
    else
    {
        setobjectivetext( "allies", &"OBJECTIVES_TDM" );
        setobjectivetext( "axis", &"OBJECTIVES_TDM" );

        if ( level.splitscreen )
        {
            setobjectivescoretext( "allies", &"OBJECTIVES_TDM" );
            setobjectivescoretext( "axis", &"OBJECTIVES_TDM" );
        }
        else
        {
            setobjectivescoretext( "allies", &"OBJECTIVES_TDM_SCORE" );
            setobjectivescoretext( "axis", &"OBJECTIVES_TDM_SCORE" );
        }

        setobjectivehinttext( "allies", &"OBJECTIVES_TDM_HINT" );
        setobjectivehinttext( "axis", &"OBJECTIVES_TDM_HINT" );
    }

    allowed[0] = "sab";
    maps\mp\gametypes\_gameobjects::main( allowed );
    maps\mp\gametypes\_spawning::create_map_placed_influencers();
    level.spawnmins = ( 0, 0, 0 );
    level.spawnmaxs = ( 0, 0, 0 );
    maps\mp\gametypes\_spawnlogic::placespawnpoints( "mp_sab_spawn_allies_start" );
    maps\mp\gametypes\_spawnlogic::placespawnpoints( "mp_sab_spawn_axis_start" );
    maps\mp\gametypes\_spawnlogic::addspawnpoints( "allies", "mp_sab_spawn_allies" );
    maps\mp\gametypes\_spawnlogic::addspawnpoints( "axis", "mp_sab_spawn_axis" );
    maps\mp\gametypes\_spawning::updateallspawnpoints();
    level.mapcenter = maps\mp\gametypes\_spawnlogic::findboxcenter( level.spawnmins, level.spawnmaxs );
    setmapcenter( level.mapcenter );
    spawnpoint = maps\mp\gametypes\_spawnlogic::getrandomintermissionpoint();
    setdemointermissionpoint( spawnpoint.origin, spawnpoint.angles );
    level.spawn_axis = maps\mp\gametypes\_spawnlogic::getspawnpointarray( "mp_sab_spawn_axis" );
    level.spawn_allies = maps\mp\gametypes\_spawnlogic::getspawnpointarray( "mp_sab_spawn_allies" );
    level.spawn_start = [];

    foreach ( team in level.teams )
        level.spawn_start[team] = maps\mp\gametypes\_spawnlogic::getspawnpointarray( "mp_sab_spawn_" + team + "_start" );

    thread updategametypedvars();
    thread sabotage();
}

ontimelimit()
{
    if ( level.inovertime )
        return;

    thread onovertime();
}

onovertime()
{
    level endon( "game_ended" );
    level.timelimitoverride = 1;
    level.inovertime = 1;
    maps\mp\gametypes\_globallogic_audio::leaderdialog( "sudden_death" );
    maps\mp\gametypes\_globallogic_audio::leaderdialog( "sudden_death_boost" );

    for ( index = 0; index < level.players.size; index++ )
    {
        level.players[index] notify( "force_spawn" );
        level.players[index] thread maps\mp\gametypes\_hud_message::oldnotifymessage( &"MP_SUDDEN_DEATH", &"MP_NO_RESPAWN", undefined, ( 1, 0, 0 ), "mp_last_stand" );
        level.players[index] setclientuivisibilityflag( "g_compassShowEnemies", 1 );
    }

    setmatchtalkflag( "DeadChatWithDead", 1 );
    setmatchtalkflag( "DeadChatWithTeam", 0 );
    setmatchtalkflag( "DeadHearTeamLiving", 0 );
    setmatchtalkflag( "DeadHearAllLiving", 0 );
    setmatchtalkflag( "EveryoneHearsEveryone", 0 );
    waittime = 0;

    while ( waittime < 90 )
    {
        if ( !level.bombplanted )
        {
            waittime = waittime + 1;
            setgameendtime( gettime() + ( 90 - waittime ) * 1000 );
        }

        wait 1.0;
    }

    thread maps\mp\gametypes\_globallogic::endgame( "tie", game["strings"]["tie"] );
}

ondeadevent( team )
{
    if ( level.bombexploded )
        return;

    if ( team == "all" )
    {
        if ( level.bombplanted )
        {
            maps\mp\gametypes\_globallogic_score::giveteamscoreforobjective( level.bombplantedby, 1 );
            thread maps\mp\gametypes\_globallogic::endgame( level.bombplantedby, game["strings"][level.bombplantedby + "_mission_accomplished"] );
        }
        else
            thread maps\mp\gametypes\_globallogic::endgame( "tie", game["strings"]["tie"] );
    }
    else if ( level.bombplanted )
    {
        if ( team == level.bombplantedby )
        {
            level.plantingteamdead = 1;
            return;
        }

        otherteam = getotherteam( level.bombplantedby ) maps\mp\gametypes\_globallogic_score::giveteamscoreforobjective( level.bombplantedby, 1 );
        thread maps\mp\gametypes\_globallogic::endgame( level.bombplantedby, game["strings"][otherteam + "_eliminated"] );
    }
    else
    {
        otherteam = getotherteam( team ) maps\mp\gametypes\_globallogic_score::giveteamscoreforobjective( otherteam, 1 );
        thread maps\mp\gametypes\_globallogic::endgame( otherteam, game["strings"][team + "_eliminated"] );
    }
}

onspawnplayerunified()
{
    self.isplanting = 0;
    self.isdefusing = 0;
    self.isbombcarrier = 0;

    if ( game["tiebreaker"] )
    {
        self thread maps\mp\gametypes\_hud_message::oldnotifymessage( &"MP_TIE_BREAKER", &"MP_NO_RESPAWN", undefined, ( 1, 0, 0 ), "mp_last_stand" );
        self setclientuivisibilityflag( "g_compassShowEnemies", 1 );
        setmatchtalkflag( "DeadChatWithDead", 1 );
        setmatchtalkflag( "DeadChatWithTeam", 0 );
        setmatchtalkflag( "DeadHearTeamLiving", 0 );
        setmatchtalkflag( "DeadHearAllLiving", 0 );
        setmatchtalkflag( "EveryoneHearsEveryone", 0 );
    }

    maps\mp\gametypes\_spawning::onspawnplayer_unified();
}

onspawnplayer( predictedspawn )
{
    if ( !predictedspawn )
    {
        self.isplanting = 0;
        self.isdefusing = 0;
        self.isbombcarrier = 0;

        if ( game["tiebreaker"] )
        {
            self thread maps\mp\gametypes\_hud_message::oldnotifymessage( &"MP_TIE_BREAKER", &"MP_NO_RESPAWN", undefined, ( 1, 0, 0 ), "mp_last_stand" );
            hintmessage = getobjectivehinttext( self.pers["team"] );

            if ( isdefined( hintmessage ) )
                self displaygamemodemessage( hintmessage, "uin_alert_slideout" );

            self setclientuivisibilityflag( "g_compassShowEnemies", 1 );
            setmatchtalkflag( "DeadChatWithDead", 1 );
            setmatchtalkflag( "DeadChatWithTeam", 0 );
            setmatchtalkflag( "DeadHearTeamLiving", 0 );
            setmatchtalkflag( "DeadHearAllLiving", 0 );
            setmatchtalkflag( "EveryoneHearsEveryone", 0 );
        }
    }

    spawnteam = self.pers["team"];

    if ( game["switchedsides"] )
        spawnteam = getotherteam( spawnteam );

    if ( level.usestartspawns )
        spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_random( level.spawn_start[spawnteam] );
    else if ( spawnteam == "axis" )
        spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_nearteam( level.spawn_axis );
    else
        spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_nearteam( level.spawn_allies );

    assert( isdefined( spawnpoint ) );

    if ( predictedspawn )
        self predictspawnpoint( spawnpoint.origin, spawnpoint.angles );
    else
        self spawn( spawnpoint.origin, spawnpoint.angles, "sab" );
}

updategametypedvars()
{
    level.planttime = getgametypesetting( "plantTime" );
    level.defusetime = getgametypesetting( "defuseTime" );
    level.bombtimer = getgametypesetting( "bombTimer" );
    level.hotpotato = getgametypesetting( "hotPotato" );
}

sabotage()
{
    level.bombplanted = 0;
    level.bombexploded = 0;
    level._effect["bombexplosion"] = loadfx( "maps/mp_maps/fx_mp_exp_bomb" );
    trigger = getent( "sab_bomb_pickup_trig", "targetname" );

    if ( !isdefined( trigger ) )
    {
        error( "No sab_bomb_pickup_trig trigger found in map." );
        return;
    }

    visuals[0] = getent( "sab_bomb", "targetname" );

    if ( !isdefined( visuals[0] ) )
    {
        error( "No sab_bomb script_model found in map." );
        return;
    }

    level.sabbomb = maps\mp\gametypes\_gameobjects::createcarryobject( "neutral", trigger, visuals, vectorscale( ( 0, 0, 1 ), 32.0 ) );
    level.sabbomb maps\mp\gametypes\_gameobjects::allowcarry( "any" );
    level.sabbomb maps\mp\gametypes\_gameobjects::set2dicon( "enemy", "compass_waypoint_bomb" );
    level.sabbomb maps\mp\gametypes\_gameobjects::set3dicon( "enemy", "waypoint_bomb" );
    level.sabbomb maps\mp\gametypes\_gameobjects::set2dicon( "friendly", "compass_waypoint_bomb" );
    level.sabbomb maps\mp\gametypes\_gameobjects::set3dicon( "friendly", "waypoint_bomb" );
    level.sabbomb maps\mp\gametypes\_gameobjects::setcarryicon( "hud_suitcase_bomb" );
    level.sabbomb maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    level.sabbomb.objidpingenemy = 1;
    level.sabbomb.onpickup = ::onpickup;
    level.sabbomb.ondrop = ::ondrop;
    level.sabbomb.allowweapons = 1;
    level.sabbomb.objpoints["allies"].archived = 1;
    level.sabbomb.objpoints["axis"].archived = 1;
    level.sabbomb.autoresettime = 60.0;

    if ( !isdefined( getent( "sab_bomb_axis", "targetname" ) ) )
    {
/#
        error( "No sab_bomb_axis trigger found in map." );
#/
        return;
    }

    if ( !isdefined( getent( "sab_bomb_allies", "targetname" ) ) )
    {
/#
        error( "No sab_bomb_allies trigger found in map." );
#/
        return;
    }

    if ( game["switchedsides"] )
    {
        level.bombzones["allies"] = createbombzone( "allies", getent( "sab_bomb_axis", "targetname" ) );
        level.bombzones["axis"] = createbombzone( "axis", getent( "sab_bomb_allies", "targetname" ) );
    }
    else
    {
        level.bombzones["allies"] = createbombzone( "allies", getent( "sab_bomb_allies", "targetname" ) );
        level.bombzones["axis"] = createbombzone( "axis", getent( "sab_bomb_axis", "targetname" ) );
    }
}

createbombzone( team, trigger )
{
    visuals = getentarray( trigger.target, "targetname" );
    bombzone = maps\mp\gametypes\_gameobjects::createuseobject( team, trigger, visuals, vectorscale( ( 0, 0, 1 ), 64.0 ) );
    bombzone resetbombsite();
    bombzone.onuse = ::onuse;
    bombzone.onbeginuse = ::onbeginuse;
    bombzone.onenduse = ::onenduse;
    bombzone.oncantuse = ::oncantuse;
    bombzone.useweapon = "briefcase_bomb_mp";
    bombzone.visuals[0].killcament = spawn( "script_model", bombzone.visuals[0].origin + vectorscale( ( 0, 0, 1 ), 128.0 ) );

    for ( i = 0; i < visuals.size; i++ )
    {
        if ( isdefined( visuals[i].script_exploder ) )
        {
            bombzone.exploderindex = visuals[i].script_exploder;
            break;
        }
    }

    return bombzone;
}

onbeginuse( player )
{
    if ( !self maps\mp\gametypes\_gameobjects::isfriendlyteam( player.pers["team"] ) )
    {
        player.isplanting = 1;
        player thread maps\mp\gametypes\_battlechatter_mp::gametypespecificbattlechatter( "sd_friendlyplant", player.pers["team"] );
    }
    else
    {
        player.isdefusing = 1;
        player thread maps\mp\gametypes\_battlechatter_mp::gametypespecificbattlechatter( "sd_enemyplant", player.pers["team"] );
    }

    player playsound( "fly_bomb_raise_plr" );
}

onenduse( team, player, result )
{
    if ( !isalive( player ) )
        return;

    player.isplanting = 0;
    player.isdefusing = 0;
    player notify( "event_ended" );
}

onpickup( player )
{
    level notify( "bomb_picked_up" );
    player recordgameevent( "pickup" );
    self.autoresettime = 60.0;
    level.usestartspawns = 0;
    team = player.pers["team"];

    if ( team == "allies" )
        otherteam = "axis";
    else
        otherteam = "allies";

    player playlocalsound( "mp_suitcase_pickup" );
    player logstring( "bomb taken" );
    excludelist[0] = player;

    if ( gettime() - level.lastdialogtime > 10000 )
    {
        maps\mp\gametypes\_globallogic_audio::leaderdialog( "bomb_acquired", team );
        player maps\mp\gametypes\_globallogic_audio::leaderdialogonplayer( "obj_destroy", "bomb" );

        if ( !level.splitscreen )
        {
            maps\mp\gametypes\_globallogic_audio::leaderdialog( "bomb_taken", otherteam );
            maps\mp\gametypes\_globallogic_audio::leaderdialog( "obj_defend", otherteam );
        }

        level.lastdialogtime = gettime();
    }

    player.isbombcarrier = 1;
    player addplayerstatwithgametype( "PICKUPS", 1 );

    if ( team == self maps\mp\gametypes\_gameobjects::getownerteam() )
    {
        printonteamarg( &"MP_EXPLOSIVES_RECOVERED_BY", team, player );
        playsoundonplayers( game["bomb_recovered_sound"], team );
    }
    else
    {
        printonteamarg( &"MP_EXPLOSIVES_RECOVERED_BY", team, player );
        playsoundonplayers( game["bomb_recovered_sound"] );
    }

    self maps\mp\gametypes\_gameobjects::setownerteam( team );
    self maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "enemy", "compass_waypoint_target" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "enemy", "waypoint_kill" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "friendly", "compass_waypoint_defend" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "friendly", "waypoint_defend" );
    level.bombzones[team] maps\mp\gametypes\_gameobjects::setvisibleteam( "none" );
    level.bombzones[otherteam] maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    level.bombzones[otherteam].trigger setinvisibletoall();
    level.bombzones[otherteam].trigger setvisibletoplayer( player );
}

ondrop( player )
{
    if ( level.bombplanted )
    {

    }
    else
    {
        if ( isdefined( player ) )
            printonteamarg( &"MP_EXPLOSIVES_DROPPED_BY", self maps\mp\gametypes\_gameobjects::getownerteam(), player );

        playsoundonplayers( game["bomb_dropped_sound"], self maps\mp\gametypes\_gameobjects::getownerteam() );

        if ( isdefined( player ) )
            player logstring( "bomb dropped" );
        else
            logstring( "bomb dropped" );

        maps\mp\gametypes\_globallogic_audio::leaderdialog( "bomb_lost", self maps\mp\gametypes\_gameobjects::getownerteam() );
        player notify( "event_ended" );
        level.bombzones["axis"].trigger setinvisibletoall();
        level.bombzones["allies"].trigger setinvisibletoall();
        thread abandonmentthink( 0.0 );
    }
}

abandonmentthink( delay )
{
    level endon( "bomb_picked_up" );
    wait( delay );

    if ( isdefined( self.carrier ) )
        return;

    if ( self maps\mp\gametypes\_gameobjects::getownerteam() == "allies" )
        otherteam = "axis";
    else
        otherteam = "allies";

    playsoundonplayers( game["bomb_dropped_sound"], otherteam );
    self maps\mp\gametypes\_gameobjects::setownerteam( "neutral" );
    self maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "enemy", "compass_waypoint_bomb" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "enemy", "waypoint_bomb" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "friendly", "compass_waypoint_bomb" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "friendly", "waypoint_bomb" );
    level.bombzones["allies"] maps\mp\gametypes\_gameobjects::setvisibleteam( "none" );
    level.bombzones["axis"] maps\mp\gametypes\_gameobjects::setvisibleteam( "none" );
}

onuse( player )
{
    team = player.pers["team"];
    otherteam = getotherteam( team );

    if ( !self maps\mp\gametypes\_gameobjects::isfriendlyteam( player.pers["team"] ) )
    {
        player notify( "bomb_planted" );
        player logstring( "bomb planted" );

        if ( isdefined( player.pers["plants"] ) )
        {
            player.pers["plants"]++;
            player.plants = player.pers["plants"];
        }

        maps\mp\_demo::bookmark( "event", gettime(), player );
        player addplayerstatwithgametype( "PLANTS", 1 );
        level thread maps\mp\_popups::displayteammessagetoall( &"MP_EXPLOSIVES_PLANTED_BY", player );
        maps\mp\gametypes\_globallogic_audio::set_music_on_team( "ACTION", "both", 1 );
        maps\mp\gametypes\_globallogic_audio::leaderdialog( "bomb_planted", team );
        maps\mp\gametypes\_globallogic_audio::leaderdialog( "bomb_planted", otherteam );
        maps\mp\_scoreevents::processscoreevent( "planted_bomb", player );
        player recordgameevent( "plant" );
        level thread bombplanted( self, player.pers["team"] );
        level.bombowner = player;
        player.isbombcarrier = 0;
        level.sabbomb.autoresettime = undefined;
        level.sabbomb maps\mp\gametypes\_gameobjects::allowcarry( "none" );
        level.sabbomb maps\mp\gametypes\_gameobjects::setvisibleteam( "none" );
        level.sabbomb maps\mp\gametypes\_gameobjects::setdropped();
        self.useweapon = "briefcase_bomb_defuse_mp";
        self setupfordefusing();
    }
    else
    {
        player notify( "bomb_defused" );
        player logstring( "bomb defused" );

        if ( isdefined( player.pers["defuses"] ) )
        {
            player.pers["defuses"]++;
            player.defuses = player.pers["defuses"];
        }

        maps\mp\_demo::bookmark( "event", gettime(), player );
        player addplayerstatwithgametype( "DEFUSES", 1 );
        level thread maps\mp\_popups::displayteammessagetoall( &"MP_EXPLOSIVES_DEFUSED_BY", player );
        maps\mp\gametypes\_globallogic_audio::set_music_on_team( "UNDERSCORE", "both", 1 );
        maps\mp\gametypes\_globallogic_audio::leaderdialog( "bomb_defused" );
        maps\mp\_scoreevents::processscoreevent( "defused_bomb", player );
        player recordgameevent( "defuse" );
        level thread bombdefused( self );

        if ( level.inovertime && isdefined( level.plantingteamdead ) )
        {
            thread maps\mp\gametypes\_globallogic::endgame( player.pers["team"], game["strings"][level.bombplantedby + "_eliminated"] );
            return;
        }

        self resetbombsite();
        level.sabbomb maps\mp\gametypes\_gameobjects::allowcarry( "any" );
        level.sabbomb maps\mp\gametypes\_gameobjects::setpickedup( player );
    }
}

oncantuse( player )
{
    player iprintlnbold( &"MP_CANT_PLANT_WITHOUT_BOMB" );
}

bombplanted( destroyedobj, team )
{
    game["challenge"][team]["plantedBomb"] = 1;
    maps\mp\gametypes\_globallogic_utils::pausetimer();
    level.bombplanted = 1;
    level.bombplantedby = team;
    level.timelimitoverride = 1;
    setmatchflag( "bomb_timer", 1 );
    setgameendtime( int( gettime() + level.bombtimer * 1000 ) );
    destroyedobj.visuals[0] thread maps\mp\gametypes\_globallogic_utils::playtickingsound( "mpl_sab_ui_suitcasebomb_timer" );
    starttime = gettime();
    bombtimerwait();
    setmatchflag( "bomb_timer", 0 );
    destroyedobj.visuals[0] maps\mp\gametypes\_globallogic_utils::stoptickingsound();

    if ( !level.bombplanted )
    {
        if ( level.hotpotato )
        {
            timepassed = ( gettime() - starttime ) / 1000;
            level.bombtimer = level.bombtimer - timepassed;
        }

        return;
    }

    explosionorigin = level.sabbomb.visuals[0].origin + vectorscale( ( 0, 0, 1 ), 12.0 );
    level.bombexploded = 1;

    if ( isdefined( level.bombowner ) )
    {
        destroyedobj.visuals[0] radiusdamage( explosionorigin, 512, 200, 20, level.bombowner, "MOD_EXPLOSIVE", "briefcase_bomb_mp" );
        level thread maps\mp\_popups::displayteammessagetoall( &"MP_EXPLOSIVES_BLOWUP_BY", level.bombowner );
        level.bombowner addplayerstatwithgametype( "DESTRUCTIONS", 1 );
        maps\mp\_scoreevents::processscoreevent( "bomb_detonated", level.bombowner );
    }
    else
        destroyedobj.visuals[0] radiusdamage( explosionorigin, 512, 200, 20, undefined, "MOD_EXPLOSIVE", "briefcase_bomb_mp" );

    rot = randomfloat( 360 );
    explosioneffect = spawnfx( level._effect["bombexplosion"], explosionorigin + vectorscale( ( 0, 0, 1 ), 50.0 ), ( 0, 0, 1 ), ( cos( rot ), sin( rot ), 0 ) );
    triggerfx( explosioneffect );
    thread playsoundinspace( "mpl_sab_exp_suitcase_bomb_main", explosionorigin );

    if ( isdefined( destroyedobj.exploderindex ) )
        exploder( destroyedobj.exploderindex );

    [[ level._setteamscore ]]( team, [[ level._getteamscore ]]( team ) + 1 );
    setgameendtime( 0 );
    level.bombzones["allies"] maps\mp\gametypes\_gameobjects::setvisibleteam( "none" );
    level.bombzones["axis"] maps\mp\gametypes\_gameobjects::setvisibleteam( "none" );
    wait 3;
    thread maps\mp\gametypes\_globallogic::endgame( team, game["strings"]["target_destroyed"] );
}

bombtimerwait()
{
    level endon( "bomb_defused" );
    maps\mp\gametypes\_hostmigration::waitlongdurationwithgameendtimeupdate( level.bombtimer );
}

resetbombsite()
{
    self maps\mp\gametypes\_gameobjects::allowuse( "enemy" );
    self maps\mp\gametypes\_gameobjects::setusetime( level.planttime );
    self maps\mp\gametypes\_gameobjects::setusetext( &"MP_PLANTING_EXPLOSIVE" );
    self maps\mp\gametypes\_gameobjects::setusehinttext( &"PLATFORM_HOLD_TO_PLANT_EXPLOSIVES" );
    self maps\mp\gametypes\_gameobjects::setkeyobject( level.sabbomb );
    self maps\mp\gametypes\_gameobjects::set2dicon( "friendly", "compass_waypoint_defend" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "friendly", "waypoint_defend" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "enemy", "compass_waypoint_target" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "enemy", "waypoint_target" );
    self maps\mp\gametypes\_gameobjects::setvisibleteam( "none" );
    self.trigger setinvisibletoall();
    self.useweapon = "briefcase_bomb_mp";
}

setupfordefusing()
{
    self maps\mp\gametypes\_gameobjects::allowuse( "friendly" );
    self maps\mp\gametypes\_gameobjects::setusetime( level.defusetime );
    self maps\mp\gametypes\_gameobjects::setusetext( &"MP_DEFUSING_EXPLOSIVE" );
    self maps\mp\gametypes\_gameobjects::setusehinttext( &"PLATFORM_HOLD_TO_DEFUSE_EXPLOSIVES" );
    self maps\mp\gametypes\_gameobjects::setkeyobject( undefined );
    self maps\mp\gametypes\_gameobjects::set2dicon( "friendly", "compass_waypoint_defuse" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "friendly", "waypoint_defuse" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "enemy", "compass_waypoint_defend" );
    self maps\mp\gametypes\_gameobjects::set3dicon( "enemy", "waypoint_defend" );
    self maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    self.trigger setvisibletoall();
}

bombdefused( object )
{
    setmatchflag( "bomb_timer", 0 );
    maps\mp\gametypes\_globallogic_utils::resumetimer();
    level.bombplanted = 0;

    if ( !level.inovertime )
        level.timelimitoverride = 0;

    level notify( "bomb_defused" );
}

onplayerkilled( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration )
{
    inbombzone = 0;
    inbombzoneteam = "none";

    if ( isdefined( level.bombzones["allies"] ) )
    {
        dist = distance2d( self.origin, level.bombzones["allies"].curorigin );

        if ( dist < level.defaultoffenseradius )
        {
            inbombzoneteam = "allies";
            inbombzone = 1;
        }
    }

    if ( isdefined( level.bombzones["axis"] ) )
    {
        dist = distance2d( self.origin, level.bombzones["axis"].curorigin );

        if ( dist < level.defaultoffenseradius )
        {
            inbombzoneteam = "axis";
            inbombzone = 1;
        }
    }

    if ( inbombzone && isplayer( attacker ) && attacker.pers["team"] != self.pers["team"] )
    {
        if ( inbombzoneteam == self.pers["team"] )
        {
            attacker maps\mp\_medals::offense( sweapon );
            attacker addplayerstatwithgametype( "OFFENDS", 1 );
            self recordkillmodifier( "defending" );
        }
        else
        {
            if ( isdefined( attacker.pers["defends"] ) )
            {
                attacker.pers["defends"]++;
                attacker.defends = attacker.pers["defends"];
            }

            attacker maps\mp\_medals::defenseglobalcount();
            attacker addplayerstatwithgametype( "DEFENDS", 1 );
            self recordkillmodifier( "assaulting" );
        }
    }

    if ( isplayer( attacker ) && attacker.pers["team"] != self.pers["team"] && isdefined( self.isbombcarrier ) && self.isbombcarrier == 1 )
        self recordkillmodifier( "carrying" );

    if ( self.isplanting == 1 )
        self recordkillmodifier( "planting" );

    if ( self.isdefusing == 1 )
        self recordkillmodifier( "defusing" );
}

onendgame( winningteam )
{
    if ( isdefined( winningteam ) && ( winningteam == "allies" || winningteam == "axis" ) )
        maps\mp\gametypes\_globallogic_score::giveteamscoreforobjective( winningteam, 1 );
}

onroundendgame( roundwinner )
{
    winner = maps\mp\gametypes\_globallogic::determineteamwinnerbygamestat( "roundswon" );
    return winner;
}

sab_gamemodespawndvars( reset_dvars )
{
    ss = level.spawnsystem;
    ss.sab_friendly_base_influencer_score = set_dvar_float_if_unset( "scr_spawn_sab_friendly_base_influencer_score", "100", reset_dvars );
    ss.sab_friendly_base_influencer_score_curve = set_dvar_if_unset( "scr_spawn_sab_friendly_base_influencer_score_curve", "constant", reset_dvars );
    ss.sab_friendly_base_influencer_radius = set_dvar_float_if_unset( "scr_spawn_sab_friendly_base_influencer_radius", "" + 15.0 * get_player_height(), reset_dvars );
    ss.sab_enemy_base_influencer_score = set_dvar_float_if_unset( "scr_spawn_sab_enemy_base_influencer_score", "-500", reset_dvars );
    ss.sab_enemy_base_influencer_score_curve = set_dvar_if_unset( "scr_spawn_sab_enemy_base_influencer_score_curve", "constant", reset_dvars );
    ss.sab_enemy_base_influencer_radius = set_dvar_float_if_unset( "scr_spawn_sab_enemy_base_influencer_radius", "" + 15.0 * get_player_height(), reset_dvars );
    ss.sab_carrier_influencer_score = set_dvar_float_if_unset( "scr_spawn_sab_carrier_influencer_score", "-75", reset_dvars );
    ss.sab_carrier_influencer_score_curve = set_dvar_if_unset( "scr_spawn_sab_carrier_influencer_score_curve", "linear", reset_dvars );
    ss.sab_carrier_influencer_radius = set_dvar_float_if_unset( "scr_spawn_sab_carrier_influencer_radius", "" + 8.0 * get_player_height(), reset_dvars );
}
