// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include common_scripts\utility;
#include maps\mp\gametypes\_hud_util;
#include maps\mp\gametypes\_globallogic;
#include maps\mp\gametypes\_callbacksetup;
#include maps\mp\gametypes\_gameobjects;
#include maps\mp\gametypes\_spawnlogic;
#include maps\mp\gametypes\_spawning;
#include maps\mp\gametypes\_globallogic_score;
#include maps\mp\teams\_teams;
#include maps\mp\gametypes\_rank;
#include maps\mp\_popups;
#include maps\mp\_scoreevents;
#include maps\mp\gametypes\_globallogic_audio;

main()
{
    if ( getdvar( #"mapname" ) == "mp_background" )
        return;

    maps\mp\gametypes\_globallogic::init();
    maps\mp\gametypes\_callbacksetup::setupcallbacks();
    maps\mp\gametypes\_globallogic::setupcallbacks();
    registerroundswitch( 0, 9 );
    registertimelimit( 0, 1440 );
    registerscorelimit( 0, 10000 );
    registerroundlimit( 0, 10 );
    registernumlives( 0, 100 );
    level.matchrules_enemyflagradar = 1;
    level.matchrules_damagemultiplier = 0;
    level.matchrules_vampirism = 0;
    setspecialloadouts();
    level.teambased = 1;
    level.initgametypeawards = ::initgametypeawards;
    level.onprecachegametype = ::onprecachegametype;
    level.onstartgametype = ::onstartgametype;
    level.onplayerkilled = ::onplayerkilled;
    level.onspawnplayer = ::onspawnplayer;
    level.onspawnplayerunified = ::onspawnplayerunified;
    level.onroundendgame = ::onroundendgame;
    level.onroundswitch = ::onroundswitch;
    precacheshader( "waypoint_targetneutral" );
    game["dialog"]["gametype"] = "team_def";

    if ( getdvarint( #"_id_46E18E53" ) )
        game["dialog"]["gametype"] = "hc_" + game["dialog"]["gametype"];

    game["dialog"]["got_flag"] = "ctf_wetake";
    game["dialog"]["enemy_got_flag"] = "ctf_theytake";
    game["dialog"]["dropped_flag"] = "ctf_wedrop";
    game["dialog"]["enemy_dropped_flag"] = "ctf_theydrop";
    game["strings"]["overtime_hint"] = &"MP_FIRST_BLOOD";
}

onprecachegametype()
{
    precachestring( &"MP_NEUTRAL_FLAG_CAPTURED_BY" );
    precachestring( &"MP_NEUTRAL_FLAG_DROPPED_BY" );
    precachestring( &"MP_GRABBING_FLAG" );
    precachestring( &"OBJECTIVES_TDEF_ATTACKER_HINT" );
    precachestring( &"OBJECTIVES_TDEF_DEFENDER_HINT" );
    precachestring( &"OBJECTIVES_TDEF" );
    precachestring( &"OBJECTIVES_TDEF_SCORE" );
    precachestring( &"OBJECTIVES_TDEF_HINT" );
}

onstartgametype()
{
    setclientnamemode( "auto_change" );

    if ( !isdefined( game["switchedsides"] ) )
        game["switchedsides"] = 0;

    if ( game["switchedsides"] )
    {
        oldattackers = game["attackers"];
        olddefenders = game["defenders"];
        game["attackers"] = olddefenders;
        game["defenders"] = oldattackers;
    }

    setobjectivetext( "allies", &"OBJECTIVES_TDEF" );
    setobjectivetext( "axis", &"OBJECTIVES_TDEF" );

    if ( level.splitscreen )
    {
        setobjectivescoretext( "allies", &"OBJECTIVES_TDEF" );
        setobjectivescoretext( "axis", &"OBJECTIVES_TDEF" );
    }
    else
    {
        setobjectivescoretext( "allies", &"OBJECTIVES_TDEF_SCORE" );
        setobjectivescoretext( "axis", &"OBJECTIVES_TDEF_SCORE" );
    }

    setobjectivehinttext( "allies", &"OBJECTIVES_TDEF_ATTACKER_HINT" );
    setobjectivehinttext( "axis", &"OBJECTIVES_TDEF_ATTACKER_HINT" );
    allowed[0] = level.gametype;
    allowed[1] = "tdm";
    maps\mp\gametypes\_gameobjects::main( allowed );
    level.spawnmins = ( 0, 0, 0 );
    level.spawnmaxs = ( 0, 0, 0 );
    maps\mp\gametypes\_spawnlogic::placespawnpoints( "mp_tdm_spawn_allies_start" );
    maps\mp\gametypes\_spawnlogic::placespawnpoints( "mp_tdm_spawn_axis_start" );
    maps\mp\gametypes\_spawnlogic::addspawnpoints( "allies", "mp_tdm_spawn" );
    maps\mp\gametypes\_spawnlogic::addspawnpoints( "axis", "mp_tdm_spawn" );
    maps\mp\gametypes\_spawning::updateallspawnpoints();
    level.mapcenter = maps\mp\gametypes\_spawnlogic::findboxcenter( level.spawnmins, level.spawnmaxs );
    setmapcenter( level.mapcenter );
    spawnpoint = maps\mp\gametypes\_spawnlogic::getrandomintermissionpoint();
    setdemointermissionpoint( spawnpoint.origin, spawnpoint.angles );

    if ( !isoneround() )
    {
        level.displayroundendtext = 1;

        if ( isscoreroundbased() )
            maps\mp\gametypes\_globallogic_score::resetteamscores();
    }

    tdef();
}

tdef()
{
    level.icon2d["allies"] = maps\mp\teams\_teams::getteamflagicon( "allies" );
    level.icon2d["axis"] = maps\mp\teams\_teams::getteamflagicon( "axis" );
    precacheshader( level.icon2d["axis"] );
    precacheshader( level.icon2d["allies"] );
    level.carryflag["allies"] = maps\mp\teams\_teams::getteamflagcarrymodel( "allies" );
    level.carryflag["axis"] = maps\mp\teams\_teams::getteamflagcarrymodel( "axis" );
    level.carryflag["neutral"] = maps\mp\teams\_teams::getteamflagmodel( "neutral" );
    precachemodel( level.carryflag["allies"] );
    precachemodel( level.carryflag["axis"] );
    precachemodel( level.carryflag["neutral"] );
    level.iconescort3d = "waypoint_defend_flag";
    level.iconescort2d = "waypoint_defend_flag";
    precacheshader( level.iconescort3d );
    precacheshader( level.iconescort2d );
    level.iconkill3d = "waypoint_kill";
    level.iconkill2d = "waypoint_kill";
    precacheshader( level.iconkill3d );
    precacheshader( level.iconkill2d );
    level.iconcaptureflag3d = "waypoint_grab_red";
    level.iconcaptureflag2d = "waypoint_grab_red";
    precacheshader( level.iconcaptureflag3d );
    precacheshader( level.iconcaptureflag2d );
    precacheshader( "waypoint_flag_friendly" );
    precacheshader( "waypoint_flag_enemy" );
    level.gameflag = undefined;
}

onplayerkilled( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration )
{
    if ( !isplayer( attacker ) || attacker.team == self.team )
        return;

    victim = self;
    score = maps\mp\gametypes\_rank::getscoreinfovalue( "kill" );
    assert( isdefined( score ) );

    if ( isdefined( level.gameflag ) && level.gameflag maps\mp\gametypes\_gameobjects::getownerteam() == attacker.team )
    {
        if ( isdefined( attacker.carryflag ) )
            attacker addplayerstat( "KILLSASFLAGCARRIER", 1 );
        else
        {

        }

        score = score * 2;
    }
    else if ( !isdefined( level.gameflag ) && cancreateflagatvictimorigin( victim ) )
    {
        level.gameflag = createflag( victim );
        score = score + maps\mp\gametypes\_rank::getscoreinfovalue( "MEDAL_FIRST_BLOOD" );
    }
    else if ( isdefined( victim.carryflag ) )
    {
        killcarrierbonus = maps\mp\gametypes\_rank::getscoreinfovalue( "kill_carrier" );
        level thread maps\mp\_popups::displayteammessagetoall( &"MP_KILLED_FLAG_CARRIER", attacker );
        maps\mp\_scoreevents::processscoreevent( "kill_flag_carrier", attacker );
        attacker recordgameevent( "kill_carrier" );
        attacker addplayerstat( "FLAGCARRIERKILLS", 1 );
        attacker notify( "objective", "kill_carrier" );
        score = score + killcarrierbonus;
    }

    attacker maps\mp\gametypes\_globallogic_score::giveteamscoreforobjective( attacker.team, score );
    otherteam = getotherteam( attacker.team );

    if ( game["state"] == "postgame" && game["teamScores"][attacker.team] > game["teamScores"][otherteam] )
        attacker.finalkill = 1;
}

ondrop( player )
{
    if ( isdefined( player ) && isdefined( player.tdef_flagtime ) )
    {
        flagtime = int( gettime() - player.tdef_flagtime );
        player addplayerstat( "HOLDINGTEAMDEFENDERFLAG", flagtime );

        if ( flagtime / 100 / 60 < 1 )
            flagminutes = 0;
        else
            flagminutes = int( flagtime / 100 / 60 );

        player addplayerstatwithgametype( "DESTRUCTIONS", flagminutes );
        player.tdef_flagtime = undefined;
        player notify( "dropped_flag" );
    }

    team = self maps\mp\gametypes\_gameobjects::getownerteam();
    otherteam = getotherteam( team );
    self.currentcarrier = undefined;
    self maps\mp\gametypes\_gameobjects::setownerteam( "neutral" );
    self maps\mp\gametypes\_gameobjects::allowcarry( "any" );
    self maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "friendly", level.iconcaptureflag2d );
    self maps\mp\gametypes\_gameobjects::set3dicon( "friendly", level.iconcaptureflag3d );
    self maps\mp\gametypes\_gameobjects::set2dicon( "enemy", level.iconcaptureflag2d );
    self maps\mp\gametypes\_gameobjects::set3dicon( "enemy", level.iconcaptureflag3d );

    if ( isdefined( player ) )
    {
        if ( isdefined( player.carryflag ) )
            player detachflag();

        printandsoundoneveryone( team, undefined, &"MP_NEUTRAL_FLAG_DROPPED_BY", &"MP_NEUTRAL_FLAG_DROPPED_BY", "mp_war_objective_lost", "mp_war_objective_lost", player );
    }
    else
    {
        playsoundonplayers( "mp_war_objective_lost", team );
        playsoundonplayers( "mp_war_objective_lost", otherteam );
    }

    maps\mp\gametypes\_globallogic_audio::leaderdialog( "dropped_flag", team );
    maps\mp\gametypes\_globallogic_audio::leaderdialog( "enemy_dropped_flag", otherteam );
}

onpickup( player )
{
    self notify( "picked_up" );
    player.tdef_flagtime = gettime();
    player thread watchforendgame();
    score = maps\mp\gametypes\_rank::getscoreinfovalue( "capture" );
    assert( isdefined( score ) );
    team = player.team;
    otherteam = getotherteam( team );

    if ( isdefined( level.tdef_loadouts ) && isdefined( level.tdef_loadouts[team] ) )
        player thread applyflagcarrierclass();
    else
        player attachflag();

    self.currentcarrier = player;
    player.carryicon setshader( level.icon2d[team], player.carryicon.width, player.carryicon.height );
    self maps\mp\gametypes\_gameobjects::setownerteam( team );
    self maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    self maps\mp\gametypes\_gameobjects::set2dicon( "friendly", level.iconescort2d );
    self maps\mp\gametypes\_gameobjects::set3dicon( "friendly", level.iconescort2d );
    self maps\mp\gametypes\_gameobjects::set2dicon( "enemy", level.iconkill3d );
    self maps\mp\gametypes\_gameobjects::set3dicon( "enemy", level.iconkill3d );
    maps\mp\gametypes\_globallogic_audio::leaderdialog( "got_flag", team );
    maps\mp\gametypes\_globallogic_audio::leaderdialog( "enemy_got_flag", otherteam );
    level thread maps\mp\_popups::displayteammessagetoall( &"MP_CAPTURED_THE_FLAG", player );
    maps\mp\_scoreevents::processscoreevent( "flag_capture", player );
    player recordgameevent( "pickup" );
    player addplayerstatwithgametype( "CAPTURES", 1 );
    player notify( "objective", "captured" );
    printandsoundoneveryone( team, undefined, &"MP_NEUTRAL_FLAG_CAPTURED_BY", &"MP_NEUTRAL_FLAG_CAPTURED_BY", "mp_obj_captured", "mp_enemy_obj_captured", player );

    if ( self.currentteam == otherteam )
        player maps\mp\gametypes\_globallogic_score::giveteamscoreforobjective( team, score );

    self.currentteam = team;

    if ( level.matchrules_enemyflagradar )
        self thread flagattachradar( otherteam );
}

applyflagcarrierclass()
{
    self endon( "death" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    if ( isdefined( self.iscarrying ) && self.iscarrying == 1 )
    {
        self notify( "force_cancel_placement" );
        wait 0.05;
    }

    self.pers["gamemodeLoadout"] = level.tdef_loadouts[self.team];
    spawnpoint = spawn( "script_model", self.origin );
    spawnpoint.angles = self.angles;
    spawnpoint.playerspawnpos = self.origin;
    spawnpoint.notti = 1;
    self.setspawnpoint = spawnpoint;
    self.gamemode_chosenclass = self.class;
    self.pers["class"] = "gamemode";
    self.pers["lastClass"] = "gamemode";
    self.class = "gamemode";
    self.lastclass = "gamemode";
    self thread waitattachflag();
}

waitattachflag()
{
    level endon( "game_ende" );
    self endon( "disconnect" );
    self endon( "death" );
    self waittill( "spawned_player" );
    self attachflag();
}

watchforendgame()
{
    self endon( "dropped_flag" );
    self endon( "disconnect" );
    level waittill( "game_ended" );

    if ( isdefined( self ) )
    {
        if ( isdefined( self.tdef_flagtime ) )
        {
            flagtime = int( gettime() - self.tdef_flagtime );
            self addplayerstat( "HOLDINGTEAMDEFENDERFLAG", flagtime );

            if ( flagtime / 100 / 60 < 1 )
                flagminutes = 0;
            else
                flagminutes = int( flagtime / 100 / 60 );

            self addplayerstatwithgametype( "DESTRUCTIONS", flagminutes );
        }
    }
}

cancreateflagatvictimorigin( victim )
{
    minetriggers = getentarray( "minefield", "targetname" );
    hurttriggers = getentarray( "trigger_hurt", "classname" );
    radtriggers = getentarray( "radiation", "targetname" );

    for ( index = 0; index < radtriggers.size; index++ )
    {
        if ( victim istouching( radtriggers[index] ) )
            return false;
    }

    for ( index = 0; index < minetriggers.size; index++ )
    {
        if ( victim istouching( minetriggers[index] ) )
            return false;
    }

    for ( index = 0; index < hurttriggers.size; index++ )
    {
        if ( victim istouching( hurttriggers[index] ) )
            return false;
    }

    return true;
}

createflag( victim )
{
    visuals[0] = spawn( "script_model", victim.origin );
    visuals[0] setmodel( level.carryflag["neutral"] );
    trigger = spawn( "trigger_radius", victim.origin, 0, 96, 72 );
    gameflag = maps\mp\gametypes\_gameobjects::createcarryobject( "neutral", trigger, visuals, vectorscale( ( 0, 0, 1 ), 85.0 ) );
    gameflag maps\mp\gametypes\_gameobjects::allowcarry( "any" );
    gameflag maps\mp\gametypes\_gameobjects::setvisibleteam( "any" );
    gameflag maps\mp\gametypes\_gameobjects::set2dicon( "enemy", level.iconcaptureflag2d );
    gameflag maps\mp\gametypes\_gameobjects::set3dicon( "enemy", level.iconcaptureflag3d );
    gameflag maps\mp\gametypes\_gameobjects::set2dicon( "friendly", level.iconcaptureflag2d );
    gameflag maps\mp\gametypes\_gameobjects::set3dicon( "friendly", level.iconcaptureflag3d );
    gameflag maps\mp\gametypes\_gameobjects::setcarryicon( level.icon2d["axis"] );
    gameflag.allowweapons = 1;
    gameflag.onpickup = ::onpickup;
    gameflag.onpickupfailed = ::onpickup;
    gameflag.ondrop = ::ondrop;
    gameflag.oldradius = 96;
    gameflag.currentteam = "none";
    gameflag.requireslos = 1;
    level.favorclosespawnent = gameflag.trigger;
    level.favorclosespawnscalar = 3;
    gameflag thread updatebaseposition();
    return gameflag;
}

updatebaseposition()
{
    level endon( "game_ended" );

    while ( true )
    {
        if ( isdefined( self.safeorigin ) )
        {
            self.baseorigin = self.safeorigin;
            self.trigger.baseorigin = self.safeorigin;
            self.visuals[0].baseorigin = self.safeorigin;
        }

        wait 0.05;
    }
}

attachflag()
{
    self attach( level.carryflag[self.team], "J_spine4", 1 );
    self.carryflag = level.carryflag[self.team];
    level.favorclosespawnent = self;
}

detachflag()
{
    self detach( self.carryflag, "J_spine4" );
    self.carryflag = undefined;
    level.favorclosespawnent = level.gameflag.trigger;
}

flagattachradar( team )
{
    level endon( "game_ended" );
    self endon( "dropped" );
}

getflagradarowner( team )
{
    level endon( "game_ended" );
    self endon( "dropped" );

    while ( true )
    {
        foreach ( player in level.players )
        {
            if ( isalive( player ) && player.team == team )
                return player;
        }

        wait 0.05;
    }
}

flagradarmover()
{
    level endon( "game_ended" );
    self endon( "dropped" );
    self.portable_radar endon( "death" );

    for (;;)
    {
        self.portable_radar moveto( self.currentcarrier.origin, 0.05 );
        wait 0.05;
    }
}

flagwatchradarownerlost()
{
    level endon( "game_ended" );
    self endon( "dropped" );
    radarteam = self.portable_radar.team;
    self.portable_radar.owner waittill_any( "disconnect", "joined_team", "joined_spectators" );
    flagattachradar( radarteam );
}

onroundendgame( roundwinner )
{
    winner = maps\mp\gametypes\_globallogic::determineteamwinnerbygamestat( "roundswon" );
    return winner;
}

onspawnplayerunified()
{
    self.usingobj = undefined;

    if ( level.usestartspawns && !level.ingraceperiod )
        level.usestartspawns = 0;

    maps\mp\gametypes\_spawning::onspawnplayer_unified();
}

onspawnplayer( predictedspawn )
{
    pixbeginevent( "TDM:onSpawnPlayer" );
    self.usingobj = undefined;
    spawnteam = self.pers["team"];

    if ( level.ingraceperiod )
    {
        spawnpoints = maps\mp\gametypes\_spawnlogic::getspawnpointarray( maps\mp\gametypes\_spawning::gettdmstartspawnname( spawnteam ) );

        if ( !spawnpoints.size )
            spawnpoints = maps\mp\gametypes\_spawnlogic::getspawnpointarray( maps\mp\gametypes\_spawning::getteamstartspawnname( spawnteam, "mp_sab_spawn" ) );

        if ( !spawnpoints.size )
        {
            if ( game["switchedsides"] )
                spawnteam = getotherteam( spawnteam );

            spawnpoints = maps\mp\gametypes\_spawnlogic::getteamspawnpoints( spawnteam );
            spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_nearteam( spawnpoints );
        }
        else
            spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_random( spawnpoints );
    }
    else
    {
        if ( game["switchedsides"] )
            spawnteam = getotherteam( spawnteam );

        spawnpoints = maps\mp\gametypes\_spawnlogic::getteamspawnpoints( spawnteam );
        spawnpoint = maps\mp\gametypes\_spawnlogic::getspawnpoint_nearteam( spawnpoints );
    }

    if ( predictedspawn )
        self predictspawnpoint( spawnpoint.origin, spawnpoint.angles );
    else
        self spawn( spawnpoint.origin, spawnpoint.angles, "tdm" );

    pixendevent();
}

onroundswitch()
{
    game["switchedsides"] = !game["switchedsides"];
}

initgametypeawards()
{

}

setspecialloadouts()
{

}
