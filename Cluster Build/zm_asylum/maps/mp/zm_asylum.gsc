// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include maps\mp\gametypes_zm\_spawning;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\animscripts\zm_death;
#include common_scripts\utility;
#include maps\mp\zm_asylum_fx;
#include maps\mp\zombies\_zm;
#include maps\mp\zombies\_load;
#include maps\mp\zm_asylum_amb;
#include maps\mp\zombies\_zm_radio;
#include maps\mp\_sticky_grenade;
#include maps\mp\zombies\_zm_weap_cymbal_monkey;
#include maps\mp\zombies\_zm_weap_ballistic_knife;
#include maps\mp\zombies\_zm_weap_bowie;
#include maps\mp\zombies\_zm_weap_thundergun;
#include maps\mp\zombies\_zm_weap_jetgun;
#include maps\mp\zombies\_zm_weap_claymore;
#include maps\mp\zombies\_zm_weap_freezegun;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\createart\zm_asylum_art;
#include character\c_usa_dempsey_zm;
#include character\c_rus_nikolai_zm;
#include character\c_jap_takeo_zm;
#include character\c_ger_richtofen_zm;
#include maps\mp\zombies\_zm_containment;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_game_module;

main()
{
    level.default_game_mode = "zclassic";
    maps\mp\zm_asylum_fx::main();
    maps\mp\zombies\_zm::init_fx();
    precache_gib_fx();
    level.zombiemode = 1;
    level._uses_retrievable_ballisitic_knives = 1;
    level.register_offhand_weapons_for_level_defaults_override = ::offhand_weapon_overrride;
    maps\mp\zombies\_load::main();
    maps\mp\zm_asylum_amb::main();
    zm_asylum_precache();
    level_use_unified_spawning( 1 );
    level._round_start_func = maps\mp\zombies\_zm::round_start;
    level.givecustomloadout = ::givecustomloadout;
    level.precachecustomcharacters = ::precachecustomcharacters;
    level.givecustomcharacters = ::givecustomcharacters;
    initcharacterstartindex();
    level._zombie_custom_add_weapons = ::custom_add_weapons;
    level.exit_level_func = ::exit_level_func;
    level._solo_revive_machine_expire_func = ::asylum_solo_revive_expire_func;
    include_weapons();
    include_limited_weapons();
    include_powerups();
    include_game_modules();
    setup_solo_revive_hack();
    init_level_specific_wall_buy_fx();
    maps\mp\zombies\_zm_radio::init();
    level.zombiemode_using_revive_perk = 1;
    level.zombiemode_using_doubletap_perk = 1;
    level.zombiemode_using_juggernaut_perk = 1;
    level.zombiemode_using_sleightofhand_perk = 1;
    level.zombiemode_using_additionalprimaryweapon_perk = 1;
    maps\mp\zombies\_zm::init();
    level thread maps\mp\_sticky_grenade::init();
    maps\mp\zombies\_zm_weap_cymbal_monkey::init();
    maps\mp\zombies\_zm_weap_ballistic_knife::init();
    maps\mp\zombies\_zm_weap_bowie::init();
    maps\mp\zombies\_zm_weap_thundergun::init();
    maps\mp\zombies\_zm_weap_jetgun::init();
    maps\mp\zombies\_zm_weap_claymore::init();
    maps\mp\zombies\_zm_weap_freezegun::init();
    level.zone_manager_init_func = ::asylum_zone_init;
    init_zones[0] = "west_downstairs_zone";
    init_zones[1] = "west2_downstairs_zone";
    level thread maps\mp\zombies\_zm_zonemgr::manage_zones( init_zones );
    level.zombie_ai_limit = 24;
    level.burning_zombies = [];
    maps\mp\createart\zm_asylum_art::main();
    init_zombie_asylum();
    init_sounds();
    level thread intro_screen();
    level thread spawn_point_override();
    level thread chair_useage();
    level thread magic_box_light();
    level thread mature_settings_changes();
    level thread master_electric_switch();
}

zm_asylum_precache()
{
    precachemodel( "tag_origin" );
    precachemodel( "p6_zm_zapper_power_box" );
    precachemodel( "p6_zm_zapper_power_box_on" );
    precachemodel( "zombie_zapper_cagelight_red" );
    precachemodel( "zombie_zapper_cagelight_green" );
    precacheshellshock( "electrocution" );
    precachemodel( "lights_tinhatlamp_off" );
    precachemodel( "lights_tinhatlamp_on" );
    precachemodel( "lights_indlight_on" );
    precachemodel( "lights_indlight" );
    precachemodel( "zombie_vending_doubletap2_on" );
    precachemodel( "zombie_vending_revive_on" );
    precachemodel( "zombie_vending_sleight_on" );
    precachemodel( "zombie_vending_jugg_on" );
    precachestring( &"ZOMBIE_ASYLUM_INTRO_ASYLUM_LEVEL_BERLIN" );
    precachestring( &"ZOMBIE_ASYLUM_INTRO_ASYLUM_LEVEL_HIMMLER" );
    precachestring( &"ZOMBIE_ASYLUM_INTRO_ASYLUM_LEVEL_SEPTEMBER" );
}

precachecustomcharacters()
{
    character\c_usa_dempsey_zm::precache();
    character\c_rus_nikolai_zm::precache();
    character\c_jap_takeo_zm::precache();
    character\c_ger_richtofen_zm::precache();
    precachemodel( "viewmodel_usa_pow_arms" );
    precachemodel( "viewmodel_rus_prisoner_arms" );
    precachemodel( "viewmodel_vtn_nva_standard_arms" );
    precachemodel( "viewmodel_usa_hazmat_arms" );
}

init_sounds()
{
    maps\mp\zombies\_zm_utility::add_sound( "break_stone", "break_stone" );
    maps\mp\zombies\_zm_utility::add_sound( "zmb_couch_slam", "couch_slam" );
    maps\mp\zombies\_zm_utility::add_sound( "door_slide_open", "door_slide_open" );
}

initcharacterstartindex()
{
    level.characterstartindex = randomint( 4 );
}

selectcharacterindextouse()
{
    if ( level.characterstartindex >= 4 )
        level.characterstartindex = 0;

    self.characterindex = level.characterstartindex;
    level.characterstartindex++;
    return self.characterindex;
}

givecustomcharacters()
{
    self detachall();

    switch ( self selectcharacterindextouse() )
    {
        case 0:
            self character\c_usa_dempsey_zm::main();
            self setviewmodel( "viewmodel_usa_pow_arms" );
            self.characterindex = 0;
            break;
        case 1:
            self character\c_rus_nikolai_zm::main();
            self setviewmodel( "viewmodel_rus_prisoner_arms" );
            self.characterindex = 1;
            break;
        case 2:
            self character\c_jap_takeo_zm::main();
            self setviewmodel( "viewmodel_vtn_nva_standard_arms" );
            self.characterindex = 2;
            break;
        case 3:
            self character\c_ger_richtofen_zm::main();
            self setviewmodel( "viewmodel_usa_hazmat_arms" );
            self.characterindex = 3;
            break;
    }

    self setmovespeedscale( 1 );
    self setsprintduration( 4 );
    self setsprintcooldown( 0 );
}

givecustomloadout( takeallweapons, alreadyspawned )
{
    self giveweapon( "knife_zm" );
    self give_start_weapon( 1 );
}

offhand_weapon_overrride()
{
    register_lethal_grenade_for_level( "frag_grenade_zm" );
    level.zombie_lethal_grenade_player_init = "frag_grenade_zm";
    register_tactical_grenade_for_level( "cymbal_monkey_zm" );
    level.zombie_tactical_grenade_player_init = undefined;
    register_placeable_mine_for_level( "claymore_zm" );
    level.zombie_placeable_mine_player_init = undefined;
    register_melee_weapon_for_level( "knife_zm" );
    level.zombie_melee_weapon_player_init = "knife_zm";
}

asylum_zone_init()
{
    add_adjacent_zone( "west_downstairs_zone", "west2_downstairs_zone", "power_on" );
    add_adjacent_zone( "west2_downstairs_zone", "north_downstairs_zone", "north_door1" );
    add_adjacent_zone( "north_downstairs_zone", "north_upstairs_zone", "north_upstairs_blocker" );
    add_adjacent_zone( "north_upstairs_zone", "north2_upstairs_zone", "upstairs_north_door1" );
    add_adjacent_zone( "north2_upstairs_zone", "kitchen_upstairs_zone", "upstairs_north_door2" );
    add_adjacent_zone( "kitchen_upstairs_zone", "power_upstairs_zone", "magic_box_north" );
    add_adjacent_zone( "west_downstairs_zone", "south_upstairs_zone", "south_upstairs_blocker" );
    add_adjacent_zone( "south_upstairs_zone", "south2_upstairs_zone", "south_access_1" );
    add_adjacent_zone( "south2_upstairs_zone", "power_upstairs_zone", "magic_box_south" );
}

include_powerups()
{
    include_powerup( "nuke" );
    include_powerup( "insta_kill" );
    include_powerup( "double_points" );
    include_powerup( "full_ammo" );
    include_powerup( "carpenter" );
}

include_weapons()
{
    include_weapon( "knife_zm", 0 );
    include_weapon( "claymore_zm", 0 );
    include_weapon( "frag_grenade_zm", 0 );
    include_weapon( "m1911_zm", 0 );
    include_weapon( "m1911_upgraded_zm", 0 );
    include_weapon( "python_zm" );
    include_weapon( "python_upgraded_zm", 0 );
    include_weapon( "fiveseven_zm" );
    include_weapon( "fiveseven_upgraded_zm", 0 );
    include_weapon( "fivesevendw_zm" );
    include_weapon( "fivesevendw_upgraded_zm", 0 );
    include_weapon( "mp5k_zm", 0 );
    include_weapon( "mp5k_upgraded_zm", 0 );
    include_weapon( "mp40_zm", 0 );
    include_weapon( "mp40_upgraded_zm", 0 );
    include_weapon( "mpl_zm", 0 );
    include_weapon( "mpl_upgraded_zm", 0 );
    include_weapon( "pm63_zm", 0 );
    include_weapon( "pm63_upgraded_zm", 0 );
    include_weapon( "kard_zm" );
    include_weapon( "kard_upgraded_zm", 0 );
    include_weapon( "saiga12_zm" );
    include_weapon( "saiga12_upgraded_zm", 0 );
    include_weapon( "thompson_zm", 0 );
    include_weapon( "thompson_upgraded_zm", 0 );
    include_weapon( "rottweil72_zm", 0 );
    include_weapon( "rottweil72_upgraded_zm", 0 );
    include_weapon( "srm1216_zm" );
    include_weapon( "srm1216_upgraded_zm", 0 );
    include_weapon( "hs10_zm" );
    include_weapon( "hs10_upgraded_zm", 0 );
    include_weapon( "judge_zm", 0 );
    include_weapon( "judge_upgraded_zm", 0 );
    include_weapon( "870mcs_zm", 0 );
    include_weapon( "870mcs_upgraded_zm", 0 );
    include_weapon( "m14_zm", 0 );
    include_weapon( "m14_upgraded_zm", 0 );
    include_weapon( "type95_zm" );
    include_weapon( "type95_upgraded_zm", 0 );
    include_weapon( "tar21_zm" );
    include_weapon( "tar21_upgraded_zm", 0 );
    include_weapon( "galil_zm" );
    include_weapon( "galil_upgraded_zm", 0 );
    include_weapon( "hk416_zm" );
    include_weapon( "hk416_upgraded_zm", 0 );
    include_weapon( "fnfal_zm", 0 );
    include_weapon( "fnfal_upgraded_zm", 0 );
    include_weapon( "sa58_zm" );
    include_weapon( "sa58_upgraded_zm", 0 );
    include_weapon( "an94_zm", 0 );
    include_weapon( "an94_upgraded_zm", 0 );
    include_weapon( "xm8_zm" );
    include_weapon( "xm8_upgraded_zm", 0 );
    include_weapon( "dsr50_zm" );
    include_weapon( "dsr50_upgraded_zm", 0 );
    include_weapon( "ballista_zm", 0 );
    include_weapon( "ballista_upgraded_zm", 0 );
    include_weapon( "rpd_zm" );
    include_weapon( "rpd_upgraded_zm", 0 );
    include_weapon( "hamr_zm" );
    include_weapon( "hamr_upgraded_zm", 0 );
    include_weapon( "mp44_zm", 0 );
    include_weapon( "mp44_upgraded_zm", 0 );
    include_weapon( "usrpg_zm" );
    include_weapon( "usrpg_upgraded_zm", 0 );
    include_weapon( "m32_zm" );
    include_weapon( "m32_upgraded_zm", 0 );
    include_weapon( "cymbal_monkey_zm" );
    include_weapon( "emp_grenade_zm" );
    include_weapon( "ray_gun_zm" );
    include_weapon( "ray_gun_upgraded_zm", 0 );
    include_weapon( "thundergun_zm" );
    include_weapon( "thundergun_upgraded_zm", 0 );
    include_weapon( "jetgun_zm" );
    include_weapon( "jetgun_upgraded_zm", 0 );
    include_weapon( "tazer_knuckles_zm" );
    include_weapon( "knife_ballistic_no_melee_zm", 0 );
    include_weapon( "knife_ballistic_no_melee_upgraded_zm", 0 );
    include_weapon( "knife_ballistic_zm" );
    include_weapon( "knife_ballistic_upgraded_zm", 0 );
    include_weapon( "freezegun_zm" );
    include_weapon( "freezegun_upgraded_zm", 0 );
}

include_limited_weapons()
{
    add_limited_weapon( "m1911_zm", 0 );
    add_limited_weapon( "thundergun_zm", 1 );
    add_limited_weapon( "knife_ballistic_zm", 1 );
    add_limited_weapon( "jetgun_zm", 1 );
    add_limited_weapon( "freezegun_zm", 1 );
}

custom_add_weapons()
{
    add_zombie_weapon( "m1911_zm", "m1911_upgraded_zm", &"ZOMBIE_WEAPON_M1911", 500, "burstrifle", "", undefined );
    add_zombie_weapon( "python_zm", "python_upgraded_zm", &"ZOMBIE_WEAPON_PYTHON", 500, "pistol", "", undefined );
    add_zombie_weapon( "fiveseven_zm", "fiveseven_upgraded_zm", &"ZOMBIE_WEAPON_FIVESEVEN", 50, "pistol", "", undefined );
    add_zombie_weapon( "fivesevendw_zm", "fivesevendw_upgraded_zm", &"ZOMBIE_WEAPON_FIVESEVENDW", 50, "wpck_duel57", "", undefined, 1 );
    add_zombie_weapon( "ak74u_zm", "ak74u_upgraded_zm", &"ZOMBIE_WEAPON_AK74U", 1200, "smg", "", undefined );
    add_zombie_weapon( "mp5k_zm", "mp5k_upgraded_zm", &"ZOMBIE_WEAPON_MP5K", 1000, "smg", "", undefined );
    add_zombie_weapon( "saiga12_zm", "saiga12_upgraded_zm", &"ZOMBIE_WEAPON_SAIGA12", 1000, "wpck_saiga12", "", undefined );
    add_zombie_weapon( "srm1216_zm", "srm1216_upgraded_zm", &"ZOMBIE_WEAPON_SRM1216", 50, "shotgun", "", undefined );
    add_zombie_weapon( "frag_grenade_zm", undefined, &"ZOMBIE_WEAPON_FRAG_GRENADE", 250, "grenade", "", undefined );
    add_zombie_weapon( "claymore_zm", undefined, &"ZOMBIE_WEAPON_CLAYMORE", 1000, "grenade", "", undefined );
    add_zombie_weapon( "sticky_grenade_zm", undefined, &"ZOMBIE_WEAPON_STICKY_GRENADE", 250, "grenade", "", undefined );
    add_zombie_weapon( "cymbal_monkey_zm", undefined, &"ZOMBIE_WEAPON_SATCHEL_2000", 2000, "monkey", "", undefined );
    add_zombie_weapon( "emp_grenade_zm", undefined, &"ZOMBIE_WEAPON_EMP_GRENADE", 2000, "grenade", "", undefined );
    add_zombie_weapon( "ray_gun_zm", "ray_gun_upgraded_zm", &"ZOMBIE_WEAPON_RAYGUN", 10000, "raygun", "", undefined );
    add_zombie_weapon( "thundergun_zm", "thundergun_upgraded_zm", &"ZOMBIE_WEAPON_THUNDERGUN", 10, "thunder", "", undefined );
    add_zombie_weapon( "jetgun_zm", "jetgun_upgraded_zm", &"ZOMBIE_WEAPON_JETGUN", 2000, "jet", "", undefined );
    add_zombie_weapon( "knife_ballistic_zm", "knife_ballistic_upgraded_zm", &"ZOMBIE_WEAPON_KNIFE_BALLISTIC", 10, "sickle", "", undefined );
    add_zombie_weapon( "knife_ballistic_bowie_zm", "knife_ballistic_bowie_upgraded_zm", &"ZOMBIE_WEAPON_KNIFE_BALLISTIC", 10, "sickle", "", undefined );
    add_zombie_weapon( "knife_ballistic_no_melee_zm", "knife_ballistic_no_melee_upgraded_zm", &"ZOMBIE_WEAPON_KNIFE_BALLISTIC", 10, "sickle", "", undefined );
    add_zombie_weapon( "freezegun_zm", "freezegun_upgraded_zm", &"ZOMBIE_WEAPON_FREEZEGUN", 10, "freezegun", "", undefined );
    add_zombie_weapon( "mp40_zm", "mp40_upgraded_zm", &"ZOMBIE_WEAPON_MP40", 1000, "smg", "", undefined );
    add_zombie_weapon( "mpl_zm", "mpl_upgraded_zm", &"ZOMBIE_WEAPON_MPL", 1000, "smg", "", undefined );
    add_zombie_weapon( "pm63_zm", "pm63_upgraded_zm", &"ZOMBIE_WEAPON_PM63", 1000, "smg", "", undefined );
    add_zombie_weapon( "kard_zm", "kard_upgraded_zm", &"ZOMBIE_WEAPON_KARD", 50, "smg", "", undefined );
    add_zombie_weapon( "thompson_zm", "thompson_upgraded_zm", &"ZOMBIE_ASYLUM_WEAPON_THOMPSON", 1200, "smg", "", undefined );
    add_zombie_weapon( "hs10_zm", "hs10_upgraded_zm", &"ZOMBIE_WEAPON_HS10", 50, "shotgun", "", undefined );
    add_zombie_weapon( "rottweil72_zm", "rottweil72_upgraded_zm", &"ZOMBIE_WEAPON_ROTTWEIL72", 500, "shotgun", "", undefined );
    add_zombie_weapon( "judge_zm", "judge_upgraded_zm", &"ZOMBIE_WEAPON_JUDGE", 600, "shotgun", "", undefined );
    add_zombie_weapon( "870mcs_zm", "870mcs_upgraded_zm", &"ZOMBIE_WEAPON_870MCS", 1500, "shotgun", "", undefined );
    add_zombie_weapon( "an94_zm", "an94_upgraded_zm", &"ZOMBIE_WEAPON_AN94", 600, "rifle", "", undefined );
    add_zombie_weapon( "m14_zm", "m14_upgraded_zm", &"ZOMBIE_WEAPON_M14", 600, "rifle", "", undefined );
    add_zombie_weapon( "type95_zm", "type95_upgraded_zm", &"ZOMBIE_WEAPON_TYPE95", 50, "wpck_type25", "", undefined, 1 );
    add_zombie_weapon( "g11_lps_zm", "g11_lps_upgraded_zm", &"ZOMBIE_WEAPON_G11", 900, "burstrifle", "", undefined );
    add_zombie_weapon( "fnfal_zm", "fnfal_upgraded_zm", &"ZOMBIE_WEAPON_FNFAL", 600, "burstrifle", "", undefined );
    add_zombie_weapon( "sa58_zm", "sa58_upgraded_zm", &"ZOMBIE_WEAPON_SA58", 600, "burstrifle", "", undefined );
    add_zombie_weapon( "tar21_zm", "tar21_upgraded_zm", &"ZOMBIE_WEAPON_TAR21", 50, "wpck_x95l", "", undefined, 1 );
    add_zombie_weapon( "commando_zm", "hk416_upgraded_zm", &"ZOMBIE_WEAPON_COMMANDO", 100, "assault", "", undefined );
    add_zombie_weapon( "galil_zm", "galil_upgraded_zm", &"ZOMBIE_WEAPON_GALIL", 50, "assault", "", undefined );
    add_zombie_weapon( "xm8_zm", "xm8_upgraded_zm", &"ZOMBIE_WEAPON_XM8", 50, "assault", "", undefined, 1 );
    add_zombie_weapon( "dsr50_zm", "dsr50_upgraded_zm", &"ZOMBIE_WEAPON_DSR50", 50, "sniper", "", undefined );
    add_zombie_weapon( "ballista_zm", "ballista_upgraded_zm", &"ZOMBIE_ASYLUM_WEAPON_BALLISTA", 200, "sniper", "", undefined );
    add_zombie_weapon( "rpd_zm", "rpd_upgraded_zm", &"ZOMBIE_WEAPON_RPD", 4000, "mg", "", undefined );
    add_zombie_weapon( "hamr_zm", "hamr_upgraded_zm", &"ZOMBIE_WEAPON_HAMR", 50, "mg", "", undefined );
    add_zombie_weapon( "mp44_zm", "mp44_upgraded_zm", &"ZOMBIE_ASYLUM_WEAPON_MP44", 1200, "mg", "", undefined );
    add_zombie_weapon( "usrpg_zm", "usrpg_upgraded_zm", &"ZOMBIE_WEAPON_USRPG", 2000, "launcher", "", undefined );
    add_zombie_weapon( "m32_zm", "m32_upgraded_zm", &"ZOMBIE_WEAPON_M32", 2000, "rifle", "", undefined );
}

include_game_modules()
{
    maps\mp\zombies\_zm_containment::register_game_module();
}

intro_screen()
{
    flag_wait( "start_zombie_round_logic" );
    wait 2;
    level.intro_hud = [];

    for ( i = 0; i < 3; i++ )
    {
        level.intro_hud[i] = newhudelem();
        level.intro_hud[i].x = 0;
        level.intro_hud[i].y = 0;
        level.intro_hud[i].alignx = "left";
        level.intro_hud[i].aligny = "bottom";
        level.intro_hud[i].horzalign = "left";
        level.intro_hud[i].vertalign = "bottom";
        level.intro_hud[i].foreground = 1;

        if ( level.splitscreen && !level.hidef )
            level.intro_hud[i].fontscale = 2.75;
        else
            level.intro_hud[i].fontscale = 1.75;

        level.intro_hud[i].alpha = 0.0;
        level.intro_hud[i].color = ( 1, 1, 1 );
        level.intro_hud[i].inuse = 0;
    }

    level.intro_hud[0].y = -110;
    level.intro_hud[1].y = -90;
    level.intro_hud[2].y = -70;
    level.intro_hud[0] settext( &"ZOMBIE_ASYLUM_INTRO_ASYLUM_LEVEL_BERLIN" );
    level.intro_hud[1] settext( &"ZOMBIE_ASYLUM_INTRO_ASYLUM_LEVEL_HIMMLER" );
    level.intro_hud[2] settext( &"ZOMBIE_ASYLUM_INTRO_ASYLUM_LEVEL_SEPTEMBER" );

    for ( i = 0; i < 3; i++ )
    {
        level.intro_hud[i] fadeovertime( 1.5 );
        level.intro_hud[i].alpha = 1;
        wait 1.5;
    }

    wait 1.5;

    for ( i = 0; i < 3; i++ )
    {
        level.intro_hud[i] fadeovertime( 1.5 );
        level.intro_hud[i].alpha = 0;
        wait 1.5;
    }

    for ( i = 0; i < 3; i++ )
        level.intro_hud[i] destroy();

    level thread magic_box_limit_location_init();
}

init_level_specific_wall_buy_fx()
{
    level._effect["frag_grenade_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_frag_nade" );
    level._effect["an94_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_an94" );
    level._effect["ballista_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_ballista" );
    level._effect["judge_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_executioner" );
    level._effect["fnfal_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_fal" );
    level._effect["mp40_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_mp40" );
    level._effect["mp44_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_stg44" );
    level._effect["thompson_zm_fx"] = loadfx( "maps/zombie/fx_zmb_wall_buy_thompson" );
}

init_zombie_asylum()
{
    flag_init( "electric_switch_used" );
    flag_set( "spawn_point_override" );
    level thread init_elec_trap_trigs();
    level thread init_lights();
    water_trigs = getentarray( "waterfall", "targetname" );
    array_thread( water_trigs, ::watersheet_on_trigger );
}

init_elec_trap_trigs()
{
    trap_trigs = getentarray( "gas_access", "targetname" );
    array_thread( trap_trigs, ::electric_trap_think );
    array_thread( trap_trigs, ::electric_trap_dialog );
}

electric_trap_think()
{
    self.is_available = undefined;
    self.zombie_cost = 1000;
    self.in_use = 0;
    self sethintstring( &"ZOMBIE_NEED_POWER" );
    self setcursorhint( "HINT_NOICON" );
    flag_wait( "power_on" );

    while ( true )
    {
        self sethintstring( &"ZOMBIE_BUTTON_BUY_TRAP", self.zombie_cost );
        self waittill( "trigger", who );

        if ( who in_revive_trigger() )
            continue;

        if ( !isdefined( self.is_available ) )
            continue;

        if ( is_player_valid( who ) )
        {
            if ( who.score >= self.zombie_cost )
            {
                if ( !self.in_use )
                {
                    self.in_use = 1;
                    play_sound_at_pos( "purchase", who.origin );
                    self thread electric_trap_move_switch( self );
                    self waittill( "switch_activated" );
                    who minus_to_player_score( self.zombie_cost );
                    self sethintstring( &"ZOMBIE_TRAP_ACTIVE" );
                    self.zombie_dmg_trig = getent( self.target, "targetname" );
                    self.zombie_dmg_trig trigger_on();
                    self thread activate_electric_trap();
                    self waittill( "elec_done" );
                    clientnotify( self.script_string + "off" );

                    if ( isdefined( self.fx_org ) )
                        self.fx_org delete();

                    if ( isdefined( self.zapper_fx_org ) )
                        self.zapper_fx_org delete();

                    if ( isdefined( self.zapper_fx_switch_org ) )
                        self.zapper_fx_switch_org delete();

                    self.zombie_dmg_trig trigger_off();
                    self sethintstring( &"ZOMBIE_TRAP_COOLDOWN" );
                    wait 25;
                    speakera = getstruct( "loudspeaker", "targetname" );
                    playsoundatposition( "warning", speakera.origin );
                    self notify( "available" );
                    self.in_use = 0;
                }
            }
        }
    }
}

activate_electric_trap()
{
    if ( isdefined( self.script_string ) && self.script_string == "north" )
    {
        machine = getent( "zap_machine_north", "targetname" );
        machine setmodel( "p6_zm_zapper_power_box_on" );
        clientnotify( "north" );
    }
    else
    {
        machine = getent( "zap_machine_south", "targetname" );
        machine setmodel( "p6_zm_zapper_power_box_on" );
        clientnotify( "south" );
    }

    clientnotify( self.target );
    fire_points = getstructarray( self.target, "targetname" );

    for ( i = 0; i < fire_points.size; i++ )
    {
        wait_network_frame();
        fire_points[i] thread electric_trap_fx( self );
    }

    self.zombie_dmg_trig thread elec_barrier_damage();
    level waittill( "arc_done" );
    machine setmodel( "p6_zm_zapper_power_box" );
}

electric_trap_fx( notify_ent )
{
    self.tag_origin = spawn( "script_model", self.origin );
    self.tag_origin setmodel( "tag_origin" );
    playfxontag( level._effect["zapper"], self.tag_origin, "tag_origin" );

    if ( isdefined( self.script_sound ) )
    {
        self.tag_origin playsound( "zmb_elec_start" );
        self.tag_origin playloopsound( "zmb_elec_loop" );
        self thread play_electrical_sound();
    }

    wait 25;

    if ( isdefined( self.script_sound ) )
        self.tag_origin stoploopsound();

    self.tag_origin delete();
    notify_ent notify( "elec_done" );
    level notify( "arc_done" );
}

elec_barrier_damage()
{
    while ( true )
    {
        self waittill( "trigger", ent );

        if ( isplayer( ent ) )
            ent thread player_elec_damage();
        else if ( !isdefined( ent.marked_for_death ) )
        {
            ent.marked_for_death = 1;
            ent thread zombie_elec_death( randomint( 100 ) );
        }
    }
}

electric_trap_move_switch( parent )
{
    tswitch = getent( "zapper_switch_" + parent.script_linkto, "targetname" );

    if ( tswitch.script_linkname == "4" )
    {
        north_zapper_light_red();
        tswitch rotatepitch( -180, 0.5 );
        tswitch playsound( "amb_sparks_l_b" );
        tswitch waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "available" );
        tswitch rotatepitch( 180, 0.5 );
        north_zapper_light_green();
    }
    else
    {
        south_zapper_light_red();
        tswitch rotatepitch( 180, 0.5 );
        tswitch playsound( "amb_sparks_l_b" );
        tswitch waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "available" );
        tswitch rotatepitch( -180, 0.5 );
        south_zapper_light_green();
    }
}

electric_trap_dialog()
{
    self endon( "warning_dialog" );
    level endon( "switch_flipped" );
    timer = 0;

    while ( true )
    {
        wait 0.5;
        players = get_players();

        for ( i = 0; i < players.size; i++ )
        {
            dist = distancesquared( players[i].origin, self.origin );

            if ( dist > 4900 )
            {
                timer = 0;
                continue;
            }

            if ( dist < 4900 && timer < 3 )
            {
                wait 0.5;
                timer++;
            }

            if ( dist < 4900 && timer == 3 )
            {
                wait 3;
                self notify( "warning_dialog" );
            }
        }
    }
}

play_elec_vocals()
{
    if ( isdefined( self ) )
    {
        org = self.origin;
        wait 0.15;
        playsoundatposition( "zmb_elec_vocals", org );
        playsoundatposition( "zmb_zombie_arc", org );
        playsoundatposition( "zmb_exp_jib_zombie", org );
    }
}

play_music_easter_egg( player )
{
    level.music_override = 1;
    level thread maps\mp\zombies\_zm_audio::change_zombie_music( "egg" );
    wait 245;
    level.music_override = 0;
    level thread maps\mp\zombies\_zm_audio::change_zombie_music( "wave_loop" );
}

chair_useage()
{
    wait 2;
    chair_counter = 0;
    chair_trig = getent( "dentist_chair", "targetname" );
    chair_trig setcursorhint( "HINT_NOICON" );
    chair_trig usetriggerrequirelookat();
    players = getplayers();

    while ( true )
    {
        wait 0.05;

        for ( i = 0; i < players.size; i++ )
        {
            chair_trig waittill( "trigger", players );
            chair_counter++;

            if ( chair_counter == 3 )
            {
                playsoundatposition( "chair", chair_trig.origin );
                chair_counter = 0;
            }
        }
    }
}

toilet_useage()
{
    toilet_counter = 0;
    toilet_trig = getent( "toilet", "targetname" );
    toilet_trig setcursorhint( "HINT_NOICON" );
    toilet_trig usetriggerrequirelookat();
    players = getplayers();

    if ( !isdefined( level.music_override ) )
        level.music_override = 0;

    while ( true )
    {
        wait 0.5;
        toilet_trig waittill( "trigger" );
        toilet_trig playsoundwithnotify( "toilet_flush", "sound_done" );
        toilet_trig waittill( "sound_done" );
        toilet_counter++;

        if ( toilet_counter == 3 )
        {
            playsoundatposition( "zmb_cha_ching", toilet_trig.origin );
            level thread play_music_easter_egg();
        }
    }
}

init_lights()
{
    tinhats = [];
    arms = [];
    ents = getentarray( "elect_light_model", "targetname" );

    for ( i = 0; i < ents.size; i++ )
    {
        if ( issubstr( ents[i].model, "tinhat" ) )
            tinhats[tinhats.size] = ents[i];

        if ( issubstr( ents[i].model, "indlight" ) )
            arms[arms.size] = ents[i];
    }

    for ( i = 0; i < tinhats.size; i++ )
    {
        wait_network_frame();
        tinhats[i] setmodel( "lights_tinhatlamp_off" );
    }

    for ( i = 0; i < arms.size; i++ )
    {
        wait_network_frame();
        arms[i] setmodel( "lights_indlight" );
    }

    flag_wait( "electric_switch_used" );

    for ( i = 0; i < tinhats.size; i++ )
    {
        wait_network_frame();
        tinhats[i] setmodel( "lights_tinhatlamp_on" );
    }

    for ( i = 0; i < arms.size; i++ )
    {
        wait_network_frame();
        arms[i] setmodel( "lights_indlight_on" );
    }
}

player_elec_damage()
{
    self endon( "death" );
    self endon( "disconnect" );

    if ( !isdefined( level.elec_loop ) )
        level.elec_loop = 0;

    if ( !isdefined( self.is_burning ) && !self player_is_in_laststand() )
    {
        self.is_burning = 1;
        self setelectrified( 1.25 );
        shocktime = 2.5;
        self shellshock( "electrocution", shocktime );

        if ( level.elec_loop == 0 )
        {
            elec_loop = 1;
            self playsound( "zmb_zombie_arc" );
        }

        if ( !self hasperk( "specialty_armorvest" ) || self.health - 100 < 1 )
        {
            radiusdamage( self.origin, 10, self.health + 100, self.health + 100 );
            self.is_burning = undefined;
        }
        else
        {
            self dodamage( 50, self.origin );
            wait 0.1;
            self.is_burning = undefined;
        }
    }
}

zombie_elec_death( flame_chance )
{
    self endon( "death" );

    if ( flame_chance > 90 && level.burning_zombies.size < 6 )
    {
        level.burning_zombies[level.burning_zombies.size] = self;
        self thread zombie_flame_watch();
        self playsound( "zmb_ignite" );
        self thread flame_death_fx();
        wait( randomfloat( 1.25 ) );
    }
    else
    {
        refs[0] = "guts";
        refs[1] = "right_arm";
        refs[2] = "left_arm";
        refs[3] = "right_leg";
        refs[4] = "left_leg";
        refs[5] = "no_legs";
        refs[6] = "head";
        self.a.gib_ref = refs[randomint( refs.size )];
        playsoundatposition( "zmb_zombie_arc", self.origin );

        if ( randomint( 100 ) > 40 )
        {
            self thread electroctute_death_fx();
            self thread play_elec_vocals();
        }

        wait( randomfloat( 1.25 ) );
        self playsound( "zmb_zombie_arc" );
    }

    self dodamage( self.health + 666, self.origin );
}

zombie_flame_watch()
{
    self waittill( "death" );
    self stoploopsound();
    arrayremovevalue( level.burning_zombies, self );
}

spawn_point_override()
{
    flag_wait( "start_zombie_round_logic" );
    players = get_players();
    north_structs = getstructarray( "north_spawn", "script_noteworthy" );
    south_structs = getstructarray( "south_spawn", "script_noteworthy" );
    side1 = north_structs;
    side2 = south_structs;

    if ( randomint( 100 ) > 50 )
    {
        side1 = south_structs;
        side2 = north_structs;
    }

    for ( i = 0; i < players.size; i++ )
    {
        if ( i < 2 )
        {
            players[i] setorigin( side1[i].origin );
            players[i] setplayerangles( side1[i].angles );
            players[i].respawn_point = side1[i];
            players[i].spawn_side = side1[i].script_noteworthy;
            players[i].spectator_respawn = side1[i];
            continue;
        }

        players[i] setorigin( side2[i].origin );
        players[i] setplayerangles( side2[i].angles );
        players[i].respawn_point = side2[i];
        players[i].spawn_side = side2[i].script_noteworthy;
        players[i].spectator_respawn = side2[i];
    }
}

disable_bump_trigger( triggername )
{
    triggers = getentarray( "audio_bump_trigger", "targetname" );

    if ( isdefined( triggers ) )
    {
        for ( i = 0; i < triggers.size; i++ )
        {
            if ( isdefined( triggers[i].script_label ) && triggers[i].script_label == triggername )
                triggers[i].script_activated = 0;
        }
    }
}

master_electric_switch()
{
    trig = getent( "use_master_switch", "targetname" );
    master_switch = getent( "master_switch", "targetname" );
    master_switch notsolid();
    trig sethintstring( &"ZOMBIE_ELECTRIC_SWITCH" );
    trig setcursorhint( "HINT_NOICON" );
    fx_org = spawn( "script_model", ( -674.922, -300.473, 284.125 ) );
    fx_org setmodel( "tag_origin" );
    fx_org.angles = vectorscale( ( 0, 1, 0 ), 90.0 );
    playfxontag( level._effect["electric_power_gen_idle"], fx_org, "tag_origin" );
    cheat = 0;
/#
    if ( getdvarint( #"_id_FA81816F" ) >= 3 )
    {
        wait 5;
        cheat = 1;
    }
#/

    if ( cheat != 1 )
        trig waittill( "trigger", user );

    master_switch rotateroll( -90, 0.3 );
    master_switch playsound( "zmb_switch_flip" );
    maps\mp\zombies\_zm_game_module::turn_power_on_and_open_doors();
    level notify( "switch_flipped" );
    disable_bump_trigger( "switch_door_trig" );
    level thread play_the_numbers();
    left_org = getent( "audio_swtch_left", "targetname" );
    right_org = getent( "audio_swtch_right", "targetname" );
    left_org_b = getent( "audio_swtch_b_left", "targetname" );
    right_org_b = getent( "audio_swtch_b_right", "targetname" );

    if ( isdefined( left_org ) )
        left_org playsound( "amb_sparks_l" );

    if ( isdefined( left_org_b ) )
        left_org playsound( "amb_sparks_l_b" );

    if ( isdefined( right_org ) )
        right_org playsound( "amb_sparks_r" );

    if ( isdefined( right_org_b ) )
        right_org playsound( "amb_sparks_r_b" );

    setclientsysstate( "levelNotify", "start_lights" );
    level thread play_pa_system();
    flag_set( "electric_switch_used" );
    trig delete();
    traps = getentarray( "gas_access", "targetname" );

    for ( i = 0; i < traps.size; i++ )
    {
        traps[i] sethintstring( &"ZOMBIE_ELECTRIC_SWITCH" );
        traps[i] setcursorhint( "HINT_NOICON" );
        traps[i].is_available = 1;
    }

    master_switch waittill( "rotatedone" );
    playfx( level._effect["switch_sparks"], getstruct( "switch_fx", "targetname" ).origin );
    level notify( "master_switch_activated" );
    fx_org delete();
    fx_org = spawn( "script_model", ( -675.021, -300.906, 283.724 ) );
    fx_org setmodel( "tag_origin" );
    fx_org.angles = vectorscale( ( 0, 1, 0 ), 90.0 );
    playfxontag( level._effect["electric_power_gen_on"], fx_org, "tag_origin" );
    fx_org playloopsound( "zmb_elec_current_loop" );
    level thread north_zapper_light_green();
    level thread south_zapper_light_green();
    wait 6;
    fx_org stoploopsound();
    level notify( "sleight_on" );
    wait_network_frame();
    level notify( "revive_on" );
    wait_network_frame();
    level notify( "doubletap_on" );
    wait_network_frame();
    level notify( "juggernog_on" );
    exploder( 101 );
    wait 8;
    playsoundatposition( "amb_sparks_l_end", left_org.origin );
    playsoundatposition( "amb_sparks_r_end", right_org.origin );
}

electric_trap_wire_sparks( side )
{
    self endon( "elec_done" );

    while ( true )
    {
        sparks = getstruct( "trap_wire_sparks_" + side, "targetname" );
        self.fx_org = spawn( "script_model", sparks.origin );
        self.fx_org setmodel( "tag_origin" );
        self.fx_org.angles = sparks.angles;
        playfxontag( level._effect["electric_current"], self.fx_org, "tag_origin" );
        targ = getstruct( sparks.target, "targetname" );

        while ( isdefined( targ ) )
        {
            self.fx_org moveto( targ.origin, 0.15 );
            self.fx_org playloopsound( "zmb_elec_current_loop", 0.1 );
            self.fx_org waittill( "movedone" );
            self.fx_org stoploopsound( 0.1 );

            if ( isdefined( targ.target ) )
                targ = getstruct( targ.target, "targetname" );
            else
                targ = undefined;
        }

        playfxontag( level._effect["electric_short_oneshot"], self.fx_org, "tag_origin" );
        wait( randomintrange( 3, 9 ) );
        self.fx_org delete();
    }
}

electric_current_open_middle_door()
{
    sparks = getstruct( "electric_middle_door", "targetname" );
    fx_org = spawn( "script_model", sparks.origin );
    fx_org setmodel( "tag_origin" );
    fx_org.angles = sparks.angles;
    playfxontag( level._effect["electric_current"], fx_org, "tag_origin" );
    targ = getstruct( sparks.target, "targetname" );

    while ( isdefined( targ ) )
    {
        fx_org moveto( targ.origin, 0.075 );

        if ( isdefined( targ.script_noteworthy ) && ( targ.script_noteworthy == "junction_boxs" || targ.script_noteworthy == "electric_end" ) )
            playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );

        fx_org playloopsound( "zmb_elec_current_loop", 0.1 );
        fx_org waittill( "movedone" );
        fx_org stoploopsound( 0.1 );

        if ( isdefined( targ.target ) )
            targ = getstruct( targ.target, "targetname" );
        else
            targ = undefined;
    }

    level notify( "electric_on_middle_door" );
    playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );
    wait( randomintrange( 3, 9 ) );
    fx_org delete();
}

electric_current_revive_machine()
{
    sparks = getstruct( "revive_electric_wire", "targetname" );
    fx_org = spawn( "script_model", sparks.origin );
    fx_org setmodel( "tag_origin" );
    fx_org.angles = sparks.angles;
    playfxontag( level._effect["electric_current"], fx_org, "tag_origin" );
    targ = getstruct( sparks.target, "targetname" );
    wait 0.2;

    while ( isdefined( targ ) )
    {
        fx_org moveto( targ.origin, 0.075 );

        if ( isdefined( targ.script_noteworthy ) && targ.script_noteworthy == "junction_revive" )
            playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );

        fx_org playloopsound( "zmb_elec_current_loop", 0.1 );
        fx_org waittill( "movedone" );
        fx_org stoploopsound( 0.1 );

        if ( isdefined( targ.target ) )
            targ = getstruct( targ.target, "targetname" );
        else
            targ = undefined;
    }

    level notify( "revive_on" );
    playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );
    wait( randomintrange( 3, 9 ) );
    fx_org delete();
}

electric_current_reload_machine()
{
    sparks = getstruct( "electric_fast_reload", "targetname" );
    fx_org = spawn( "script_model", sparks.origin );
    fx_org setmodel( "tag_origin" );
    fx_org.angles = sparks.angles;
    playfxontag( level._effect["electric_current"], fx_org, "tag_origin" );
    targ = getstruct( sparks.target, "targetname" );

    while ( isdefined( targ ) )
    {
        fx_org moveto( targ.origin, 0.075 );

        if ( isdefined( targ.script_noteworthy ) && targ.script_noteworthy == "reload_junction" )
            playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );

        fx_org playloopsound( "zmb_elec_current_loop", 0.1 );
        fx_org waittill( "movedone" );
        fx_org stoploopsound( 0.1 );

        if ( isdefined( targ.target ) )
            targ = getstruct( targ.target, "targetname" );
        else
            targ = undefined;
    }

    level notify( "sleight_on" );
    playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );
    wait( randomintrange( 3, 9 ) );
    fx_org delete();
}

electric_current_doubletap_machine()
{
    sparks = getstruct( "electric_double_tap", "targetname" );
    fx_org = spawn( "script_model", sparks.origin );
    fx_org setmodel( "tag_origin" );
    fx_org.angles = sparks.angles;
    playfxontag( level._effect["electric_current"], fx_org, "tag_origin" );
    targ = getstruct( sparks.target, "targetname" );

    while ( isdefined( targ ) )
    {
        fx_org moveto( targ.origin, 0.075 );

        if ( isdefined( targ.script_noteworthy ) && targ.script_noteworthy == "double_tap_junction" )
            playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );

        fx_org playloopsound( "zmb_elec_current_loop", 0.1 );
        fx_org waittill( "movedone" );
        fx_org stoploopsound( 0.1 );

        if ( isdefined( targ.target ) )
            targ = getstruct( targ.target, "targetname" );
        else
            targ = undefined;
    }

    level notify( "doubletap_on" );
    playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );
    wait( randomintrange( 3, 9 ) );
    fx_org delete();
}

electric_current_juggernog_machine()
{
    sparks = getstruct( "electric_juggernog", "targetname" );
    fx_org = spawn( "script_model", sparks.origin );
    fx_org setmodel( "tag_origin" );
    fx_org.angles = sparks.angles;
    playfxontag( level._effect["electric_current"], fx_org, "tag_origin" );
    targ = getstruct( sparks.target, "targetname" );

    while ( isdefined( targ ) )
    {
        fx_org moveto( targ.origin, 0.075 );
        fx_org playloopsound( "zmb_elec_current_loop", 0.1 );
        fx_org waittill( "movedone" );
        fx_org stoploopsound( 0.1 );

        if ( isdefined( targ.target ) )
            targ = getstruct( targ.target, "targetname" );
        else
            targ = undefined;
    }

    level notify( "juggernog_on" );
    playfxontag( level._effect["electric_short_oneshot"], fx_org, "tag_origin" );
    wait( randomintrange( 3, 9 ) );
    fx_org delete();
}

north_zapper_light_red()
{
    zapper_lights = getentarray( "zapper_light_north", "targetname" );

    for ( i = 0; i < zapper_lights.size; i++ )
        zapper_lights[i] setmodel( "zombie_zapper_cagelight_red" );

    if ( isdefined( level.north_light ) )
        level.north_light delete();

    level.north_light = spawn( "script_model", ( 366, 476, 329 ) );
    level.north_light setmodel( "tag_origin" );
    level.north_light.angles = vectorscale( ( 0, 1, 0 ), 270.0 );
    playfxontag( level._effect["zapper_light_notready"], level.north_light, "tag_origin" );
}

north_zapper_light_green()
{
    zapper_lights = getentarray( "zapper_light_north", "targetname" );

    for ( i = 0; i < zapper_lights.size; i++ )
        zapper_lights[i] setmodel( "zombie_zapper_cagelight_green" );

    if ( isdefined( level.north_light ) )
        level.north_light delete();

    level.north_light = spawn( "script_model", ( 366, 476, 329 ) );
    level.north_light setmodel( "tag_origin" );
    level.north_light.angles = vectorscale( ( 0, 1, 0 ), 270.0 );
    playfxontag( level._effect["zapper_light_ready"], level.north_light, "tag_origin" );
}

south_zapper_light_red()
{
    zapper_lights = getentarray( "zapper_light_south", "targetname" );

    for ( i = 0; i < zapper_lights.size; i++ )
        zapper_lights[i] setmodel( "zombie_zapper_cagelight_red" );

    if ( isdefined( level.south_light ) )
        level.south_light delete();

    level.south_light = spawn( "script_model", ( 168, -404, 330 ) );
    level.south_light setmodel( "tag_origin" );
    level.south_light.angles = vectorscale( ( 0, 1, 0 ), 90.0 );
    playfxontag( level._effect["zapper_light_notready"], level.south_light, "tag_origin" );
}

south_zapper_light_green()
{
    zapper_lights = getentarray( "zapper_light_south", "targetname" );

    for ( i = 0; i < zapper_lights.size; i++ )
        zapper_lights[i] setmodel( "zombie_zapper_cagelight_green" );

    if ( isdefined( level.south_light ) )
        level.south_light delete();

    level.south_light = spawn( "script_model", ( 168, -404, 330 ) );
    level.south_light setmodel( "tag_origin" );
    level.south_light.angles = vectorscale( ( 0, 1, 0 ), 270.0 );
    playfxontag( level._effect["zapper_light_ready"], level.south_light, "tag_origin" );
}

electroctute_death_fx()
{
    self endon( "death" );

    if ( isdefined( self.is_electrocuted ) && self.is_electrocuted )
        return;

    self.is_electrocuted = 1;
    self thread electrocute_timeout();

    if ( self.team == "axis" )
    {
        level.bconfiretime = gettime();
        level.bconfireorg = self.origin;
    }

    playfxontag( level._effect["elec_torso"], self, "J_SpineLower" );
    self playsound( "zmb_elec_jib_zombie" );
    wait 1;
    tagarray = [];
    tagarray[0] = "J_Elbow_LE";
    tagarray[1] = "J_Elbow_RI";
    tagarray[2] = "J_Knee_RI";
    tagarray[3] = "J_Knee_LE";
    tagarray = array_randomize( tagarray );
    playfxontag( level._effect["elec_md"], self, tagarray[0] );
    self playsound( "zmb_elec_jib_zombie" );
    wait 1;
    self playsound( "zmb_elec_jib_zombie" );
    tagarray[0] = "J_Wrist_RI";
    tagarray[1] = "J_Wrist_LE";

    if ( !isdefined( self.a.gib_ref ) || self.a.gib_ref != "no_legs" )
    {
        tagarray[2] = "J_Ankle_RI";
        tagarray[3] = "J_Ankle_LE";
    }

    tagarray = array_randomize( tagarray );
    playfxontag( level._effect["elec_sm"], self, tagarray[0] );
    playfxontag( level._effect["elec_sm"], self, tagarray[1] );
}

electrocute_timeout()
{
    self endon( "death" );
    self playloopsound( "amb_fire_manager_0" );
    wait 12;
    self stoploopsound();

    if ( isdefined( self ) && isalive( self ) )
    {
        self.is_electrocuted = 0;
        self notify( "stop_flame_damage" );
    }
}

play_the_numbers()
{
    while ( true )
    {
        wait( randomintrange( 15, 20 ) );
        playsoundatposition( "the_numbers", ( -608, -336, 304 ) );
        wait( randomintrange( 15, 20 ) );
    }
}

magic_box_limit_location_init()
{
    level.open_chest_location = [];
    level.open_chest_location[0] = undefined;
    level.open_chest_location[1] = undefined;
    level.open_chest_location[2] = undefined;
    level.open_chest_location[3] = "opened_chest";
    level.open_chest_location[4] = "start_chest";
    level thread waitfor_flag_open_chest_location( "magic_box_south" );
    level thread waitfor_flag_open_chest_location( "south_access_1" );
    level thread waitfor_flag_open_chest_location( "north_door1" );
    level thread waitfor_flag_open_chest_location( "north_upstairs_blocker" );
    level thread waitfor_flag_open_chest_location( "south_upstairs_blocker" );
}

waitfor_flag_open_chest_location( which )
{
    wait 3;

    switch ( which )
    {
        case "magic_box_south":
            flag_wait( "magic_box_south" );
            level.open_chest_location[0] = "magic_box_south";
            break;
        case "south_access_1":
            flag_wait( "south_access_1" );
            level.open_chest_location[0] = "magic_box_south";
            level.open_chest_location[1] = "magic_box_bathroom";
            break;
        case "north_door1":
            flag_wait( "north_door1" );
            level.open_chest_location[2] = "magic_box_hallway";
            break;
        case "north_upstairs_blocker":
            flag_wait( "north_upstairs_blocker" );
            level.open_chest_location[2] = "magic_box_hallway";
            break;
        case "south_upstairs_blocker":
            flag_wait( "south_upstairs_blocker" );
            level.open_chest_location[1] = "magic_box_bathroom";
            break;
        default:
            return;
    }
}

magic_box_light()
{
    open_light = getent( "opened_chest_light", "script_noteworthy" );
    hallway_light = getent( "magic_box_hallway_light", "script_noteworthy" );
    open_light_model = getent( "opened_chest_model", "script_noteworthy" );
    hallway_light_model = getent( "magic_box_hallway_model", "script_noteworthy" );

    while ( true )
    {
        level waittill( "magic_box_light_switch" );
        open_light setlightintensity( 0 );
        hallway_light setlightintensity( 0 );
        open_light_model setmodel( "lights_tinhatlamp_off" );
        hallway_light_model setmodel( "lights_tinhatlamp_off" );

        if ( level.chests[level.chest_index].script_noteworthy == "opened_chest" )
        {
            open_light setlightintensity( 1 );
            open_light_model setmodel( "lights_tinhatlamp_on" );
        }
        else if ( level.chests[level.chest_index].script_noteworthy == "magic_box_hallway" )
        {
            hallway_light setlightintensity( 1 );
            hallway_light_model setmodel( "lights_tinhatlamp_on" );
        }
    }
}

watersheet_on_trigger()
{
    while ( true )
    {
        self waittill( "trigger", who );

        if ( isdefined( who ) && isplayer( who ) && isalive( who ) && who.sessionstate != "spectator" )
        {
            if ( !who player_is_in_laststand() )
                wait 0.1;
        }
    }
}

setup_custom_vox()
{
    level.plr_vox["level"]["power"] = "power";
}

exit_level_func()
{
    zombies = getaiarray( level.zombie_team );

    foreach ( zombie in zombies )
    {
        if ( isdefined( zombie.ignore_solo_last_stand ) && zombie.ignore_solo_last_stand )
            continue;

        if ( isdefined( zombie.find_exit_point ) )
        {
            zombie thread [[ zombie.find_exit_point ]]();
            continue;
        }

        if ( zombie.ignoreme )
        {
            zombie thread maps\mp\zombies\_zm::default_delayed_exit();
            continue;
        }

        zombie thread maps\mp\zombies\_zm::default_find_exit_point();
    }
}

setup_solo_revive_hack()
{
    a_m_revive_models = getentarray( "vending_revive", "targetname" );

    foreach ( m_revive in a_m_revive_models )
    {
        if ( m_revive.classname == "script_brushmodel" )
        {
            m_revive.targetname = "vending_revive_clip";
            break;
        }
    }
}

asylum_solo_revive_expire_func()
{
    m_clip = getent( "vending_revive_clip", "targetname" );
    level.quick_revive_machine waittill( "movedone" );
    m_clip notsolid();
}

play_electrical_sound()
{
    level endon( "arc_done" );

    while ( true )
    {
        wait( randomfloatrange( 0.1, 0.5 ) );
        playsoundatposition( "zmb_elec_arc", self.origin );
    }
}

play_pa_system()
{
    clientnotify( "switch_flipped_generator" );
    speakera = getstruct( "loudspeaker", "targetname" );
    playsoundatposition( "alarm", speakera.origin );
    level thread play_comp_sounds();
    generator_arc = getent( "generator_arc", "targetname" );
    generator_arc playloopsound( "gen_arc_loop" );
    wait 4.0;
    generator = getent( "generator_origin", "targetname" );
    generator playloopsound( "generator_loop" );
    wait 8.0;
    playsoundatposition( "amb_pa_system", speakera.origin );
}

play_comp_sounds()
{
    computer = getent( "comp", "targetname" );
    computer playsound( "comp_start" );
    wait 6;
    computer playloopsound( "comp_loop" );
}

mature_settings_changes()
{
    if ( !is_mature() )
    {
        master_switch = getent( "master_switch", "targetname" );

        if ( isdefined( master_switch ) )
            master_switch setmodel( "zombie_power_lever_handle" );

        asylum_chair_mature = getent( "asylum_chair_mature", "targetname" );

        if ( isdefined( asylum_chair_mature ) )
            asylum_chair_mature setmodel( "zombie_asylum_chair_nogore" );
    }
}
