// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include maps\mp\gametypes_zm\_hud_util;
#include common_scripts\utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_game_module;
#include maps\mp\zombies\_zm_containment;
#include maps\mp\zombies\_zm;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zombies\_zm_score;

register_game_module()
{
    level.game_module_containment_index = 1;
    maps\mp\zombies\_zm_game_module::register_game_module( level.game_module_containment_index, "containment", maps\mp\zombies\_zm_containment::containment_pre_init, maps\mp\zombies\_zm_containment::containment_post_init );
}

containment_pre_init()
{
    if ( level.scr_zm_game_module != level.game_module_containment_index )
        return;
}

containment_post_init()
{
    if ( level.scr_zm_game_module != level.game_module_containment_index )
        return;

    level thread main();
}

main()
{
    if ( getdvar( #"_id_5C1C5F18" ) == "" )
        setdvar( "max_zombie_escapees", "25" );

    if ( getdvar( #"_id_3F8A7E7C" ) == "" )
        setdvar( "req_player_by_point", "0" );

    if ( getdvar( #"_id_BBF60051" ) == "" )
        setdvar( "player_move_point", "0" );

    level.zm_gamemodule_spawn_func = ::containment_onplayerspawn;
    level._zombie_custom_spawn_logic = ::zombie_goto_escape_point;
    level.round_prestart_func = ::containment_prestart;
    precachemodel( "TAG_ORIGIN" );
    level.zombie_containment = 1;
    level.max_escaped_zombies = getdvarint( #"_id_5C1C5F18" );
    level.require_players_by_point = getdvarint( #"_id_3F8A7E7C" );
    level.player_causes_point_to_move = getdvarint( #"_id_BBF60051" );
    level._effect["escape"] = loadfx( "maps/zombie/fx_zombie_exit_glow" );
    level._effect["escape_tail"] = loadfx( "maps/zombie/zombie_fx_exit_marker" );
    level thread init_containment();
    level.zombies_killed = 0;
    level.zombies_to_reduce_meter = 3;
}

init_containment()
{
    level.current_game_module = level.game_module_containment_index;
    level.zone_occupied_func = ::escape_spot_in_zone;
    wait 4;
    level thread monitor_end_game();
    level thread create_zombie_escape_spot();
    level thread escape_spot_round_logic();
    level thread escape_spot_player_logic();
    level thread create_escape_progress_bar();
    level thread escape_spot_monitor();
}

containment_prestart()
{
    setdvar( "zombie_unlock_all", 1 );
    flag_set( "power_on" );
    players = get_players();
    zombie_doors = getentarray( "zombie_door", "targetname" );

    for ( i = 0; i < zombie_doors.size; i++ )
    {
        zombie_doors[i] notify( "trigger", players[0] );
        wait 0.05;
    }

    zombie_airlock_doors = getentarray( "zombie_airlock_buy", "targetname" );

    for ( i = 0; i < zombie_airlock_doors.size; i++ )
    {
        zombie_airlock_doors[i] notify( "trigger", players[0] );
        wait 0.05;
    }

    zombie_debris = getentarray( "zombie_debris", "targetname" );

    for ( i = 0; i < zombie_debris.size; i++ )
    {
        zombie_debris[i] notify( "trigger", players[0] );
        wait 0.05;
    }

    wait 1;
    setdvar( "zombie_unlock_all", 0 );
    level thread set_round();
}

set_round()
{
    wait 10;
    target_round = 7;
    level.devcheater = 1;
    level.zombie_total = 0;
    maps\mp\zombies\_zm::ai_calculate_health( target_round );
    level.round_number = target_round - 1;
    level notify( "kill_round" );
    wait 1;
    zombies = get_round_enemy_array();

    if ( isdefined( zombies ) )
    {
        for ( i = 0; i < zombies.size; i++ )
        {
            if ( is_true( zombies[i].ignore_devgui_death ) )
                continue;

            zombies[i] dodamage( zombies[i].health + 666, zombies[i].origin );
        }
    }
}

escape_spot_in_zone( zone_name )
{
    in_zone = 0;
    scr_org = spawn( "script_origin", level._current_cont_spot.origin + vectorscale( ( 0, 0, 1 ), 40.0 ) );
    in_zone = scr_org maps\mp\zombies\_zm_zonemgr::entity_in_zone( zone_name );
    scr_org delete();
    return in_zone;
}

create_zombie_escape_spot()
{
    level._cont_spots = getstructarray( "zcon_escape_spot", "targetname" );
    level._current_cont_spot = getstruct( "zcon_start", "script_noteworthy" );
    level.escape_spot_fx = spawn( "script_model", level._current_cont_spot.origin );
    level.escape_spot_fx setmodel( "TAG_ORIGIN" );
    wait 0.1;
    trace = bullettrace( level.escape_spot_fx.origin + vectorscale( ( 0, 0, 1 ), 50.0 ), level.escape_spot_fx.origin + vectorscale( ( 0, 0, -1 ), 60.0 ), 0, undefined );
    level.escape_spot_fx rotateto( vectortoangles( trace["normal"] ), 0.1 );
    playfxontag( level._effect["escape"], level.escape_spot_fx, "TAG_ORIGIN" );
    playfxontag( level._effect["escape_tail"], level.escape_spot_fx, "TAG_ORIGIN" );

    if ( isdefined( level._effect["black_hole_bomb_portal_exit"] ) )
        playfxontag( level._effect["black_hole_bomb_portal_exit"], level.obj_spot, "tag_origin" );

    level.escape_spot = spawn( "trigger_radius", level.escape_spot_fx.origin, 9, 48, 96 );
    level.escape_spot thread wait_for_zombie_to_esacpe();
    level.escape_spot_fx create_zombie_point_of_interest( undefined, 30, 0, 0 );
    level.escape_spot_fx thread create_zombie_point_of_interest_attractor_positions( 4, 45 );
    level.current_poi = level.escape_spot_fx;
}

rotate_sam()
{
    z = 0;

    while ( true )
    {
        self.angles = self.angles + ( 0, 1, 0 );
        wait 0.05;
    }
}

zombie_goto_escape_point()
{
    self endon( "death" );
    level endon( "end_game" );
    level endon( "fake_death" );
    self thread zombie_wait_for_death();

    if ( randomint( 100 ) > 65 )
        self.ignore_goal = 0;
    else
        self.ignore_goal = 1;

    enemyoverride = [];
    enemyoverride[0] = level.current_poi.origin;
    enemyoverride[1] = level.current_poi;

    while ( isdefined( self ) && isalive( self ) && !level.intermission )
    {
        player = get_closest_valid_player( self.origin, undefined );

        if ( !isdefined( player ) )
        {
            wait_network_frame();
            continue;
        }

        dist_to_player = distancesquared( player.origin, self.origin );
        dist_to_goal = distancesquared( level.escape_spot.origin, self.origin );

        if ( dist_to_player < 16384 && self.ignore_goal )
            self.enemyoverride = undefined;
        else
            self.enemyoverride = enemyoverride;

        wait 0.5;
    }
}

zombie_wait_for_death()
{
    self waittill( "death" );

    if ( isdefined( self.attacker ) && isplayer( self.attacker ) )
    {
        if ( level.require_players_by_point )
        {
            if ( distancesquared( self.attacker.origin, level.escape_spot.origin ) > 65536 )
                return;
        }

        level.zombies_killed++;

        if ( level.zombies_killed >= level.zombies_to_reduce_meter )
        {
            level.zombies_killed = 0;

            if ( level.escaped_zombies - 1 > 0 )
                level.escaped_zombies--;
        }
    }

    players = get_players();

    for ( i = 0; i < players.size; i++ )
        players[i].escape_progress thread maps\mp\gametypes_zm\_hud_util::updatebarscale( level.escaped_zombies / level.max_escaped_zombies );
}

create_escape_progress_bar()
{
    players = get_players();

    for ( i = 0; i < players.size; i++ )
        players[i] maps\mp\zombies\_zm_score::add_to_player_score( 500 );
}

wait_for_zombie_to_esacpe()
{
    level.escaped_zombies = 0;

    while ( true )
    {
        self waittill( "trigger", who );

        if ( isdefined( self.is_moving_to_spot ) )
            continue;

        if ( !isplayer( who ) )
        {
            org = who.origin;
            who.a.nodeath = 1;

            if ( isdefined( who.headmodel ) )
                who.headmodel delete();

            who delete();

            if ( isdefined( level._effect["black_hole_bomb_zombie_destroy"] ) )
                playfx( level._effect["black_hole_bomb_zombie_destroy"], org );
            else
                playfx( level._effect["poltergeist"], org + vectorscale( ( 0, 0, 1 ), 10.0 ) );

            playsoundatposition( "lightning_l", org );
            level.escaped_zombies++;
            players = get_players();

            for ( i = 0; i < players.size; i++ )
                players[i].escape_progress thread maps\mp\gametypes_zm\_hud_util::updatebarscale( level.escaped_zombies / level.max_escaped_zombies );

            if ( level.escaped_zombies > level.max_escaped_zombies - 1 )
            {
                iprintlnbold( "Too many zombies have escaped!" );
                wait 2;
                level notify( "end_game" );
                maps\mp\zombies\_zm::end_game();
                return;
            }
        }

        wait 0.1;
    }
}

escape_spot_round_logic()
{
    level waittill( "between_round_over" );

    while ( true )
    {
        level waittill_either( "between_round_over", "player_moved_spot" );
        spots = level._cont_spots;
        arrayremovevalue( spots, level._current_cont_spot );
        new_spot = random( spots );
        level._current_cont_spot = new_spot;
        level notify( "move_spot", new_spot );
        level.last_exit_moved = level.escaped_zombies;
    }
}

escape_spot_player_logic()
{
    if ( !is_true( level.player_causes_point_to_move ) )
        return;

    level endon( "end_game" );
    dist_check = 16384;
    zombie_dist_check = 40000;
    should_move = 0;

    while ( true )
    {
        if ( isdefined( level.escape_spot.is_moving_to_spot ) )
        {
            wait 0.1;
            continue;
        }

        should_move = 0;
        players = get_players();

        for ( i = 0; i < players.size; i++ )
        {
            player = players[i];

            if ( distancesquared( player.origin, level.escape_spot.origin ) < dist_check )
                should_move = 1;
        }

        wait 2;

        if ( should_move )
        {
            zombies = get_round_enemy_array();

            if ( isdefined( zombies ) )
            {
                for ( i = 0; i < zombies.size; i++ )
                {
                    if ( distancesquared( zombies[i].origin, level.escape_spot.origin ) < zombie_dist_check )
                        should_move = 0;
                }
            }
        }

        if ( should_move )
        {
            nearby = 0;
            players = get_players();

            for ( i = 0; i < players.size; i++ )
            {
                player = players[i];

                if ( distancesquared( player.origin, level.escape_spot.origin ) < dist_check )
                    nearby++;
            }

            if ( nearby == 0 )
                should_move = 0;
        }

        if ( should_move )
            level notify( "player_moved_spot" );

        wait 0.1;
    }
}

escape_spot_monitor()
{
    while ( true )
    {
        level waittill( "move_spot", new_spot );

        if ( isdefined( level.escape_spot.is_moving_to_spot ) )
            continue;

        level.escape_spot.is_moving_to_spot = 1;
        level.current_poi deactivate_zombie_point_of_interest();
        level.escape_spot_fx playsound( level.zmb_laugh_alias );
        level.escape_spot_fx moveto( new_spot.origin, 20 );
        level.escape_spot.origin = new_spot.origin;
        level.escape_spot_fx waittill( "movedone" );
        level.escape_spot_fx create_zombie_point_of_interest( undefined, 30, 0, 0 );
        level.escape_spot_fx thread create_zombie_point_of_interest_attractor_positions( 4, 45 );
        level.current_poi = level.escape_spot_fx;
        wait 0.5;
        level.escape_spot.is_moving_to_spot = undefined;
    }
}

monitor_end_game()
{
    while ( !level.intermission )
        wait_network_frame();

    level notify( "end_game" );
}

containment_onplayerspawn()
{
    if ( !isdefined( self.escape_progress ) )
    {
        self.escape_progress = self maps\mp\gametypes_zm\_hud_util::createprimaryprogressbar();
        self.escape_progress maps\mp\gametypes_zm\_hud_util::setpoint( "CENTER", "TOP", -200, 40 );
    }
}
