// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zombies\_zm_audio;

init_roofs()
{
    flag_wait( "curtains_done" );
    level thread quad_stage_roof_break();
    level thread quad_lobby_roof_break();
    level thread quad_dining_roof_break();
    level thread quad_roof_fx();
}

quad_roof_crumble_fx()
{
    quad_crumble_triggers = getentarray( "quad_roof_crumble_fx_trigger", "targetname" );
    array_thread( quad_crumble_triggers, ::quad_roof_crumble_fx_play );
}

quad_roof_crumble_fx_play()
{
    roof_parts = getentarray( self.target, "targetname" );

    if ( isdefined( roof_parts ) )
    {
        for ( i = 0; i < roof_parts.size; i++ )
            roof_parts[i] delete();
    }

    fx = getstruct( self.target, "targetname" );

    if ( isdefined( fx ) )
        thread rumble_all_players( "damage_heavy" );

    if ( isdefined( self.script_noteworthy ) )
        clientnotify( self.script_noteworthy );

    if ( isdefined( self.script_int ) )
        exploder( self.script_int );
}

play_quad_first_sounds()
{
    location = getstruct( self.target, "targetname" );
    self playsound( "zmb_vocals_quad_spawn", "sounddone" );
    self waittill( "sounddone" );
    self playsound( "zmb_quad_roof_hit" );
    thread play_wood_land_sound( location.origin );
}

play_wood_land_sound( origin )
{
    wait 1;
    playsoundatposition( "zmb_quad_roof_break_land", origin - vectorscale( ( 0, 0, 1 ), 150.0 ) );
}

rumble_all_players( high_rumble_string, low_rumble_string, rumble_org, high_rumble_range, low_rumble_range )
{
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( isdefined( high_rumble_range ) && isdefined( low_rumble_range ) && isdefined( rumble_org ) )
        {
            if ( distance( players[i].origin, rumble_org ) < high_rumble_range )
                players[i] playrumbleonentity( high_rumble_string );
            else if ( distance( players[i].origin, rumble_org ) < low_rumble_range )
                players[i] playrumbleonentity( low_rumble_string );

            continue;
        }

        players[i] playrumbleonentity( high_rumble_string );
    }
}

quad_roof_fx()
{
    quad_roof_triggers = getentarray( "quad_roof_dust_effect_trigger", "targetname" );
    array_thread( quad_roof_triggers, ::quad_roof_fx_play );
}

quad_roof_fx_play()
{
    while ( true )
    {
        self waittill( "trigger", who );

        if ( is_true( who.triggered ) )
            continue;
        else
            who.triggered = 1;

        exploder( self.script_int );
    }
}

quad_traverse_death_fx()
{
    self endon( "quad_end_traverse_anim" );
    self waittill( "death" );
    playfx( level._effect["quad_grnd_dust_spwnr"], self.origin );
}

begin_quad_introduction( quad_round_name )
{
    if ( flag( "dog_round" ) )
        flag_clear( "dog_round" );

    if ( level.next_dog_round == level.round_number + 1 )
        level.next_dog_round++;

    level.zombie_total = 0;
    level.quad_round_name = quad_round_name;
}

theater_quad_round()
{
    level.zombie_health = level.zombie_vars["zombie_health_start"];
    old_round = level.round_number;
    level.zombie_total = 0;
    level.zombie_health = 100 * old_round;
    kill_all_zombies();
    level.round_number = old_round;
}

spawn_second_wave_quads( second_wave_targetname )
{
    second_wave_spawners = [];
    second_wave_spawners = getentarray( second_wave_targetname, "targetname" );

    if ( second_wave_spawners.size < 1 )
    {
/#
        assertmsg( "No second wave quad spawners in spawner array." );
#/
        return;
    }

    for ( i = 0; i < second_wave_spawners.size; i++ )
    {
        ai = spawn_zombie( second_wave_spawners[i] );

        if ( isdefined( ai ) )
        {
            ai thread maps\mp\zombies\_zm::round_spawn_failsafe();
            ai thread quad_traverse_death_fx();
        }

        wait( randomint( 10, 45 ) );
    }

    wait_network_frame();
}

spawn_a_quad_zombie( spawn_array )
{
    spawn_point = spawn_array[randomint( spawn_array.size )];
    ai = spawn_zombie( spawn_point );

    if ( isdefined( ai ) )
    {
        ai thread maps\mp\zombies\_zm::round_spawn_failsafe();
        ai thread quad_traverse_death_fx();
    }

    wait( level.zombie_vars["zombie_spawn_delay"] );
    wait_network_frame();
}

kill_all_zombies()
{
    zombies = getaispeciesarray( "axis", "all" );

    if ( isdefined( zombies ) )
    {
        for ( i = 0; i < zombies.size; i++ )
        {
            if ( !isdefined( zombies[i] ) )
                continue;

            zombies[i] dodamage( zombies[i].health + 666, zombies[i].origin );
            wait_network_frame();
        }
    }
}

prevent_round_ending()
{
    level endon( "quad_round_can_end" );

    while ( true )
    {
        if ( level.zombie_total < 1 )
            level.zombie_total = 1;

        wait 0.5;
    }
}

intro_quad_spawn()
{
    timer = gettime();
    spawned = 0;
    previous_spawn_delay = level.zombie_vars["zombie_spawn_delay"];
    thread prevent_round_ending();
    initial_spawners = [];

    switch ( level.quad_round_name )
    {
        case "initial_round":
            initial_spawners = getentarray( "initial_first_round_quad_spawner", "targetname" );
            break;
        case "theater_round":
            initial_spawners = getentarray( "initial_theater_round_quad_spawner", "targetname" );
            break;
        default:
/#
            assertmsg( "No round specified for introducing quad round." );
#/
            return;
    }

    if ( initial_spawners.size < 1 )
    {
/#
        assertmsg( "No initial quad spawners in spawner array." );
#/
        return;
    }

    while ( true )
    {
        if ( isdefined( level.delay_spawners ) )
            manage_zombie_spawn_delay( timer );

        level.delay_spawners = 1;
        spawn_a_quad_zombie( initial_spawners );
        wait 0.2;
        spawned++;

        if ( spawned > level.quads_per_round )
            break;
    }

    spawned = 0;
    second_spawners = [];

    switch ( level.quad_round_name )
    {
        case "initial_round":
            second_spawners = getentarray( "initial_first_round_quad_spawner_second_wave", "targetname" );
            break;
        case "theater_round":
            second_spawners = getentarray( "theater_round_quad_spawner_second_wave", "targetname" );
            break;
        default:
/#
            assertmsg( "No round specified for second quad wave." );
#/
            return;
    }

    if ( second_spawners.size < 1 )
    {
/#
        assertmsg( "No second quad spawners in spawner array." );
#/
        return;
    }

    while ( true )
    {
        manage_zombie_spawn_delay( timer );
        spawn_a_quad_zombie( second_spawners );
        wait 0.2;
        spawned++;

        if ( spawned > level.quads_per_round * 2 )
            break;
    }

    level.zombie_vars["zombie_spawn_delay"] = previous_spawn_delay;
    level.zombie_health = level.zombie_vars["zombie_health_start"];
    level.zombie_total = 0;
    level.round_spawn_func = maps\mp\zombies\_zm::round_spawning;
    level thread [[ level.round_spawn_func ]]();
    wait 2;
    level notify( "quad_round_can_end" );
    level.delay_spawners = undefined;
}

manage_zombie_spawn_delay( start_timer )
{
    if ( gettime() - start_timer < 15000 )
        level.zombie_vars["zombie_spawn_delay"] = randomint( 30, 45 );
    else if ( gettime() - start_timer < 25000 )
        level.zombie_vars["zombie_spawn_delay"] = randomint( 15, 30 );
    else if ( gettime() - start_timer < 35000 )
        level.zombie_vars["zombie_spawn_delay"] = randomint( 10, 15 );
    else if ( gettime() - start_timer < 50000 )
        level.zombie_vars["zombie_spawn_delay"] = randomint( 5, 10 );
}

quad_lobby_roof_break()
{
    zone = level.zones["foyer_zone"];

    while ( true )
    {
        if ( zone.is_occupied )
        {
            flag_set( "lobby_occupied" );
            break;
        }

        wait_network_frame();
    }

    quad_stage_roof_break_single( 5 );
    wait 0.4;
    quad_stage_roof_break_single( 6 );
    wait 2;
    quad_stage_roof_break_single( 7 );
    wait 1;
    quad_stage_roof_break_single( 8 );
    maps\mp\zombies\_zm_zonemgr::reinit_zone_spawners();
}

quad_dining_roof_break()
{
    trigger = getent( "dining_first_floor", "targetname" );
    trigger waittill( "trigger" );
    flag_set( "dining_occupied" );
    quad_stage_roof_break_single( 9 );
    wait 1;
    quad_stage_roof_break_single( 10 );
    maps\mp\zombies\_zm_zonemgr::reinit_zone_spawners();
}

quad_stage_roof_break()
{
    level thread play_quad_start_vo();
    quad_stage_roof_break_single( 1 );
    wait 2;
    quad_stage_roof_break_single( 3 );
    wait 0.33;
    quad_stage_roof_break_single( 2 );
    wait 1;
    quad_stage_roof_break_single( 0 );
    wait 0.45;
    quad_stage_roof_break_single( 4 );
    wait 0.33;
    quad_stage_roof_break_single( 15 );
    wait 0.4;
    quad_stage_roof_break_single( 11 );
    wait 0.45;
    quad_stage_roof_break_single( 12 );
    wait 0.3;
    quad_stage_roof_break_single( 13 );
    wait 0.35;
    quad_stage_roof_break_single( 14 );
    maps\mp\zombies\_zm_zonemgr::reinit_zone_spawners();
}

quad_stage_roof_break_single( index )
{
    trigger = getent( "quad_roof_crumble_fx_origin_" + index, "target" );
    trigger thread quad_roof_crumble_fx_play();
}

play_quad_start_vo()
{
    wait 3;
    players = getplayers();
    player = players[randomintrange( 0, players.size )];
    player maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "quad_spawn" );
}
