// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include common_scripts\utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_mgturret;

init()
{
    level.auto_turret_array = getentarray( "auto_turret_trigger", "script_noteworthy" );

    if ( !isdefined( level.auto_turret_array ) )
        return;

    level.curr_auto_turrets_active = 0;

    if ( !isdefined( level.max_auto_turrets_active ) )
        level.max_auto_turrets_active = 2;

    if ( !isdefined( level.auto_turret_cost ) )
        level.auto_turret_cost = 1500;

    if ( !isdefined( level.auto_turret_timeout ) )
        level.auto_turret_timeout = 30;

    for ( i = 0; i < level.auto_turret_array.size; i++ )
    {
        level.auto_turret_array[i] setcursorhint( "HINT_NOICON" );
        level.auto_turret_array[i] sethintstring( &"ZOMBIE_NEED_POWER" );
        level.auto_turret_array[i] usetriggerrequirelookat();
        level.auto_turret_array[i].curr_time = -1;
        level.auto_turret_array[i].turret_active = 0;
        level.auto_turret_array[i] thread auto_turret_think();
    }
}

auto_turret_think()
{
    if ( !isdefined( self.target ) )
        return;

    turret_array = getentarray( self.target, "targetname" );

    if ( isdefined( self.target ) )
    {
        for ( i = 0; i < turret_array.size; i++ )
        {
            if ( turret_array[i].model == "zombie_zapper_handle" )
            {
                self.handle = turret_array[i];
                continue;
            }

            if ( turret_array[i].classname == "misc_turret" )
                self.turret = turret_array[i];
        }
    }

    self.turret setdefaultdroppitch( -35 );

    if ( !isdefined( self.turret ) )
        return;

    self.turret setconvergencetime( 0.3 );
    self.turret setturretteam( "allies" );
    self.turret maketurretunusable();
    self.audio_origin = self.origin;
    flag_wait( "power_on" );

    for (;;)
    {
        cost = level.auto_turret_cost;
        self sethintstring( &"ZOMBIE_AUTO_TURRET", cost );
        self waittill( "trigger", player );
        index = maps\mp\zombies\_zm_weapons::get_player_index( player );

        if ( player maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
            continue;

        if ( player in_revive_trigger() )
            continue;

        if ( player.score < cost )
        {
            self playsound( "deny" );
            player thread play_no_money_turret_dialog();
            continue;
        }

        player maps\mp\zombies\_zm_score::minus_to_player_score( cost );
        self thread auto_turret_activate();
        self playsound( "zmb_turret_startup" );
        self disable_trigger();
        self waittill( "turret_deactivated" );
        playsoundatposition( "zmb_turret_down", self.audio_origin );
        self enable_trigger();
    }
}

activate_move_handle()
{
    if ( isdefined( self.handle ) )
    {
        self.handle rotatepitch( 160, 0.5 );
        self.handle playsound( "amb_sparks_l_b" );
        self.handle waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "turret_deactivated" );
        self.handle rotatepitch( -160, 0.5 );
    }
}

play_no_money_turret_dialog()
{

}

auto_turret_activate()
{
    self endon( "turret_deactivated" );
    self thread activate_move_handle();
    self waittill( "switch_activated" );

    if ( level.max_auto_turrets_active <= 0 )
        return;

    while ( level.curr_auto_turrets_active >= level.max_auto_turrets_active )
    {
        worst_turret = undefined;
        worst_turret_time = -1;

        for ( i = 0; i < level.auto_turret_array.size; i++ )
        {
            if ( level.auto_turret_array[i] == self )
                continue;

            if ( !level.auto_turret_array[i].turret_active )
                continue;

            if ( worst_turret_time < 0 || level.auto_turret_array[i].curr_time < worst_turret_time )
            {
                worst_turret = level.auto_turret_array[i];
                worst_turret_time = level.auto_turret_array[i].curr_time;
            }
        }

        if ( isdefined( worst_turret ) )
            worst_turret auto_turret_deactivate();
        else
            assert( 0, "Couldn't free an auto turret to activate another, this should never be the case" );
    }

    self.turret setturrettype( "sentry" );
    self.turret setmode( "auto_nonai" );
    self.turret thread maps\mp\zombies\_zm_mgturret::burst_fire_unmanned();
    self.turret_active = 1;
    self.turret_fx = spawn( "script_model", self.turret.origin );
    self.turret_fx setmodel( "tag_origin" );
    self.turret_fx.angles = self.turret.angles;
    playfxontag( level._effect["auto_turret_light"], self.turret_fx, "tag_origin" );
    self.curr_time = level.auto_turret_timeout;
    self thread auto_turret_update_timeout();
    wait( level.auto_turret_timeout );
    self auto_turret_deactivate();
}

auto_turret_deactivate()
{
    self.turret_active = 0;
    self.curr_time = -1;
    self.turret setmode( "auto_ai" );
    self.turret notify( "stop_burst_fire_unmanned" );
    self.turret_fx delete();
    self notify( "turret_deactivated" );
}

auto_turret_update_timeout()
{
    self endon( "turret_deactivated" );

    while ( self.curr_time > 0 )
    {
        wait 1;
        self.curr_time--;
    }
}
