// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zm_theater;
#include maps\mp\zm_theater_amb;

initmoviescreen()
{
    level thread setupcurtains();
    level thread movie_reels_init();
}

set_up_images()
{
    level.images = [];
    level.images = getentarray( "screen_image", "targetname" );
    level.images = mergesort( level.images );

    for ( x = 0; x < level.images.size; x++ )
        level.images[x] hide();
}

mergesort( current_list )
{
    if ( current_list.size <= 1 )
        return current_list;

    left = [];
    right = [];
    middle = current_list.size / 2;

    for ( x = 0; x < middle; x++ )
        left = add_to_array( left, current_list[x] );

    while ( x < current_list.size )
    {
        right = add_to_array( right, current_list[x] );
        x++;
    }

    left = mergesort( left );
    right = mergesort( right );

    if ( left[left.size - 1].script_int > right[right.size - 1].script_int )
        result = merge( left, right );
    else
        result = append( left, right );

    return result;
}

merge( left, right )
{
    result = [];

    while ( left.size > 0 && right.size > 0 )
    {
        if ( left[0] <= right[0] )
        {
            result = add_to_array( result, left[0] );
            arrayremoveindex( left, 0 );
        }
        else
        {
            result = add_to_array( result, right[0] );
            arrayremoveindex( right, 0 );
        }
    }

    while ( left.size > 0 )
        result = append( result, left );

    while ( right.size > 0 )
        result = append( result, right );

    return result;
}

append( left, right )
{
    for ( x = 0; x < right.size; x++ )
        left = add_to_array( left, right[x] );

    return left;
}

setupcurtains()
{
    flag_wait( "power_on" );
    curtains_clip = getent( "theater_curtains_clip", "targetname" );
    curtains_clip notsolid();
    curtains_clip connectpaths();
    level maps\mp\zm_theater::theater_open_curtains();
    flag_set( "curtains_done" );
    level thread lower_movie_screen();
}

movecurtains( curtent )
{
    curtain = getent( curtent, "targetname" );
    curtorg = curtain.origin;
    time = 2;
    curtain thread monitorcurtain( curtorg );
    curtain connectpaths();
    curtain moveto( curtain.origin + curtain.script_vector, time, time * 0.25, time * 0.25 );
    curtain playsound( "curtain_open" );
}

monitorcurtain( curtorg )
{
    clip = getent( self.target, "targetname" );

    while ( isdefined( clip ) )
    {
        if ( abs( curtorg[0] - self.origin[0] ) >= 38 )
        {
            clip connectpaths();
            clip notsolid();

            if ( isdefined( clip.target ) )
                clip = getent( clip.target, "targetname" );
            else
                clip = undefined;
        }

        wait 0.1;
    }
}

open_left_curtain()
{
    flag_wait( "power_on" );
    curtain = getent( "left_curtain", "targetname" );

    if ( isdefined( curtain ) )
    {
        wait 2;
        curtain_clip = getentarray( "left_curtain_clip", "targetname" );

        for ( i = 0; i < curtain_clip.size; i++ )
        {
            curtain_clip[i] connectpaths();
            curtain_clip[i] notsolid();
        }

        curtain connectpaths();
        curtain movex( -300, 2 );
    }
}

open_right_curtain()
{
    flag_wait( "power_on" );
    curtain = getent( "right_curtain", "targetname" );

    if ( isdefined( curtain ) )
    {
        wait 2;
        curtain_clip = getentarray( "right_curtain_clip", "targetname" );

        for ( i = 0; i < curtain_clip.size; i++ )
        {
            curtain_clip[i] connectpaths();
            curtain_clip[i] notsolid();
        }

        curtain connectpaths();
        curtain movex( 300, 2 );
    }
}

lower_movie_screen()
{
    screen = getent( "movie_screen", "targetname" );

    if ( isdefined( screen ) )
    {
        screen movez( -466, 6 );
        screen playsound( "evt_screen_lower" );
    }

    screen waittill( "movedone" );
    wait 2;
    clientnotify( "sip" );
}

play_images()
{
    for ( x = 0; 1; x++ )
    {
        if ( x > level.images.size - 1 )
            x = 0;

        level.images[x] show();
        wait 0.1;
        level.images[x] hide();
    }
}

movie_reels_init()
{
    clean_bedroom_reels = getentarray( "trigger_movie_reel_clean_bedroom", "targetname" );
    bear_bedroom_reels = getentarray( "trigger_movie_reel_bear_bedroom", "targetname" );
    interrogation_reels = getentarray( "trigger_movie_reel_interrogation", "targetname" );
    pentagon_reels = getentarray( "trigger_movie_reel_pentagon", "targetname" );
    level.reel_trigger_array = [];
    level.reel_trigger_array = add_to_array( level.reel_trigger_array, clean_bedroom_reels, 0 );
    level.reel_trigger_array = add_to_array( level.reel_trigger_array, bear_bedroom_reels, 0 );
    level.reel_trigger_array = add_to_array( level.reel_trigger_array, interrogation_reels, 0 );
    level.reel_trigger_array = add_to_array( level.reel_trigger_array, pentagon_reels, 0 );
    level.reel_trigger_array = array_randomize( level.reel_trigger_array );
    reel_0 = movie_reels_random( level.reel_trigger_array[0], "ps1" );
    reel_1 = movie_reels_random( level.reel_trigger_array[1], "ps2" );
    reel_2 = movie_reels_random( level.reel_trigger_array[2], "ps3" );
    temp_reels_0 = arraycombine( clean_bedroom_reels, bear_bedroom_reels, 0, 0 );
    temp_reels_1 = arraycombine( interrogation_reels, pentagon_reels, 0, 0 );
    all_reels = arraycombine( temp_reels_0, temp_reels_1, 0, 0 );
    array_thread( all_reels, ::movie_reels );
    level thread movie_projector_reel_change();
}

movie_reels_random( array_reel_triggers, str_reel )
{
    if ( !isdefined( array_reel_triggers ) )
        return;
    else if ( array_reel_triggers.size <= 0 )
        return;
    else if ( !isdefined( str_reel ) )
        return;

    random_reels = array_randomize( array_reel_triggers );
    random_reels[0].script_string = str_reel;
    random_reels[0].reel_active = 1;
    return random_reels[0];
}

movie_reels()
{
    if ( !isdefined( self.target ) )
    {
        assert( isdefined( self.target ), "one of the reel triggers missing target" );
        return;
    }

    self.reel_model = getent( self.target, "targetname" );

    if ( !isdefined( self.reel_active ) )
        self.reel_active = 0;

    if ( isdefined( self.reel_active ) && self.reel_active == 0 )
    {
        self.reel_model hide();
        self setcursorhint( "HINT_NOICON" );
        self sethintstring( "" );
        self trigger_off();
        return;
    }
    else if ( isdefined( self.reel_active ) && self.reel_active == 1 )
    {
        self.reel_model setmodel( "zombie_theater_reelcase_logo" );
        self setcursorhint( "HINT_NOICON" );
    }

    flag_wait( "power_on" );
    self waittill( "trigger", who );
    who playsound( "zmb_reel_pickup" );
    self.reel_model hide();
    self trigger_off();
    who.reel = self.script_string;
    who thread theater_movie_reel_hud();
}

movie_projector_reel_change()
{
    screen_struct = getstruct( "struct_theater_screen", "targetname" );
    projector_trigger = getent( "trigger_change_projector_reels", "targetname" );
    projector_trigger setcursorhint( "HINT_NOICON" );

    if ( !isdefined( screen_struct.script_string ) )
        screen_struct.script_string = "ps0";

    while ( true )
    {
        projector_trigger waittill( "trigger", who );

        if ( isdefined( who.reel ) && isstring( who.reel ) )
        {
            clientnotify( who.reel );
            who notify( "reel_set" );
            who thread theater_remove_reel_hud();
            who thread maps\mp\zm_theater_amb::play_radio_egg( 2 );
            who playsound( "zmb_reel_place" );
            who.reel = undefined;
            wait 3;
        }
        else
            wait 0.1;

        wait 0.1;
    }
}

theater_movie_reel_hud()
{
    self.reelhud = create_simple_hud( self );
    self.reelhud.foreground = 1;
    self.reelhud.sort = 2;
    self.reelhud.hidewheninmenu = 0;
    self.reelhud.alignx = "center";
    self.reelhud.aligny = "bottom";
    self.reelhud.horzalign = "user_right";
    self.reelhud.vertalign = "user_bottom";
    self.reelhud.x = -200;
    self.reelhud.y = 0;
    self.reelhud.alpha = 1;
    self.reelhud setshader( "zom_icon_theater_reel", 32, 32 );
    self thread theater_remove_reel_on_death();
}

theater_remove_reel_hud()
{
    if ( isdefined( self.reelhud ) )
        self.reelhud destroy();
}

theater_remove_reel_on_death()
{
    self endon( "reel_set" );
    self waittill_either( "death", "_zombie_game_over" );
    self thread theater_remove_reel_hud();
}
