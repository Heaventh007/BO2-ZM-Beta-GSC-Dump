// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_music;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\zombies\_zm;
#include clientscripts\mp\zm_theater_teleporter;
#include clientscripts\mp\zm_theater_fx;
#include clientscripts\mp\zm_theater_amb;
#include clientscripts\mp\zombies\_zm_deathcard;
#include character\clientscripts\c_zom_quad;

main()
{
    if ( !is_true( getdvar( #"createfx" ) != "" ) )
        include_weapons();

    level.zombiemode_using_doubletap_perk = 1;
    level.zombiemode_using_juggernaut_perk = 1;
    level.zombiemode_using_revive_perk = 1;
    level.zombiemode_using_additionalprimaryweapon_perk = 1;
    level.zombiemode_using_sleightofhand_perk = 1;
    level.zombiemode_using_pack_a_punch = 1;
    clientscripts\mp\zombies\_zm::init();
    clientscripts\mp\zm_theater_teleporter::main();
    clientscripts\mp\zm_theater_fx::main();
    clientscripts\mp\zm_theater_amb::main();
    clientscripts\mp\zombies\_zm_deathcard::init();
    init_theater_box_indicator();
    thread waitforclient( 0 );
    level._power_on = 0;
    level thread theatre_zpo_listener();
    level thread eeroom_visionset_init();
    level thread theater_light_model_swap_init();
    register_zombie_types();
    curtain_anim_init();
    level thread watch_for_power();
}

watch_for_power()
{
    if ( is_true( level.createfx_enabled ) )
        return;

    for ( looped_once = 0; 1; looped_once = 1 )
    {
        if ( !level getclientfield( "zombie_power_on" ) )
        {
            level.power_on = 0;

            if ( looped_once )
                level notify( "power_controlled_light" );

            level waittill_any( "power_on", "pwr", "ZPO" );
        }

        level notify( "power_controlled_light" );
        level waittill_any( "pwo", "ZPOff" );
    }
}

register_zombie_types()
{
    character\clientscripts\c_zom_quad::register_gibs();
}

include_weapons()
{
    include_weapon( "minigun_zm", 0 );
    include_weapon( "frag_grenade_zm", 0 );
    include_weapon( "claymore_zm", 0 );
    include_weapon( "m1911_zm", 0 );
    include_weapon( "m1911_upgraded_zm", 0 );
    include_weapon( "python_zm" );
    include_weapon( "python_upgraded_zm", 0 );
    include_weapon( "fiveseven_zm" );
    include_weapon( "fiveseven_upgraded_zm", 0 );
    include_weapon( "m14_zm", 0 );
    include_weapon( "m14_upgraded_zm", 0 );
    include_weapon( "m16_zm", 0 );
    include_weapon( "m16_gl_upgraded_zm", 0 );
    include_weapon( "xm8_zm" );
    include_weapon( "xm8_upgraded_zm", 0 );
    include_weapon( "type95_zm" );
    include_weapon( "type95_upgraded_zm", 0 );
    include_weapon( "ak74u_zm", 0 );
    include_weapon( "ak74u_upgraded_zm", 0 );
    include_weapon( "mp5k_zm", 0 );
    include_weapon( "mp5k_upgraded_zm", 0 );
    include_weapon( "mp40_zm", 0 );
    include_weapon( "mp40_upgraded_zm", 0 );
    include_weapon( "beretta93r_zm", 0 );
    include_weapon( "beretta93r_upgraded_zm", 0 );
    include_weapon( "pm63_zm", 0 );
    include_weapon( "pm63_upgraded_zm", 0 );
    include_weapon( "kard_zm" );
    include_weapon( "kard_upgraded_zm", 0 );
    include_weapon( "fivesevendw_zm" );
    include_weapon( "fivesevendw_upgraded_zm", 0 );
    include_weapon( "870mcs_zm", 0 );
    include_weapon( "870mcs_upgraded_zm", 0 );
    include_weapon( "rottweil72_zm", 0 );
    include_weapon( "rottweil72_upgraded_zm", 0 );
    include_weapon( "judge_zm" );
    include_weapon( "judge_upgraded_zm", 0 );
    include_weapon( "tar21_zm" );
    include_weapon( "tar21_upgraded_zm", 0 );
    include_weapon( "galil_zm" );
    include_weapon( "galil_upgraded_zm", 0 );
    include_weapon( "hk416_zm" );
    include_weapon( "hk416_upgraded_zm", 0 );
    include_weapon( "sa58_zm" );
    include_weapon( "sa58_upgraded_zm", 0 );
    include_weapon( "barretm82_zm" );
    include_weapon( "barretm82_upgraded_zm", 0 );
    include_weapon( "dsr50_zm" );
    include_weapon( "dsr50_upgraded_zm", 0 );
    include_weapon( "rpd_zm" );
    include_weapon( "rpd_upgraded_zm", 0 );
    include_weapon( "hamr_zm" );
    include_weapon( "hamr_upgraded_zm", 0 );
    include_weapon( "usrpg_zm" );
    include_weapon( "usrpg_upgraded_zm", 0 );
    include_weapon( "m32_zm" );
    include_weapon( "m32_upgraded_zm", 0 );
    include_weapon( "zombie_cymbal_monkey" );
    include_weapon( "ray_gun_zm" );
    include_weapon( "ray_gun_upgraded_zm", 0 );
    include_weapon( "thundergun_zm", 1 );
    include_weapon( "thundergun_upgraded_zm", 0 );
}

init_theater_box_indicator()
{
    level._custom_box_monitor = ::theater_box_monitor;
    level._box_locations = array( "start_chest_loc", "foyer_chest_loc", "crematorium_chest_loc", "alleyway_chest_loc", "control_chest_loc", "stage_chest_loc", "dressing_chest_loc", "dining_chest_loc", "theater_chest_loc" );
    onplayerconnect_callback( ::init_board_lights );
}

init_board_lights( clientnum )
{
    structs = getstructarray( "magic_box_loc_light", "targetname" );

    for ( j = 0; j < structs.size; j++ )
    {
        s = structs[j];

        if ( !isdefined( s.lights ) )
            s.lights = [];

        if ( isdefined( s.lights[clientnum] ) )
        {
            if ( isdefined( s.lights[clientnum].fx ) )
            {
                s.lights[clientnum].fx delete();
                s.lights[clientnum].fx = undefined;
            }

            s.lights[clientnum] delete();
            s.lights[clientnum] = undefined;
        }

        s.lights[clientnum] = spawn( clientnum, s.origin, "script_model" );
        s.lights[clientnum].angles = s.angles;
        s.lights[clientnum] setmodel( "zombie_zapper_cagelight" );
    }
}

get_lights( clientnum, name )
{
    structs = getstructarray( name, "script_noteworthy" );
    lights = [];

    for ( i = 0; i < structs.size; i++ )
        lights[lights.size] = structs[i].lights[clientnum];

    return lights;
}

turn_off_all_box_lights( clientnum )
{
    level notify( "kill_box_light_threads_" + clientnum );

    for ( i = 0; i < level._box_locations.size; i++ )
        turn_off_light( clientnum, i );
}

flash_lights( clientnum, period )
{
    level notify( "kill_box_light_threads_" + clientnum );
    level endon( "kill_box_light_threads_" + clientnum );

    while ( true )
    {
        wait( period );

        for ( i = 0; i < level._box_locations.size; i++ )
            turn_light_green( clientnum, i );

        wait( period );

        for ( i = 0; i < level._box_locations.size; i++ )
            turn_off_light( clientnum, i, 1 );
    }
}

turn_light_red( clientnum, light_num, play_fx )
{
    if ( light_num == level._box_indicator_no_lights )
        return;

    name = level._box_locations[light_num];
    lights = get_lights( clientnum, name );

    for ( i = 0; i < lights.size; i++ )
    {
        if ( isdefined( lights[i].fx ) )
        {
            lights[i].fx delete();
            lights[i].fx = undefined;
        }

        if ( isdefined( play_fx ) && play_fx )
        {
            lights[i] setmodel( "zombie_zapper_cagelight_red" );
            lights[i].fx = spawn( clientnum, ( lights[i].origin[0], lights[i].origin[1], lights[i].origin[2] - 10 ), "script_model" );
            lights[i].fx setmodel( "tag_origin" );
            lights[i].fx.angles = lights[i].angles;
            playfxontag( clientnum, level._effect["boxlight_light_ready"], lights[i].fx, "tag_origin" );
            continue;
        }

        lights[i] setmodel( "zombie_zapper_cagelight_red" );
    }
}

turn_light_green( clientnum, light_num, play_fx )
{
    if ( light_num == level._box_indicator_no_lights )
        return;

    name = level._box_locations[light_num];
    lights = get_lights( clientnum, name );

    for ( i = 0; i < lights.size; i++ )
    {
        if ( isdefined( lights[i].fx ) )
        {
            lights[i].fx delete();
            lights[i].fx = undefined;
        }

        if ( isdefined( play_fx ) && play_fx )
        {
            lights[i] setmodel( "zombie_zapper_cagelight_green" );
            lights[i].fx = spawn( clientnum, ( lights[i].origin[0], lights[i].origin[1], lights[i].origin[2] - 10 ), "script_model" );
            lights[i].fx setmodel( "tag_origin" );
            lights[i].fx.angles = lights[i].angles;
            playfxontag( clientnum, level._effect["boxlight_light_ready"], lights[i].fx, "tag_origin" );
            continue;
        }

        lights[i] setmodel( "zombie_zapper_cagelight_green" );
    }
}

turn_off_light( clientnum, light_num, dont_kill_threads )
{
    if ( !isdefined( dont_kill_threads ) )
        level notify( "kill_box_light_threads_" + clientnum );

    if ( light_num == level._box_indicator_no_lights )
        return;

    name = level._box_locations[light_num];
    lights = get_lights( clientnum, name );

    for ( i = 0; i < lights.size; i++ )
    {
        if ( isdefined( lights[i].fx ) )
        {
            lights[i].fx delete();
            lights[i].fx = undefined;
        }

        lights[i] setmodel( "zombie_zapper_cagelight" );
    }
}

theater_box_monitor( clientnum, state, oldstate )
{
    s = int( state );

    if ( s == level._box_indicator_no_lights )
        turn_off_all_box_lights( clientnum );
    else if ( s == level._box_indicator_flash_lights_moving )
        level thread flash_lights( clientnum, 0.25 );
    else if ( s == level._box_indicator_flash_lights_fire_sale )
        level thread flash_lights( clientnum, 0.3 );
    else
    {
        if ( s < 0 || s > level._box_locations.size )
            return;

        level notify( "kill_box_light_threads_" + clientnum );
        turn_off_all_box_lights( clientnum );
        level._box_indicator = s;

        if ( level._power_on )
            turn_light_green( clientnum, level._box_indicator, 1 );
    }
}

theatre_zpo_listener()
{
    while ( true )
    {
        level waittill( "ZPO" );
        level._power_on = 1;

        if ( level._box_indicator != level._box_indicator_no_lights )
        {
            for ( i = 0; i < getlocalplayers().size; i++ )
                theater_box_monitor( i, level._box_indicator );
        }

        level notify( "threeprimaries_on" );
        level notify( "pl1" );
    }
}

eeroom_visionset_init()
{
    eeroom_visionset_triggers = getentarray( 0, "trigger_eeroom_visionset", "targetname" );

    if ( !isdefined( eeroom_visionset_triggers ) )
        return;

    array_thread( eeroom_visionset_triggers, ::theater_player_in_eeroom );
}

theater_player_in_eeroom()
{
    while ( true )
    {
        self waittill( "trigger", ent_player );

        if ( ent_player islocalplayer() )
            self thread trigger_thread( ent_player, ::eeroom_visionset_on, ::eeroom_visionset_off );
    }
}

eeroom_visionset_on( ent_player )
{
    if ( !isdefined( self.script_string ) )
        return;

    wait 1.0;

    switch ( self.script_string )
    {
        case "asylum_room":
            visionsetnaked( ent_player getlocalclientnumber(), "zombie_theater_eroom_asylum", 0 );
            break;
        case "pentagon_room":
            visionsetnaked( ent_player getlocalclientnumber(), "zombie_theater_erooms_pentagon", 0 );
            break;
        case "girls_new_room":
            visionsetnaked( ent_player getlocalclientnumber(), "zombie_theater_eroom_girlnew", 0 );
            break;
        case "girls_old_room":
            visionsetnaked( ent_player getlocalclientnumber(), "zombie_theater_eroom_girlold", 0 );
            break;
        default:
            visionsetnaked( ent_player getlocalclientnumber(), "zombie_theater", 0 );
            break;
    }
}

eeroom_visionset_off( ent_player )
{
    visionsetnaked( ent_player getlocalclientnumber(), "zombie_theater", 0 );
}

theater_light_model_swap_init()
{
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        theater_light_models = getentarray( i, "model_lights_on", "targetname" );

        if ( isdefined( theater_light_models ) && theater_light_models.size > 0 )
            array_thread( theater_light_models, ::theater_light_model_swap );
    }
}

theater_light_model_swap()
{
    level waittill( "ZPO" );

    if ( self.model == "lights_hang_single" )
        self setmodel( "lights_hang_single_on_nonflkr" );
    else if ( self.model == "zombie_zapper_cagelight" )
        self setmodel( "zombie_zapper_cagelight_on" );
}

curtain_anim_init()
{
    registerclientfield( "world", "zm_theater_curtain_open", 7000, 1, "int", ::theater_open_curtains, 0 );
}

#using_animtree("zombie_theater");

theater_open_curtains( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    scriptmodelsuseanimtree( #animtree );
    theater_curtains = getent( localclientnum, "theater_curtains", "targetname" );
    theater_curtains.animname = "curtain";
    theater_curtains useanimtree( #animtree );
    theater_curtains setanim( %o_zombie_theatre_curtain, 1.0, 0.2, 2.0 );
}
