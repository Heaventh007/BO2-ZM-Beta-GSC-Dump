// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_music;
#include clientscripts\mp\zm_theater_teleporter;

main()
{
    level thread setup_teleport_aftereffects();
    level thread wait_for_black_box();
    level thread wait_for_teleport_aftereffect();
    level thread setup_teleporter_screen();
    level thread pack_clock_init();
}

setup_teleporter_screen()
{
    waitforclient( 0 );
    level.extracamactive = 0;
    level thread start_extra_cam();
    level thread stop_extra_cam();
    wait 0.5;
    level notify( "camera_stop" );
}

setup_teleport_aftereffects()
{
    waitforclient( 0 );
    level.teleport_ae_funcs = [];

    if ( getlocalplayers().size == 1 )
        level.teleport_ae_funcs[level.teleport_ae_funcs.size] = clientscripts\mp\zm_theater_teleporter::teleport_aftereffect_fov;

    level.teleport_ae_funcs[level.teleport_ae_funcs.size] = clientscripts\mp\zm_theater_teleporter::teleport_aftereffect_shellshock;
    level.teleport_ae_funcs[level.teleport_ae_funcs.size] = clientscripts\mp\zm_theater_teleporter::teleport_aftereffect_shellshock_electric;
    level.teleport_ae_funcs[level.teleport_ae_funcs.size] = clientscripts\mp\zm_theater_teleporter::teleport_aftereffect_bw_vision;
    level.teleport_ae_funcs[level.teleport_ae_funcs.size] = clientscripts\mp\zm_theater_teleporter::teleport_aftereffect_red_vision;
    level.teleport_ae_funcs[level.teleport_ae_funcs.size] = clientscripts\mp\zm_theater_teleporter::teleport_aftereffect_flashy_vision;
    level.teleport_ae_funcs[level.teleport_ae_funcs.size] = clientscripts\mp\zm_theater_teleporter::teleport_aftereffect_flare_vision;
}

wait_for_black_box()
{
    secondclientnum = -1;

    while ( true )
    {
        level waittill( "black_box_start", localclientnum );
        assert( isdefined( localclientnum ) );
        savedvis = getvisionsetnaked( localclientnum );
        visionsetnaked( localclientnum, "default", 0 );

        while ( secondclientnum != localclientnum )
            level waittill( "black_box_end", secondclientnum );

        visionsetnaked( localclientnum, savedvis, 0 );
    }
}

wait_for_teleport_aftereffect()
{
    while ( true )
    {
        level waittill( "teleport_ae_start", localclientnum );

        if ( getdvar( #"_id_3608B991" ) == "-1" )
            self thread [[ level.teleport_ae_funcs[randomint( level.teleport_ae_funcs.size )] ]]( localclientnum );
        else
            self thread [[ level.teleport_ae_funcs[int( getdvar( #"_id_3608B991" ) )] ]]( localclientnum );
    }
}

teleport_aftereffect_shellshock( localclientnum )
{
    wait 0.05;
}

teleport_aftereffect_shellshock_electric( localclientnum )
{
    wait 0.05;
}

teleport_aftereffect_fov( localclientnum )
{
/#
    println( "***FOV Aftereffect***\\n" );
#/
    start_fov = 30;
    end_fov = 65;
    duration = 0.5;

    for ( i = 0; i < duration; i = i + 0.017 )
    {
        fov = start_fov + ( end_fov - start_fov ) * ( i / duration );
        wait 0.017;
    }
}

teleport_aftereffect_bw_vision( localclientnum )
{
/#
    println( "***B&W Aftereffect***\\n" );
#/
    savedvis = getvisionsetnaked( localclientnum );
    visionsetnaked( localclientnum, "cheat_bw_invert_contrast", 0.4 );
    wait 1.25;
    visionsetnaked( localclientnum, savedvis, 1 );
}

teleport_aftereffect_red_vision( localclientnum )
{
/#
    println( "***Red Aftereffect***\\n" );
#/
    savedvis = getvisionsetnaked( localclientnum );
    visionsetnaked( localclientnum, "zombie_turned", 0.4 );
    wait 1.25;
    visionsetnaked( localclientnum, savedvis, 1 );
}

teleport_aftereffect_flashy_vision( localclientnum )
{
/#
    println( "***Flashy Aftereffect***\\n" );
#/
    savedvis = getvisionsetnaked( localclientnum );
    visionsetnaked( localclientnum, "cheat_bw_invert_contrast", 0.1 );
    wait 0.4;
    visionsetnaked( localclientnum, "cheat_bw_contrast", 0.1 );
    wait 0.4;
    visionsetnaked( localclientnum, "cheat_invert_contrast", 0.1 );
    wait 0.4;
    visionsetnaked( localclientnum, "cheat_contrast", 0.1 );
    wait 0.4;
    visionsetnaked( localclientnum, savedvis, 5 );
}

teleport_aftereffect_flare_vision( localclientnum )
{
/#
    println( "***Flare Aftereffect***\\n" );
#/
    savedvis = getvisionsetnaked( localclientnum );
    visionsetnaked( localclientnum, "flare", 0.4 );
    wait 1.25;
    visionsetnaked( localclientnum, savedvis, 1 );
}

start_extra_cam()
{
    while ( true )
        level waittill( "camera_start", localclientnum );
}

stop_extra_cam()
{
    while ( true )
        level waittill( "camera_stop" );
}

pack_clock_init()
{
    level waittill( "pack_clock_start", clientnum );
    curr_time = getsystemtime();
    hours = curr_time[0];

    if ( hours > 12 )
        hours = hours - 12;

    if ( hours == 0 )
        hours = 12;

    minutes = curr_time[1];
    seconds = curr_time[2];
    hour_hand = getent( clientnum, "zom_clock_hour_hand", "targetname" );
    hour_values = [];
    hour_values["hand_time"] = hours;
    hour_values["rotate"] = 30;
    hour_values["rotate_bit"] = 0.00833333;
    hour_values["first_rotate"] = ( minutes * 60 + seconds ) * hour_values["rotate_bit"];
    minute_hand = getent( clientnum, "zom_clock_minute_hand", "targetname" );
    minute_values = [];
    minute_values["hand_time"] = minutes;
    minute_values["rotate"] = 6;
    minute_values["rotate_bit"] = 0.1;
    minute_values["first_rotate"] = seconds * minute_values["rotate_bit"];

    if ( isdefined( hour_hand ) )
        hour_hand thread pack_clock_run( hour_values );

    if ( isdefined( minute_hand ) )
        minute_hand thread pack_clock_run( minute_values );
}

pack_clock_run( time_values )
{
    self endon( "entityshutdown" );
    self rotatepitch( time_values["hand_time"] * time_values["rotate"] * -1, 0.05 );
    self waittill( "rotatedone" );

    if ( isdefined( time_values["first_rotate"] ) )
    {
        self rotatepitch( time_values["first_rotate"] * -1, 0.05 );
        self waittill( "rotatedone" );
    }

    prev_time = getsystemtime();

    while ( true )
    {
        curr_time = getsystemtime();

        if ( prev_time != curr_time )
        {
            self rotatepitch( time_values["rotate_bit"] * -1, 0.05 );
            prev_time = curr_time;
        }

        wait 1.0;
    }
}
