// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_ai_thief;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\zm_pentagon_amb;

teleporter_init()
{
    level.teleport_ae_funcs = [];
    setdvar( "pentagonAftereffectOverride", "-1" );
    thread teleport_pad_init();
    thread enable_zone_portals_init();
    thread open_portal_rooms();
    thread pack_hideaway_init();
    poi1 = getent( "pack_room_poi1", "targetname" );
    poi2 = getent( "pack_room_poi2", "targetname" );
    poi1 create_zombie_point_of_interest( undefined, 30, 0, 0 );
    poi1 thread create_zombie_point_of_interest_attractor_positions( 4, 45 );
    poi2 create_zombie_point_of_interest( undefined, 30, 0, 0 );
    poi2 thread create_zombie_point_of_interest_attractor_positions( 4, 45 );
}

teleport_pad_init()
{
    level.portal_trig = getentarray( "portal_trigs", "targetname" );

    for ( i = 0; i < level.portal_trig.size; i++ )
    {
        level.portal_trig[i].active = 1;
        level.portal_trig[i].portal_used = [];
        level.portal_trig[i] thread player_teleporting();
    }
}

pack_hideaway_init()
{
    hideaway = getent( "pack_hideaway", "targetname" );
    parts = getentarray( hideaway.target, "targetname" );
    level.punch_trigger = getent( "zombie_vending_upgrade", "targetname" );
    level.punch_machine = getent( level.punch_trigger.target, "targetname" );
    level.punch_sign = getent( level.punch_machine.target, "targetname" );
    level.punch_sign linkto( level.punch_machine );

    if ( isdefined( level.punch_trigger ) )
    {
        level.punch_trigger enablelinkto();
        level.punch_trigger linkto( hideaway );
    }

    if ( isdefined( level.punch_machine ) )
        level.punch_machine linkto( hideaway );

    pack_audio_trig = getent( "pack_audio_trig", "script_noteworthy" );
    pack_audio_trig enablelinkto();
    pack_audio_trig linkto( hideaway );

    if ( isdefined( parts ) )
    {
        for ( i = 0; i < parts.size; i++ )
            parts[i] linkto( hideaway );
    }

    while ( true )
    {
        flag_wait( "open_pack_hideaway" );
        hideaway notsolid();
        hideaway rotateyaw( 180, 2.5 );
        hideaway playsound( "evt_packapunch_revolve_start" );
        hideaway playloopsound( "evt_packapunch_revolve_loop" );
        hideaway waittill( "rotatedone" );
        level.punch_trigger setvisibletoall();
        level.punch_trigger trigger_on();
        hideaway stoploopsound( 1 );
        hideaway playsound( "evt_packapunch_revolve_end" );
        level.punch_sign unlink();
        wait 40;

        if ( flag( "pack_machine_in_use" ) )
        {
            while ( flag( "pack_machine_in_use" ) )
                wait 0.1;
        }

        level.punch_sign linkto( level.punch_machine );
        level.punch_trigger trigger_off();
        players = get_players();

        for ( i = 0; i < players.size; i++ )
            level.punch_trigger setinvisibletoplayer( players[i] );

        hideaway rotateyaw( 180, 2.5 );
        hideaway playsound( "evt_packapunch_revolve_start" );
        hideaway playloopsound( "evt_packapunch_revolve_loop" );
        flag_clear( "open_pack_hideaway" );
        wait_network_frame();
        hideaway waittill( "rotatedone" );
        hideaway stoploopsound( 1 );
        hideaway playsound( "evt_packapunch_revolve_end" );
    }
}

pack_door_init()
{
    trigger = getent( "pack_room_door", "targetname" );
    doors = getentarray( trigger.target, "targetname" );
    pack_door_slam = getent( "slam_pack_door", "targetname" );
    pack_door_open = 0;

    while ( true )
    {
        trigger sethintstring( &"ZOMBIE_PENTAGON_PACK_ROOM_DOOR" );
        trigger setcursorhint( "HINT_NOICON" );
        level waittill_any( "defcon_reset", "player_in_pack" );
        players = get_players();

        if ( level.zones["conference_level2"].is_occupied )
        {
            if ( level.zones["war_room_zone_south"].is_enabled && !flag( "bonfire_reset" ) )
            {
                trigger sethintstring( "" );

                for ( i = 0; i < doors.size; i++ )
                {
                    doors[i].start_angles = doors[i].angles;

                    if ( isdefined( doors[i].script_angles ) )
                    {
                        doors[i] notsolid();
                        doors[i] rotateto( doors[i].script_angles, 1.0 );
                        play_sound_at_pos( "door_rotate_open", doors[i].origin );
                        doors[i] thread pack_door_solid_thread();
                    }
                }

                pack_door_open = 1;
            }

            while ( !is_packroom_clear() )
            {
                if ( flag( "bonfire_reset" ) )
                    break;

                wait 0.1;
            }

            if ( pack_door_open == 1 )
            {
                for ( i = 0; i < doors.size; i++ )
                {
                    if ( isdefined( doors[i].script_angles ) )
                    {
                        doors[i] notsolid();
                        doors[i] rotateto( doors[i].start_angles, 0.25 );
                        play_sound_at_pos( "door_rotate_open", doors[i].origin );
                        doors[i] thread pack_door_solid_thread();
                    }
                }
            }
        }

        if ( flag( "bonfire_reset" ) )
            flag_clear( "bonfire_reset" );
        else
            level notify( "pack_room_reset" );

        wait_network_frame();
    }
}

is_packroom_clear()
{
    pack_door_slam = getent( "slam_pack_door", "targetname" );
    pack_room_trig = getent( "pack_room_trigger", "targetname" );
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] istouching( pack_door_slam ) )
            return false;
    }

    if ( level.zones["conference_level2"].is_occupied )
        return false;
    else if ( flag( "thief_round" ) )
    {
        zombies = getaiarray( "axis" );

        for ( i = 0; i < zombies.size; i++ )
        {
            if ( isdefined( zombies[i].animname ) && zombies[i].animname == "thief_zombie" && zombies[i] istouching( pack_room_trig ) )
                return false;

            if ( isdefined( zombies[i].animname ) && zombies[i].animname == "thief_zombie" && zombies[i] istouching( pack_door_slam ) )
                return false;
        }
    }

    return true;
}

pack_door_solid_thread()
{
    self waittill( "rotatedone" );
    self.door_moving = undefined;

    while ( true )
    {
        players = get_players();
        player_touching = 0;

        for ( i = 0; i < players.size; i++ )
        {
            if ( players[i] istouching( self ) )
            {
                player_touching = 1;
                break;
            }
        }

        if ( !player_touching )
        {
            self solid();

            if ( self.angles != self.start_angles )
                self connectpaths();
            else
                self disconnectpaths();

            return;
        }

        wait 1;
    }
}

clear_zombies_in_packroom()
{
    pack_room_trig = getent( "pack_room_trigger", "targetname" );

    if ( flag( "thief_round" ) )
        return;

    zombies = getaiarray( "axis" );

    if ( !isdefined( zombies ) )
        return;

    for ( i = 0; i < zombies.size; i++ )
    {
        if ( zombies[i] istouching( pack_room_trig ) )
        {
            if ( zombies[i].ignoreall == 1 )
            {
                level.zombie_total++;

                if ( isdefined( zombies[i].fx_quad_trail ) )
                    zombies[i].fx_quad_trail delete();

                zombies[i] maps\mp\zombies\_zm_spawner::reset_attack_spot();
                zombies[i] notify( "zombie_delete" );
                zombies[i] delete();
                continue;
            }

            zombies[i] thread send_zombies_out( level.portal_pack );
        }
    }
}

player_teleporting()
{
    user = undefined;

    while ( true )
    {
        self waittill( "trigger", user );
        player_used = 0;

        if ( isdefined( self.portal_used ) )
        {
            for ( i = 0; i < self.portal_used.size; i++ )
            {
                if ( self.portal_used[i] == user )
                    player_used = 1;
            }
        }

        wait_network_frame();

        if ( player_used == 1 )
            continue;
        else if ( is_player_valid( user ) || user maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
            self thread teleport_player( user );
    }
}

cooldown_portal_timer( player )
{
    self.portal_used[self.portal_used.size] = player;

    for ( time = 0; !flag( "defcon_active" ) && time < 20; time++ )
        wait 1;

    arrayremovevalue( self.portal_used, player );
}

teleport_player( user )
{
    prone_offset = vectorscale( ( 0, 0, 1 ), 49.0 );
    crouch_offset = vectorscale( ( 0, 0, 1 ), 20.0 );
    stand_offset = ( 0, 0, 0 );
    destination = undefined;
    dest_trig = 0;

    if ( isdefined( user.teleporting ) && user.teleporting == 1 )
        return;

    user.teleporting = 1;
    user freezecontrols( 1 );
    user disableoffhandweapons();
    user disableweapons();

    if ( flag( "defcon_active" ) && self.script_noteworthy != "conference_level2" )
    {
        for ( i = 0; i < level.portal_trig.size; i++ )
        {
            if ( isdefined( level.portal_trig[i].script_noteworthy ) && level.portal_trig[i].script_noteworthy == "conference_level2" )
            {
                dest_trig = i;
                user thread start_defcon_countdown();
                self thread defcon_pack_poi();
            }
        }
    }
    else
    {
        dest_trig = find_portal_destination( self );

        if ( !isdefined( dest_trig ) )
        {
            while ( !isdefined( dest_trig ) )
            {
                dest_trig = find_portal_destination( self );
                break;
                wait_network_frame();
            }
        }

        self thread no_zombie_left_behind( level.portal_trig[dest_trig], user );
    }

    player_destination = getstructarray( level.portal_trig[dest_trig].target, "targetname" );

    if ( isdefined( player_destination ) )
    {
        for ( i = 0; i < player_destination.size; i++ )
        {
            if ( isdefined( player_destination[i].script_noteworthy ) && player_destination[i].script_noteworthy == "player_pos" )
                destination = player_destination[i];
        }
    }

    if ( !isdefined( destination ) )
        destination = groundpos( level.portal_trig[dest_trig].origin );

    level.portal_trig[dest_trig] thread cooldown_portal_timer( user );

    if ( user getstance() == "prone" )
        desired_origin = destination.origin + prone_offset;
    else if ( user getstance() == "crouch" )
        desired_origin = destination.origin + crouch_offset;
    else
        desired_origin = destination.origin + stand_offset;

    wait_network_frame();
    playfx( level._effect["transporter_start"], user.origin );
    playsoundatposition( "evt_teleporter_out", user.origin );
    players = getplayers();

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] == user )
            continue;

        if ( distance( players[i].origin, desired_origin ) < 18 )
            desired_origin = desired_origin + anglestoforward( destination.angles ) * -32;
    }

    user setorigin( desired_origin );
    user setplayerangles( destination.angles );
    playfx( level._effect["transporter_beam"], user.origin );
    playsoundatposition( "evt_teleporter_go", user.origin );
    wait 0.5;
    user enableweapons();
    user enableoffhandweapons();
    user freezecontrols( 0 );
    user.teleporting = 0;
    level thread check_if_empty_floors();
    setclientsysstate( "levelNotify", "cool_fx", user );
    setclientsysstate( "levelNotify", "ae1", user );
    wait 1.25;

    if ( flag( "thief_round" ) )
    {
        setclientsysstate( "levelNotify", "vis4", user );
        return;
    }
    else
    {
        user.floor = maps\mp\zombies\_zm_ai_thief::thief_check_floor( user );
        setclientsysstate( "levelNotify", "vis" + user.floor, user );
    }
}

find_portal_destination( orig_trig )
{
    if ( isdefined( orig_trig.thief_override ) )
        return orig_trig.thief_override;

    if ( isdefined( orig_trig.script_string ) && orig_trig.script_string == "power_room_portal" )
    {
        loc = [];

        for ( i = 0; i < level.portal_trig.size; i++ )
        {
            if ( level.portal_trig[i].script_noteworthy == "war_room_zone_north" )
            {
                loc[0] = i;
                continue;
            }

            if ( level.portal_trig[i].script_noteworthy == "conference_level1" )
                loc[1] = i;
        }

        dest_trig = loc[randomintrange( 0, 2 )];
        return dest_trig;
    }
    else
    {
        dest_trig = randomintrange( 0, level.portal_trig.size );

        if ( level.portal_trig[dest_trig] == orig_trig || level.portal_trig[dest_trig].script_noteworthy == "conference_level2" || !level.zones[level.portal_trig[dest_trig].script_noteworthy].is_enabled )
        {
            portals = level.portal_trig;

            for ( i = 0; i < level.portal_trig.size; i++ )
            {
                level.portal_trig[i].index = i;

                if ( level.portal_trig[i] == orig_trig || level.portal_trig[i].script_noteworthy == "conference_level2" || !level.zones[level.portal_trig[i].script_noteworthy].is_enabled )
                    arrayremovevalue( portals, level.portal_trig[i] );
            }

            rand = randomintrange( 0, portals.size );
            dest_trig = portals[rand].index;
        }

        return dest_trig;
    }
}

delete_zombie_noone_looking( how_close, verticle_only, need_to_see )
{
    self endon( "death" );

    if ( !isdefined( how_close ) )
        how_close = 500;

    if ( !isdefined( verticle_only ) )
        verticle_only = 1;

    if ( !isdefined( need_to_see ) )
        need_to_see = 1;

    self.inview = 0;
    self.player_close = 0;
    players = getplayers();

    for ( i = 0; i < players.size; i++ )
    {
        can_be_seen = self player_can_see_me( players[i] );

        if ( can_be_seen )
        {
            self.inview++;
            continue;
        }

        if ( verticle_only )
        {
            closest = abs( self.origin[2] - players[i].origin[2] );

            if ( closest < how_close )
                self.player_close++;

            continue;
        }

        closest = distance( self.origin, players[i].origin );

        if ( closest < how_close )
            self.player_close++;
    }

    wait_network_frame();

    if ( self.inview == 0 && self.player_close == 0 || need_to_see == 0 && self.player_close == 0 )
    {
        if ( isdefined( self.teleporting ) && self.teleporting == 1 )
            return;
        else if ( isdefined( self.animname ) && self.animname == "thief_zombie" )
            return;
        else if ( isdefined( self.animname ) && self.animname == "quad_zombie" )
        {
            level.zombie_total++;

            if ( isdefined( self.fx_quad_trail ) )
                self.fx_quad_trail delete();

            self notify( "zombie_delete" );
            self delete();
        }
        else
        {
            level.zombie_total++;
            self maps\mp\zombies\_zm_spawner::reset_attack_spot();
            self notify( "zombie_delete" );
            self delete();
        }
    }
}

player_can_see_me( player )
{
    playerangles = player getplayerangles();
    playerforwardvec = anglestoforward( playerangles );
    playerunitforwardvec = vectornormalize( playerforwardvec );
    banzaipos = self.origin;
    playerpos = player getorigin();
    playertobanzaivec = banzaipos - playerpos;
    playertobanzaiunitvec = vectornormalize( playertobanzaivec );
    forwarddotbanzai = vectordot( playerunitforwardvec, playertobanzaiunitvec );
    anglefromcenter = acos( forwarddotbanzai );
    playerfov = getdvarfloat( #"cg_fov" );
    banzaivsplayerfovbuffer = getdvarfloat( #"_id_BCB625CF" );

    if ( banzaivsplayerfovbuffer <= 0 )
        banzaivsplayerfovbuffer = 0.2;

    playercanseeme = anglefromcenter <= playerfov * 0.5 * ( 1 - banzaivsplayerfovbuffer );
    return playercanseeme;
}

open_portal_rooms()
{
    yellow_conf_screen = getent( "yellow_conf_screen", "targetname" );
    power_room_screen = getent( "power_room_screen", "targetname" );
    jfk_room_screen = getent( "jfk_room_screen", "targetname" );
    war_room_screen_north = getent( "war_room_screen_north", "targetname" );
    war_room_screen_ramp = getent( "war_room_screen_ramp", "targetname" );
    flag_wait( "power_on" );
    yellow_conf_screen playsound( "evt_teleporter_door_short" );
    yellow_conf_screen movez( 116, 1.5 );
    yellow_conf_screen connectpaths();
    power_room_screen playsound( "evt_teleporter_door_short" );
    power_room_screen movez( 116, 1.5 );
    power_room_screen connectpaths();
    jfk_room_screen playsound( "evt_teleporter_door_long" );
    jfk_room_screen movez( 150, 2.0 );
    jfk_room_screen connectpaths();
    war_room_screen_north playsound( "evt_teleporter_door_short" );
    level thread war_room_portal_door();
    war_room_screen_north movez( -122, 1.5 );
    war_room_screen_ramp movey( 46, 1.5 );
    war_room_screen_ramp waittill( "movedone" );
    war_room_screen_north connectpaths();
}

war_room_portal_door()
{
    war_room_screen_south = getent( "war_room_screen_south", "targetname" );
    war_room_screen_south playsound( "evt_teleporter_door_short" );
    war_room_screen_south movez( -120, 1.5 );
    war_room_screen_south waittill( "movedone" );
    war_room_screen_south connectpaths();
}

enable_zone_portals_init()
{
    portal_zone_trig = getentarray( "portal_zone_trigs", "targetname" );

    for ( i = 0; i < portal_zone_trig.size; i++ )
        portal_zone_trig[i] thread enable_zone_portals();
}

enable_zone_portals()
{
    self waittill( "trigger", user );

    if ( ( user maps\mp\zombies\_zm_laststand::player_is_in_laststand() || is_player_valid( user ) ) && isdefined( self.script_noteworthy ) )
        level thread maps\mp\zombies\_zm_zonemgr::enable_zone( self.script_noteworthy );
}

no_zombie_left_behind( portal_trig, targeted_player )
{
    portal_enter = undefined;
    teleporting_zombies = 0;
    portal_entered = getstructarray( self.target, "targetname" );

    for ( i = 0; i < portal_entered.size; i++ )
    {
        if ( isdefined( portal_entered[i].script_noteworthy ) && portal_entered[i].script_noteworthy == "zombie_pos" )
            portal_enter = portal_entered[i];
    }

    if ( !isdefined( portal_enter ) )
        return;

    zombies = getaiarray( "axis" );

    if ( isdefined( zombies ) )
    {
        for ( i = 0; i < zombies.size; i++ )
        {
            if ( isdefined( zombies[i].animname ) && zombies[i].animname == "thief_zombie" )
                continue;
            else
            {
                if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "conference_level2" && !level.zones["conference_level2"].is_occupied && isdefined( zombies[i].favoriteenemy ) && zombies[i].favoriteenemy == targeted_player )
                {
                    zombies[i].teleporting = 1;
                    zombies[i] thread zombie_through_portal( portal_enter, portal_trig, targeted_player );
                    continue;
                }

                if ( distance( zombies[i].origin, portal_enter.origin ) < 500 && isdefined( zombies[i].favoriteenemy ) && zombies[i].favoriteenemy == targeted_player )
                {
                    zombies[i].teleporting = 1;
                    zombies[i] thread zombie_through_portal( portal_enter, portal_trig, targeted_player );
                    teleporting_zombies++;
                }
            }
        }
    }
}

zombie_through_portal( portal_enter, portal_exit, targeted_player )
{
    self endon( "death" );
    self endon( "damage" );
    wait_network_frame();

    if ( distance( self.origin, targeted_player.origin ) < 500 )
    {
        self.teleporting = 0;
        return;
    }

    move_speed = undefined;

    if ( isdefined( self.zombie_move_speed ) )
        move_speed = self.zombie_move_speed;

    self.ignoreall = 1;
    self notify( "stop_find_flesh" );
    self notify( "zombie_acquire_enemy" );
    self setgoalpos( portal_enter.origin );
    self.timed_out = 0;
    self thread teleportation_timed_out();

    while ( distance( self.origin, portal_enter.origin ) > self.goalradius && self.timed_out == 0 )
        wait 0.1;

    if ( isdefined( self.pre_teleport_func ) )
        self [[ self.pre_teleport_func ]]();

    playfx( level._effect["transporter_start"], self.origin );
    playsoundatposition( "evt_teleporter_out", portal_enter.origin );
    final_destination = getstructarray( portal_exit.target, "targetname" );

    for ( i = 0; i < final_destination.size; i++ )
    {
        if ( isdefined( final_destination[i].script_noteworthy ) && final_destination[i].script_noteworthy == "zombie_pos" )
            portal_exit = final_destination[i];
    }

    self forceteleport( portal_exit.origin + anglestoforward( portal_exit.angles ) * randomfloatrange( 0, 64 ), portal_exit.angles );
    playfx( level._effect["transporter_beam"], portal_exit.origin );
    playsoundatposition( "evt_teleporter_go", portal_exit.origin );
    self.teleporting = 0;
    self.ignoreall = 0;
    self thread maps\mp\zombies\_zm_ai_basic::find_flesh();

    if ( isdefined( move_speed ) )
        self.zombie_move_speed = move_speed;

    if ( isdefined( self.post_teleport_func ) )
        self [[ self.post_teleport_func ]]();
}

pentagon_packapunch_init()
{
    level.defcon_level = 1;
    level.defcon_activated = 0;
    level.ignore_spawner_func = ::pentagon_ignore_spawner;
    level thread defcon_sign_lights();
    punch_switches = getentarray( "punch_switch", "targetname" );

    if ( isdefined( punch_switches ) )
    {
        for ( i = 0; i < punch_switches.size; i++ )
            punch_switches[i] thread defcon_sign_setup();
    }
}

defcon_sign_setup()
{
    self sethintstring( &"ZOMBIE_NEED_POWER" );
    self setcursorhint( "HINT_NOICON" );
    flag_wait( "power_on" );
    self.lights = getentarray( self.target, "targetname" );

    if ( isdefined( self.lights ) )
    {
        for ( j = 0; j < self.lights.size; j++ )
        {
            if ( isdefined( self.lights[j].script_noteworthy ) && self.lights[j].script_noteworthy == "defcon_bulb" )
                self.lights[j] setmodel( "zombie_trap_switch_light_on_green" );
        }
    }

    while ( true )
    {
        self sethintstring( &"ZOMBIE_PENTAGON_DEFCON_SWITCH" );
        self waittill( "trigger", user );
        self sethintstring( "" );

        if ( isdefined( self.lights ) )
        {
            for ( j = 0; j < self.lights.size; j++ )
            {
                if ( isdefined( self.lights[j].script_noteworthy ) && self.lights[j].script_noteworthy == "defcon_bulb" )
                    self.lights[j] setmodel( "zombie_trap_switch_light_on_red" );

                if ( isdefined( self.lights[j].script_noteworthy ) && self.lights[j].script_noteworthy == "defcon_handle" )
                {
                    self.lights[j] rotatepitch( -180, 0.5 );
                    self.lights[j] playsound( "zmb_defcon_switch" );
                }
            }
        }

        if ( level.defcon_level != 4 )
        {
            level.defcon_level++;

            if ( level.zombie_vars["zombie_powerup_bonfire_sale_on"] == 0 )
                level thread maps\mp\zm_pentagon_amb::play_pentagon_announcer_vox( "zmb_vox_pentann_defcon", level.defcon_level );

            level thread defcon_sign_lights();
        }
        else
        {
            level.defcon_level = 5;

            if ( level.zombie_vars["zombie_powerup_bonfire_sale_on"] == 0 || !flag( "bonfire_reset" ) )
                level thread maps\mp\zm_pentagon_amb::play_pentagon_announcer_vox( "zmb_vox_pentann_defcon", level.defcon_level );

            level thread defcon_sign_lights();
            flag_set( "defcon_active" );

            if ( level.zombie_vars["zombie_powerup_bonfire_sale_on"] == 0 || !flag( "bonfire_reset" ) )
                level thread play_defcon5_alarms();

            level thread pack_portal_fx_on();
        }

        level waittill( "pack_room_reset" );

        if ( !flag( "bonfire_reset" ) )
            level thread maps\mp\zm_pentagon_amb::play_pentagon_announcer_vox( "zmb_vox_pentann_defcon_reset" );

        if ( isdefined( self.lights ) )
        {
            for ( j = 0; j < self.lights.size; j++ )
            {
                if ( isdefined( self.lights[j].script_noteworthy ) && self.lights[j].script_noteworthy == "defcon_bulb" )
                    self.lights[j] setmodel( "zombie_trap_switch_light_on_green" );

                if ( isdefined( self.lights[j].script_noteworthy ) && self.lights[j].script_noteworthy == "defcon_handle" )
                {
                    self.lights[j] rotatepitch( 180, 0.5 );
                    self.lights[j] playsound( "zmb_defcon_switch" );
                }
            }
        }
    }
}

pack_portal_fx_on()
{
    players = get_players();
    players[0] setclientfield( "clientfield_pentagon_player_portalfx", 0 );
}

regular_portal_fx_on()
{
    players = get_players();
    players[0] setclientfield( "clientfield_pentagon_player_portalfx", 1 );
}

defcon_sign_lights()
{
    defcon_signs = getentarray( "defcon_sign", "targetname" );
    defcon[1] = "p_zm_pent_defcon_sign_01";
    defcon[2] = "p_zm_pent_defcon_sign_02";
    defcon[3] = "p_zm_pent_defcon_sign_03";
    defcon[4] = "p_zm_pent_defcon_sign_04";
    defcon[5] = "p_zm_pent_defcon_sign_05";

    if ( isdefined( defcon_signs ) )
    {
        for ( i = 0; i < defcon_signs.size; i++ )
        {
            if ( isdefined( level.defcon_level ) )
            {
                defcon_signs[i] setmodel( defcon[level.defcon_level] );
                continue;
            }

            defcon_signs[i] setmodel( defcon[1] );
        }
    }
}

start_defcon_countdown()
{
    if ( level.defcon_activated )
        return;

    if ( level.zones["war_room_zone_south"].is_enabled )
    {
        if ( !flag( "war_room_entry" ) )
            flag_set( "war_room_entry" );
    }
    else if ( !flag( "war_room_special" ) )
        flag_set( "war_room_special" );

    level thread special_pack_time_spawning();
    level thread special_pack_cleanup();
    flag_set( "open_pack_hideaway" );
    level.defcon_activated = 1;
    level.defcon_countdown_time = 30;

    while ( level.defcon_level > 1 )
    {
        wait( level.defcon_countdown_time / 4 );
        level.defcon_level--;
        level thread defcon_sign_lights();
    }

    level.defcon_level = 1;
    flag_clear( "defcon_active" );
    level.defcon_activated = 0;
    level thread regular_portal_fx_on();
    flag_clear( "bonfire_reset" );
    level notify( "defcon_reset" );
    wait 2.0;

    if ( !is_packroom_clear() )
        level notify( "player_in_pack" );
}

special_pack_time_spawning()
{
    flag_set( "no_pack_room_spawning" );
    maps\mp\zombies\_zm_zonemgr::reinit_zone_spawners();

    while ( level.defcon_level >= 3 )
        wait 0.1;

    flag_clear( "no_pack_room_spawning" );
    maps\mp\zombies\_zm_zonemgr::reinit_zone_spawners();
}

special_pack_cleanup()
{
    while ( flag( "defcon_active" ) )
        wait 1;

    if ( level.zones["conference_level2"].is_occupied )
    {
        while ( level.zones["conference_level2"].is_occupied )
            wait 1;
    }

    level thread clear_zombies_in_packroom();
}

defcon_pack_poi()
{
    zone_name = "conference_level2";
    players = get_players();
    poi1 = getent( "pack_room_poi1", "targetname" );
    poi2 = getent( "pack_room_poi2", "targetname" );
    wait 0.5;
    num_players = maps\mp\zombies\_zm_zonemgr::get_players_in_zone( zone_name );

    if ( num_players == players.size )
    {
        if ( level.zones["war_room_zone_south"].is_enabled )
            poi1 activate_zombie_point_of_interest();
        else
            poi2 activate_zombie_point_of_interest();
    }
    else
        return;

    while ( num_players >= players.size && flag( "defcon_active" ) )
    {
        num_players = maps\mp\zombies\_zm_zonemgr::get_players_in_zone( zone_name );
        wait 0.1;
    }

    poi1 deactivate_zombie_point_of_interest();
    poi2 deactivate_zombie_point_of_interest();
}

check_if_empty_floors()
{
    num_floor1 = 0;
    num_floor2 = 0;
    num_floor3 = 0;
    num_floor1_laststand = 0;
    num_floor2_laststand = 0;
    num_floor3_laststand = 0;
    players = getplayers();

    for ( i = 0; i < players.size; i++ )
    {
        players[i].floor = maps\mp\zombies\_zm_ai_thief::thief_check_floor( players[i] );

        if ( players[i].floor == 1 )
        {
            num_floor1++;

            if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() || players[i].sessionstate == "spectator" )
                num_floor1_laststand++;

            continue;
        }

        if ( players[i].floor == 2 )
        {
            num_floor2++;

            if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() || players[i].sessionstate == "spectator" )
                num_floor2_laststand++;

            continue;
        }

        if ( players[i].floor == 3 )
        {
            num_floor3++;

            if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() || players[i].sessionstate == "spectator" )
                num_floor3_laststand++;
        }
    }

    zombies = getaiarray( "axis" );

    if ( !isdefined( zombies ) )
        return;

    for ( i = 0; i < zombies.size; i++ )
    {
        zombies[i].floor = maps\mp\zombies\_zm_ai_thief::thief_check_floor( zombies[i] );

        if ( isdefined( zombies[i].animname ) && zombies[i].animname == "thief_zombie" )
            continue;
        else if ( isdefined( zombies[i].teleporting ) && zombies[i].teleporting == 1 )
            continue;
        else if ( isdefined( zombies[i].floor ) && zombies[i].floor == 1 )
        {
            if ( num_floor1 == num_floor1_laststand && players.size > 1 && flag( "power_on" ) )
                zombies[i] thread send_zombies_out( level.portal_top );
            else if ( num_floor1 == num_floor1_laststand && players.size > 1 && !flag( "power_on" ) )
            {
                playfx( level._effect["transporter_start"], zombies[i].origin );
                zombies[i] thread cleanup_unoccupied_floor();
            }
            else if ( num_floor1 == 0 )
            {
                if ( flag( "power_on" ) )
                    zombies[i] thread send_zombies_out( level.portal_top );
                else
                    zombies[i] thread cleanup_unoccupied_floor();
            }
            else
                continue;
        }
        else if ( isdefined( zombies[i].floor ) && zombies[i].floor == 2 )
        {
            if ( num_floor2 == num_floor2_laststand && players.size > 1 && flag( "power_on" ) )
                zombies[i] thread send_zombies_out( level.portal_mid );
            else if ( num_floor2 == num_floor2_laststand && players.size > 1 && !flag( "power_on" ) )
            {
                playfx( level._effect["transporter_start"], zombies[i].origin );
                zombies[i] thread cleanup_unoccupied_floor();
            }
            else if ( num_floor2 == 0 )
            {
                if ( flag( "power_on" ) )
                    zombies[i] thread send_zombies_out( level.portal_mid );
                else
                    zombies[i] thread cleanup_unoccupied_floor();
            }
            else
                continue;
        }
        else if ( isdefined( zombies[i].floor ) && zombies[i].floor == 3 )
        {
            if ( num_floor3 == num_floor3_laststand && players.size > 1 && flag( "power_on" ) )
                zombies[i] thread send_zombies_out( level.portal_power );
            else if ( num_floor3 == num_floor3_laststand && players.size > 1 && !flag( "power_on" ) )
            {
                playfx( level._effect["transporter_start"], zombies[i].origin );
                zombies[i] thread cleanup_unoccupied_floor();
            }
            else if ( num_floor3 == 0 )
            {
                if ( flag( "power_on" ) )
                    zombies[i] thread send_zombies_out( level.portal_power );
                else
                    zombies[i] thread cleanup_unoccupied_floor();
            }
            else
                continue;
        }
        else
        {
            level.zombie_total++;
            zombies[i] dodamage( zombies[i].health + 100, zombies[i].origin );
        }
    }
}

send_zombies_out( portal )
{
    self endon( "death" );
    move_speed = undefined;

    if ( isdefined( self.zombie_move_speed ) )
        move_speed = self.zombie_move_speed;

    self.ignoreall = 1;
    self.teleporting = 1;
    self notify( "stop_find_flesh" );
    self notify( "zombie_acquire_enemy" );
    self setgoalpos( portal.origin );
    self.timed_out = 0;
    self thread teleportation_timed_out();

    while ( distance( self.origin, portal.origin ) > self.goalradius && self.timed_out == 0 )
        wait 0.1;

    playfx( level._effect["transporter_start"], self.origin );
    playsoundatposition( "evt_teleporter_out", self.origin );

    if ( portal == level.portal_pack )
    {
        self forceteleport( level.portal_mid.origin + anglestoforward( level.portal_mid.angles ) * randomfloatrange( 0, 32 ), level.portal_mid.angles );
        playfx( level._effect["transporter_beam"], level.portal_top.origin );
        playsoundatposition( "evt_teleporter_go", level.portal_top.origin );
        self thread cleanup_unoccupied_floor( move_speed );
    }
    else
        self thread cleanup_unoccupied_floor( move_speed );
}

teleportation_timed_out()
{
    for ( time = 0; isdefined( self ) && !self.timed_out && time < 20; time++ )
        wait 1;

    if ( isdefined( self ) )
        self.timed_out = 1;
}

cleanup_unoccupied_floor( move_speed, current_floor, next_floor )
{
    self endon( "death" );
    self notify( "teleporting" );
    self notify( "stop_zombie_goto_entrance" );
    self.floor = maps\mp\zombies\_zm_ai_thief::thief_check_floor( self );
    self maps\mp\zombies\_zm_spawner::reset_attack_spot();

    if ( isdefined( self.animname ) && self.animname == "thief_zombie" )
        return;

    num_floor1 = 0;
    num_floor2 = 0;
    num_floor3 = 0;
    num_floor1_laststand = 0;
    num_floor2_laststand = 0;
    num_floor3_laststand = 0;
    pos_num = 0;
    teleport_pos = [];
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        players[i].floor = maps\mp\zombies\_zm_ai_thief::thief_check_floor( players[i] );

        if ( players[i].floor == 1 )
        {
            num_floor1++;

            if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() || players[i].sessionstate == "spectator" )
                num_floor1_laststand++;

            continue;
        }

        if ( players[i].floor == 2 )
        {
            num_floor2++;

            if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() || players[i].sessionstate == "spectator" )
                num_floor2_laststand++;

            continue;
        }

        if ( players[i].floor == 3 )
        {
            num_floor3++;

            if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() || players[i].sessionstate == "spectator" )
                num_floor3_laststand++;
        }
    }

    if ( flag( "power_on" ) )
    {
        if ( num_floor3 > 0 && num_floor3 != num_floor3_laststand && self.floor != 3 )
        {
            num = randomintrange( 0, level.portal_bottom.size );
            self forceteleport( level.portal_bottom[num].origin + anglestoforward( level.portal_bottom[num].angles ) * randomfloatrange( 0, 32 ), level.portal_bottom[num].angles );
            playfx( level._effect["transporter_beam"], level.portal_bottom[num].origin );
            playsoundatposition( "evt_teleporter_go", level.portal_bottom[num].origin );
        }
        else if ( num_floor2 > 0 && num_floor2 != num_floor2_laststand && self.floor != 2 )
        {
            self forceteleport( level.portal_mid.origin + anglestoforward( level.portal_mid.angles ) * randomfloatrange( 0, 32 ), level.portal_mid.angles );
            playfx( level._effect["transporter_beam"], level.portal_mid.origin );
            playsoundatposition( "evt_teleporter_go", level.portal_mid.origin );
        }
        else if ( num_floor1 > 0 && num_floor1 != num_floor1_laststand && self.floor != 1 )
        {
            self forceteleport( level.portal_top.origin + anglestoforward( level.portal_top.angles ) * randomfloatrange( 0, 32 ), level.portal_top.angles );
            playfx( level._effect["transporter_beam"], level.portal_top.origin );
            playsoundatposition( "evt_teleporter_go", level.portal_top.origin );
        }

        self.teleporting = 0;
        self.ignoreall = 0;
        self thread maps\mp\zombies\_zm_ai_basic::find_flesh();

        if ( isdefined( move_speed ) )
            self.zombie_move_speed = move_speed;
    }
    else
    {
        self.teleporting = 0;

        if ( !isdefined( self.animname ) || self.animname != "quad_zombie" )
        {
            if ( self.health == level.zombie_health )
            {
                level.zombie_total++;

                if ( isdefined( self.fx_quad_trail ) )
                    self.fx_quad_trail delete();

                self maps\mp\zombies\_zm_spawner::reset_attack_spot();
                self notify( "zombie_delete" );
                self delete();
            }
            else if ( isdefined( next_floor ) && isdefined( current_floor ) )
            {
                if ( next_floor == 3 && current_floor == 2 )
                    teleport_pos = getstructarray( "elevator1_down_hidden", "targetname" );
                else if ( next_floor == 2 && current_floor == 3 )
                    teleport_pos = getstructarray( "elevator1_up_hidden", "targetname" );
                else if ( next_floor == 2 && current_floor == 1 )
                    teleport_pos = getstructarray( "elevator2_down_hidden", "targetname" );
                else if ( next_floor == 1 && current_floor == 2 )
                    teleport_pos = getstructarray( "elevator2_up_hidden", "targetname" );
            }
            else if ( num_floor3 > 0 && num_floor3 != num_floor3_laststand && self.floor != 3 )
                teleport_pos = getstructarray( "elevator1_down_hidden", "targetname" );
            else if ( num_floor2 > 0 && num_floor2 != num_floor2_laststand && self.floor != 2 )
                teleport_pos = getstructarray( "elevator2_down_hidden", "targetname" );
            else if ( num_floor1 > 0 && num_floor1 != num_floor1_laststand && self.floor != 1 )
                teleport_pos = getstructarray( "elevator2_up_hidden", "targetname" );
            else
                return;

            if ( isdefined( teleport_pos ) )
            {
                pos_num = randomintrange( 0, teleport_pos.size );
                self forceteleport( teleport_pos[pos_num].origin + ( randomfloatrange( 0, 22 ), randomfloatrange( 0, 22 ), 0 ), teleport_pos[pos_num].angles );
            }

            wait 1;

            if ( isdefined( self ) )
            {
                self.ignoreall = 1;
                self notify( "stop_find_flesh" );
                self notify( "zombie_acquire_enemy" );
                wait_network_frame();

                if ( isdefined( self.target ) )
                    self.target = undefined;

                self thread maps\mp\zombies\_zm_spawner::zombie_think();
            }
        }
        else if ( isdefined( self.animname ) && self.animname == "quad_zombie" )
        {
            level.zombie_total++;

            if ( isdefined( self.fx_quad_trail ) )
                self.fx_quad_trail delete();

            self notify( "zombie_delete" );
            self delete();
        }
        else
        {
            level.zombie_total++;
            self maps\mp\zombies\_zm_spawner::reset_attack_spot();
            self notify( "zombie_delete" );
            self delete();
        }
    }
}

teleporter_power_cable()
{
    cable_on = getent( "teleporter_link_cable_on", "targetname" );
    cable_off = getent( "teleporter_link_cable_off", "targetname" );
    cable_on hide();
    flag_wait( "power_on" );
    cable_off hide();
    cable_on show();
}

pentagon_ignore_spawner( spawner )
{
    if ( flag( "no_pack_room_spawning" ) )
    {
        if ( spawner.targetname == "conference_level2_spawners" )
            return true;
    }

    if ( flag( "no_warroom_elevator_spawning" ) )
    {
        if ( spawner.targetname == "war_room_zone_elevator_spawners" )
            return true;
    }

    if ( flag( "no_labs_elevator_spawning" ) )
    {
        if ( spawner.targetname == "labs_elevator_spawners" )
            return true;
    }

    return false;
}

play_defcon5_alarms()
{
    structs = getstructarray( "defcon_alarms", "targetname" );
    sound_ent = [];

    for ( i = 0; i < structs.size; i++ )
    {
        sound_ent[i] = spawn( "script_origin", structs[i].origin );
        sound_ent[i] playloopsound( "zmb_defcon_alarm", 0.25 );
    }

    level waittill( "defcon_reset" );

    for ( i = 0; i < sound_ent.size; i++ )
        sound_ent[i] stoploopsound( 0.5 );

    wait 1;
    array_delete( sound_ent );
}
