// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_fx;
#include clientscripts\mp\_utility;
#include clientscripts\mp\_music;
#include clientscripts\mp\zombies\_zm_utility;

main()
{
    level thread wait_for_teleport_aftereffect();
    waitforallclients();
    level.portal_effect = level._effect["zombie_pentagon_teleporter"];
    level.pack_effect = level._effect["zombie_pent_portal_pack"];
    onplayerconnect_callback( ::teleporter_fx_setup );
    onplayerconnect_callback( ::teleporter_fx_cool_down );
}

teleporter_fx_setup( clientnum )
{
    teleporters = getentarray( clientnum, "pentagon_teleport_fx", "targetname" );
    level.fxents[clientnum] = [];
    level.packtime[clientnum] = 1;
    teleporter_pack = getent( clientnum, "pentagon_teleport_fx_pack", "targetname" );
    teleporter_pack.fx_ent = spawn( clientnum, teleporter_pack.origin, "script_model" );
    teleporter_pack.fx_ent setmodel( "tag_origin" );
    teleporter_pack.fx_ent.angles = teleporter_pack.angles;
    teleporter_pack.portalfx = playfxontag( clientnum, level.portal_effect, teleporter_pack.fx_ent, "tag_origin" );
    teleporter_pack playloopsound( "evt_teleporter_loop", 1.75 );

    for ( i = 0; i < teleporters.size; i++ )
    {
        fx_ent = spawn( clientnum, teleporters[i].origin, "script_model" );
        fx_ent setmodel( "tag_origin" );
        fx_ent.angles = teleporters[i].angles;
        level.fxents[clientnum][level.fxents[clientnum].size] = fx_ent;
    }
}

teleporter_fx_init( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    fx_array = level.fxents[localclientnum];

    if ( newval && level.packtime[localclientnum] == 1 )
    {
/#
        println( "*** Client : regular portal fx on. ", localclientnum );
#/
        level.packtime[localclientnum] = 0;

        for ( i = 0; i < fx_array.size; i++ )
        {
            if ( isdefined( fx_array[i].portalfx ) )
                deletefx( localclientnum, fx_array[i].portalfx );

            wait 0.01;
            fx_array[i].portalfx = playfxontag( localclientnum, level.portal_effect, fx_array[i], "tag_origin" );
            playsound( localclientnum, "evt_teleporter_start", fx_array[i].origin );
            fx_array[i] playloopsound( "evt_teleporter_loop", 1.75 );
        }
    }
    else if ( !newval && level.packtime[localclientnum] == 0 )
    {
        level notify( "end_cool_downs" );
/#
        println( "*** Client : pack portal fx on. ", localclientnum );
#/
        level.packtime[localclientnum] = 1;

        for ( i = 0; i < fx_array.size; i++ )
        {
            if ( isdefined( fx_array[i].portalfx ) )
                deletefx( localclientnum, fx_array[i].portalfx );

            wait 0.01;
            fx_array[i].portalfx = playfxontag( localclientnum, level.pack_effect, fx_array[i], "tag_origin" );
            fx_array[i] thread play_packa_special_looper( localclientnum );
        }
    }
}

teleporter_fx_cool_down( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    while ( true )
    {
        level waittill( "cool_fx", localclientnum );
        players = getlocalplayers();

        if ( level.packtime[localclientnum] == 0 )
        {
            fx_pos = undefined;
            closest = 512;

            for ( i = 0; i < level.fxents[localclientnum].size; i++ )
            {
                if ( isdefined( level.fxents[localclientnum][i] ) )
                {
                    if ( closest > distance( level.fxents[localclientnum][i].origin, players[localclientnum].origin ) )
                    {
                        closest = distance( level.fxents[localclientnum][i].origin, players[localclientnum].origin );
                        fx_pos = level.fxents[localclientnum][i];
                    }
                }
            }

            if ( isdefined( fx_pos ) && isdefined( fx_pos.portalfx ) )
            {
                deletefx( localclientnum, fx_pos.portalfx );
                fx_pos.portalfx = playfxontag( localclientnum, level._effect["zombie_pent_portal_cool"], fx_pos, "tag_origin" );
                self thread turn_off_cool_down_fx( fx_pos, localclientnum );
            }
        }

        wait 0.1;
    }
}

turn_off_cool_down_fx( fx_pos, localclientnum )
{
    fx_pos thread cool_down_timer();
    fx_pos waittill( "cool_down_over" );

    if ( isdefined( fx_pos ) && isdefined( fx_pos.portalfx ) )
    {
        deletefx( localclientnum, fx_pos.portalfx );

        if ( level.packtime[localclientnum] == 0 )
            fx_pos.portalfx = playfxontag( localclientnum, level.portal_effect, fx_pos, "tag_origin" );
        else
            fx_pos.portalfx = playfxontag( localclientnum, level.pack_effect, fx_pos, "tag_origin" );
    }
}

cool_down_timer()
{
    time = 0;
    self.defcon_active = 0;
    self thread pack_cooldown_listener();

    while ( !self.defcon_active && time < 20 )
    {
        wait 1;
        time++;
    }

    self notify( "cool_down_over" );
}

pack_cooldown_listener()
{
    self endon( "cool_down_over" );
    level waittill( "end_cool_downs" );
    self.defcon_active = 1;
}

wait_for_teleport_aftereffect()
{
    while ( true )
    {
        level waittill( "ae1", clientnum );
        visionsetnaked( clientnum, "flare", 0.4 );
    }
}

play_packa_special_looper( clientnum )
{
    self playloopsound( "mus_packapunch_special", 1 );
    level waittill( "pack_portal_fx_off", clientnum );
    self stoploopsound( 1 );
}
