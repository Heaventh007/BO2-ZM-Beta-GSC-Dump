// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zm_sumpf;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\animscripts\zm_death;

init_elec_trap_trigs()
{
    trap_trigs = getentarray( "elec_trap_trig", "targetname" );

    for ( i = 0; i < trap_trigs.size; i++ )
    {
        trap_trigs[i] thread electric_trap_think();
        trap_trigs[i] thread electric_trap_dialog();
        wait_network_frame();
    }
}

electric_trap_dialog()
{
    self endon( "warning_dialog" );
    level endon( "switch_flipped" );
    timer = 0;

    while ( true )
    {
        wait 0.5;
        players = get_players();

        for ( i = 0; i < players.size; i++ )
        {
            dist = distancesquared( players[i].origin, self.origin );

            if ( dist > 4900 )
            {
                timer = 0;
                continue;
            }

            if ( dist < 4900 && timer < 3 )
            {
                wait 0.5;
                timer++;
            }

            if ( dist < 4900 && timer == 3 )
            {
                wait 3;
                self notify( "warning_dialog" );
            }
        }
    }
}

electric_trap_think()
{
    self.is_available = 1;
    self.zombie_cost = 1000;
    self.in_use = 0;
    self sethintstring( &"ZOMBIE_BUTTON_BUY_TRAP", self.zombie_cost );
    self setcursorhint( "HINT_NOICON" );
    level thread maps\mp\zm_sumpf::turnlightgreen( self.script_string );

    while ( true )
    {
        self waittill( "trigger", who );

        if ( who in_revive_trigger() )
            continue;

        if ( !isdefined( self.is_available ) )
            continue;

        if ( is_player_valid( who ) )
        {
            if ( who.score >= self.zombie_cost )
            {
                if ( !self.in_use )
                {
                    self.in_use = 1;
                    play_sound_at_pos( "purchase", who.origin );
                    who maps\mp\zombies\_zm_audio::create_and_play_dialog( "level", "trap_barrel" );
                    self thread electric_trap_move_switch( self );
                    self waittill( "switch_activated" );
                    who maps\mp\zombies\_zm_score::minus_to_player_score( self.zombie_cost );
                    self trigger_off();
                    level thread maps\mp\zm_sumpf::turnlightred( self.script_string );
                    self.zombie_dmg_trig = getent( self.target, "targetname" );
                    self.zombie_dmg_trig trigger_on();
                    self thread activate_electric_trap( who );
                    self waittill( "elec_done" );
                    clientnotify( self.script_string + "off" );

                    if ( isdefined( self.fx_org ) )
                        self.fx_org delete();

                    if ( isdefined( self.zapper_fx_org ) )
                        self.zapper_fx_org delete();

                    if ( isdefined( self.zapper_fx_switch_org ) )
                        self.zapper_fx_switch_org delete();

                    self.zombie_dmg_trig trigger_off();
                    wait 90;
                    self trigger_on();
                    level thread maps\mp\zm_sumpf::turnlightgreen( self.script_string );
                    pa_system = getent( "speaker_by_log", "targetname" );
                    playsoundatposition( "warning", pa_system.origin );
                    self notify( "available" );
                    self.in_use = 0;
                }
            }
        }
    }
}

electric_trap_move_switch( parent )
{
    tswitch = getent( parent.script_linkto, "targetname" );

    if ( tswitch.targetname == "sw_electric_trap_lever" )
    {
        tswitch rotatepitch( 180, 0.5 );
        tswitch playsound( "amb_sparks_l_b" );
        tswitch waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "available" );
        tswitch rotatepitch( -180, 0.5 );
    }
    else if ( tswitch.targetname == "se_electric_trap_lever" )
    {
        tswitch rotatepitch( 180, 0.5 );
        tswitch playsound( "amb_sparks_l_b" );
        tswitch waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "available" );
        tswitch rotatepitch( -180, 0.5 );
    }
    else if ( tswitch.targetname == "ne_electric_trap_lever" )
    {
        tswitch rotatepitch( 180, 0.5 );
        tswitch playsound( "amb_sparks_l_b" );
        tswitch waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "available" );
        tswitch rotatepitch( -180, 0.5 );
    }
    else if ( tswitch.targetname == "nw_electric_trap_lever" )
    {
        tswitch rotatepitch( 180, 0.5 );
        tswitch playsound( "amb_sparks_l_b" );
        tswitch waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "available" );
        tswitch rotatepitch( -180, 0.5 );
    }
}

activate_electric_trap( who )
{
    clientnotify( self.target );
    fire_points = getstructarray( self.target, "targetname" );

    for ( i = 0; i < fire_points.size; i++ )
    {
        wait_network_frame();
        fire_points[i] thread electric_trap_fx( self );
    }

    self.zombie_dmg_trig thread elec_barrier_damage( who );
    level waittill( "arc_done" );
}

electric_trap_fx( notify_ent )
{
    self.tag_origin = spawn( "script_model", self.origin );
    self.tag_origin playsound( "zmb_elec_start" );
    self.tag_origin playloopsound( "zmb_elec_loop" );
    self thread play_electrical_sound();
    wait 25;

    if ( isdefined( self.script_sound ) )
        self.tag_origin stoploopsound();

    self.tag_origin delete();
    notify_ent notify( "elec_done" );
    level notify( "arc_done" );
}

play_electrical_sound()
{
    level endon( "arc_done" );

    while ( true )
    {
        wait( randomfloatrange( 0.1, 0.5 ) );
        playsoundatposition( "zmb_elec_arc", self.origin );
    }
}

elec_barrier_damage( who )
{
    while ( true )
    {
        self waittill( "trigger", ent );

        if ( isplayer( ent ) )
            ent thread player_elec_damage();
        else
        {
            if ( ent.isdog && is_magic_bullet_shield_enabled( ent ) )
                continue;

            if ( !isdefined( ent.marked_for_death ) )
            {
                ent.marked_for_death = 1;
                ent thread zombie_elec_death( randomint( 100 ) );
                who.trapped_used[self.targetname] = level.round_number;
            }
        }
    }
}

play_elec_vocals()
{
    if ( isdefined( self ) )
    {
        org = self.origin;
        wait 0.15;
        playsoundatposition( "zmb_elec_vocals", org );
        playsoundatposition( "zmb_zombie_arc", org );
        playsoundatposition( "zmb_exp_jib_zombie", org );
    }
}

player_elec_damage()
{
    self endon( "death" );
    self endon( "disconnect" );

    if ( !isdefined( level.elec_loop ) )
        level.elec_loop = 0;

    if ( !isdefined( self.is_burning ) && !self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
    {
        self.is_burning = 1;
        self setelectrified( 1.25 );
        shocktime = 2.5;
        self shellshock( "electrocution", shocktime );

        if ( level.elec_loop == 0 )
        {
            elec_loop = 1;
            self playsound( "zombie_arc" );
        }

        if ( !self hasperk( "specialty_armorvest" ) || self.health - 100 < 1 )
        {
            radiusdamage( self.origin, 10, self.health + 100, self.health + 100 );
            self.is_burning = undefined;
        }
        else
        {
            self dodamage( 50, self.origin );
            wait 0.1;
            self.is_burning = undefined;
        }
    }
}

zombie_elec_death( flame_chance )
{
    self endon( "death" );

    if ( flame_chance > 90 && level.burning_zombies.size < 6 )
    {
        level.burning_zombies[level.burning_zombies.size] = self;
        self thread zombie_flame_watch();
        self playsound( "ignite" );
        self thread maps\mp\animscripts\zm_death::flame_death_fx();
        wait( randomfloat( 1.25 ) );
    }
    else
    {
        refs[0] = "guts";
        refs[1] = "right_arm";
        refs[2] = "left_arm";
        refs[3] = "right_leg";
        refs[4] = "left_leg";
        refs[5] = "no_legs";
        refs[6] = "head";
        self.a.gib_ref = refs[randomint( refs.size )];
        playsoundatposition( "zmb_zombie_arc", self.origin );

        if ( randomint( 100 ) > 40 )
        {
            if ( !flag( "dog_round" ) )
                self thread electroctute_death_fx();

            self thread play_elec_vocals();
        }

        wait( randomfloat( 1.25 ) );
        self playsound( "zmb_zombie_arc" );
    }

    self dodamage( self.health + 666, self.origin );
}

zombie_flame_watch()
{
    self waittill( "death" );
    self stoploopsound();
}

electroctute_death_fx()
{
    self endon( "death" );

    if ( isdefined( self.is_electrocuted ) && self.is_electrocuted )
        return;

    self.is_electrocuted = 1;
    self thread electrocute_timeout();

    if ( self.team == "axis" )
    {
        level.bconfiretime = gettime();
        level.bconfireorg = self.origin;
    }

    tagarray = [];
    tagarray[0] = "J_Elbow_LE";
    tagarray[1] = "J_Elbow_RI";
    tagarray[2] = "J_Knee_RI";
    tagarray[3] = "J_Knee_LE";
    tagarray = array_randomize( tagarray );

    if ( isdefined( tagarray[0] ) )
        playfxontag( level._effect["elec_md"], self, tagarray[0] );

    self playsound( "zmb_elec_jib_zombie" );
    wait 1;
    self playsound( "zmb_elec_jib_zombie" );
    tagarray[0] = "J_Wrist_RI";
    tagarray[1] = "J_Wrist_LE";

    if ( !isdefined( self.a.gib_ref ) || self.a.gib_ref != "no_legs" )
    {
        tagarray[2] = "J_Ankle_RI";
        tagarray[3] = "J_Ankle_LE";
    }

    tagarray = array_randomize( tagarray );

    if ( isdefined( tagarray[0] ) )
        playfxontag( level._effect["elec_sm"], self, tagarray[0] );

    if ( isdefined( tagarray[1] ) )
        playfxontag( level._effect["elec_sm"], self, tagarray[1] );
}

electrocute_timeout()
{
    self endon( "death" );
    self playloopsound( "amb_fire_manager_0" );
    wait 12;
    self stoploopsound();

    if ( isdefined( self ) && isalive( self ) )
    {
        self.is_electrocuted = 0;
        self notify( "stop_flame_damage" );
    }
}
