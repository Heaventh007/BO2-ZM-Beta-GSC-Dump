// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\zombies\_zm_audio;

randomize_vending_machines()
{
    vending_machines = [];
    vending_machines = getentarray( "zombie_vending", "targetname" );
    start_locations = [];
    start_locations[0] = getent( "random_vending_start_location_0", "script_noteworthy" );
    start_locations[1] = getent( "random_vending_start_location_1", "script_noteworthy" );
    start_locations[2] = getent( "random_vending_start_location_2", "script_noteworthy" );
    start_locations[3] = getent( "random_vending_start_location_3", "script_noteworthy" );
    level.start_locations = [];
    level.start_locations[level.start_locations.size] = start_locations[0].origin;
    level.start_locations[level.start_locations.size] = start_locations[1].origin;
    level.start_locations[level.start_locations.size] = start_locations[2].origin;
    level.start_locations[level.start_locations.size] = start_locations[3].origin;
    start_locations = array_randomize( start_locations );

    for ( i = 0; i < vending_machines.size; i++ )
    {
        origin = start_locations[i].origin;
        angles = start_locations[i].angles;
        machine = vending_machines[i] get_vending_machine( start_locations[i] );
        start_locations[i].origin = origin;
        start_locations[i].angles = angles;
        machine.origin = origin;
        machine.angles = angles;
        machine ghost();
        vending_machines[i] trigger_on();

        if ( flag( "solo_game" ) )
        {
            if ( vending_machines[i].script_noteworthy == "specialty_quickrevive" )
                vending_machines[i] thread solo_disable_quickrevive();
        }
    }
}

solo_disable_quickrevive()
{
    flag_wait( "solo_revive" );
    self unlink();
    self trigger_off();
}

get_vending_machine( start_location )
{
    machine = undefined;
    machine_clip = undefined;
    machine_array = getentarray( self.target, "targetname" );

    for ( i = 0; i < machine_array.size; i++ )
    {
        if ( isdefined( machine_array[i].script_noteworthy ) && machine_array[i].script_noteworthy == "clip" )
        {
            machine_clip = machine_array[i];
            continue;
        }

        machine = machine_array[i];
    }

    if ( !isdefined( machine ) )
        return;

    if ( isdefined( machine_clip ) )
        machine_clip linkto( machine );

    start_location.origin = machine.origin;
    start_location.angles = machine.angles;
    self enablelinkto();
    self linkto( start_location );
    return machine;
}

activate_vending_machine( machine, origin, entity )
{
    level notify( "master_switch_activated" );

    switch ( machine )
    {
        case "zombie_vending_jugg":
            level notify( "juggernog_on" );
            entity maps\mp\zombies\_zm_perks::perk_fx( "jugger_light" );
            break;
        case "zombie_vending_doubletap2":
            level notify( "doubletap_on" );
            entity maps\mp\zombies\_zm_perks::perk_fx( "doubletap_light" );
            break;
        case "zombie_vending_revive_on":
            level notify( "revive_on" );
            entity maps\mp\zombies\_zm_perks::perk_fx( "revive_light" );
            break;
        case "zombie_vending_sleight":
            level notify( "sleight_on" );
            entity maps\mp\zombies\_zm_perks::perk_fx( "sleight_light" );
            break;
    }

    play_vending_vo( machine, origin );
}

play_vending_vo( machine, origin )
{
    players = get_players();
    players = get_array_of_closest( origin, players, undefined, undefined, 512 );
    player = undefined;

    for ( i = 0; i < players.size; i++ )
    {
        if ( sighttracepassed( players[i] geteye(), origin, 0, undefined ) )
            player = players[i];
    }

    if ( !isdefined( player ) )
        return;

    switch ( machine )
    {
        case "zombie_vending_jugg":
            player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "level", "jugga" );
            break;
        case "zombie_vending_doubletap2":
            player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "level", "doubletap" );
            break;
        case "zombie_vending_revive_on":
            player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "level", "revive" );
            break;
        case "zombie_vending_sleight":
            player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "level", "speed" );
            break;
    }
}

vending_randomization_effect( index )
{
    vending_triggers = getentarray( "zombie_vending", "targetname" );
    machines = [];

    for ( j = 0; j < vending_triggers.size; j++ )
    {
        machine_array = getentarray( vending_triggers[j].target, "targetname" );

        for ( i = 0; i < machine_array.size; i++ )
        {
            if ( isdefined( machine_array[i].script_noteworthy ) && machine_array[i].script_noteworthy == "clip" )
                continue;
            else
                machines[j] = machine_array[i];
        }
    }

    for ( j = 0; j < machines.size; j++ )
    {
        if ( machines[j].origin == level.start_locations[index] )
            break;
    }

    if ( isdefined( level.first_time_opening_perk_hut ) )
    {
        if ( level.first_time_opening_perk_hut )
        {
            if ( machines[j].model != "zombie_vending_jugg_on" || machines[j].model != "zombie_vending_sleight_on" )
            {
                for ( i = 0; i < machines.size; i++ )
                {
                    if ( i != j && ( machines[i].model == "zombie_vending_jugg_on" || machines[i].model == "zombie_vending_sleight_on" ) )
                        break;
                }

                start_locations = [];
                start_locations[0] = getent( "random_vending_start_location_0", "script_noteworthy" );
                start_locations[1] = getent( "random_vending_start_location_1", "script_noteworthy" );
                start_locations[2] = getent( "random_vending_start_location_2", "script_noteworthy" );
                start_locations[3] = getent( "random_vending_start_location_3", "script_noteworthy" );
                target_index = undefined;
                switch_index = undefined;

                for ( x = 0; x < start_locations.size; x++ )
                {
                    if ( start_locations[x].origin == level.start_locations[index] )
                        target_index = x;

                    if ( start_locations[x].origin == machines[i].origin )
                        switch_index = x;
                }

                temp_origin = machines[j].origin;
                temp_angles = machines[j].angles;
                machines[j].origin = machines[i].origin;
                machines[j].angles = machines[i].angles;
                start_locations[target_index].origin = start_locations[switch_index].origin;
                start_locations[target_index].angles = start_locations[switch_index].angles;
                machines[i].origin = temp_origin;
                machines[i].angles = temp_angles;
                start_locations[switch_index].origin = temp_origin;
                start_locations[switch_index].angles = temp_angles;
                j = i;
            }

            level.first_time_opening_perk_hut = 0;
        }
    }

    playsoundatposition( "rando_start", machines[j].origin );
    origin = machines[j].origin;

    if ( level.vending_model_info.size > 1 )
    {
        playfxontag( level._effect["zombie_perk_start"], machines[j], "tag_origin" );
        playsoundatposition( "rando_perk", machines[j].origin );
    }
    else
    {
        playfxontag( level._effect["zombie_perk_4th"], machines[j], "tag_origin" );
        playsoundatposition( "rando_perk", machines[j].origin );
    }

    true_model = machines[j].model;
    machines[j] setmodel( true_model );
    machines[j] show();
    floatheight = 40;
    level thread play_sound_2d( "perk_lottery" );
    machines[j] moveto( origin + ( 0, 0, floatheight ), 5, 3, 0.5 );
    tag_fx = spawn( "script_model", machines[j].origin + vectorscale( ( 0, 0, 1 ), 40.0 ) );
    tag_fx setmodel( "tag_origin" );
    tag_fx linkto( machines[j] );
    modelindex = 0;
    machines[j] vibrate( machines[j].angles, 2, 1, 4 );

    for ( i = 0; i < 30; i++ )
    {
        wait 0.15;

        if ( level.vending_model_info.size > 1 )
        {
            while ( !isdefined( level.vending_model_info[modelindex] ) )
            {
                modelindex++;

                if ( modelindex == 4 )
                    modelindex = 0;
            }

            modelname = level.vending_model_info[modelindex];
            machines[j] setmodel( modelname );
            playfxontag( level._effect["zombie_perk_flash"], tag_fx, "tag_origin" );
            modelindex++;

            if ( modelindex == 4 )
                modelindex = 0;
        }
    }

    modelname = true_model;
    machines[j] setmodel( modelname );
    machines[j] moveto( origin, 0.3, 0.3, 0 );
    playfxontag( level._effect["zombie_perk_end"], machines[j], "tag_origin" );
    playsoundatposition( "perks_rattle", machines[j].origin );
    activate_vending_machine( true_model, origin, machines[j] );
}
