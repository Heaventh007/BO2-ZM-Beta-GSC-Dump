// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm;

initzipline()
{
    zipbuytrigger = getentarray( "zipline_buy_trigger", "targetname" );
    nonstatictrig = undefined;
    statictrig = undefined;
    level.direction = undefined;
    level.znodes = [];
    level.zrnodes = [];
    level.zipinuse = 0;
    level thread zombie_dog_collision();

    for ( i = 0; i < zipbuytrigger.size; i++ )
    {
        zipbuytrigger[i].zip = getent( zipbuytrigger[i].target, "targetname" );
        zipbuytrigger[i].attachspot = getentarray( zipbuytrigger[i].zip.target, "targetname" );
        zipbuytrigger[i].blocker = getent( "zipline_blocker", "targetname" );
        zipbuytrigger[i].aiblocker = getent( "zipline_ai_blocker", "targetname" );
        zipbuytrigger[i].tempclip = getentarray( "zip_temp_clip", "targetname" );
        zipbuytrigger[i].handle = getent( "zip_handle", "targetname" );
        zipbuytrigger[i].handlebox = getent( "zip_handle_box", "targetname" );
        zipbuytrigger[i].lever = getent( "zip_lever", "targetname" );

        for ( p = 0; p < zipbuytrigger[i].attachspot.size; p++ )
        {
            if ( isdefined( zipbuytrigger[i].attachspot[p].script_noteworthy ) && zipbuytrigger[i].attachspot[p].script_noteworthy == "main_spot" )
            {
                zipbuytrigger[i].volume = getent( zipbuytrigger[i].attachspot[p].target, "targetname" );
                zipbuytrigger[i].zipdamagetrigger = getent( zipbuytrigger[i].volume.target, "targetname" );
                zipbuytrigger[i].zipdamagevolume = getent( zipbuytrigger[i].zipdamagetrigger.target, "targetname" );
                zipbuytrigger[i].spline = getent( zipbuytrigger[i].zipdamagevolume.target, "targetname" );
            }
        }

        if ( isdefined( zipbuytrigger[i].script_noteworthy ) && zipbuytrigger[i].script_noteworthy == "nonstatic" )
            nonstatictrig = zipbuytrigger[i];
        else if ( isdefined( zipbuytrigger[i].script_noteworthy ) && zipbuytrigger[i].script_noteworthy == "static" )
            statictrig = zipbuytrigger[i];

        level.znodes = getentarray( "zipline_nodes", "script_noteworthy" );
        level.zrnodes = [];
        zipbuytrigger[i] setcursorhint( "HINT_NOICON" );
    }

    nonstatictrig enablelinkto();
    nonstatictrig linkto( nonstatictrig.zip );
    statictrig trigger_off();
    zipbuytrigger[0].volume enablelinkto();
    zipbuytrigger[0].volume linkto( zipbuytrigger[0].zip );
    zipbuytrigger[0].zipdamagetrigger enablelinkto();
    zipbuytrigger[0].zipdamagetrigger linkto( zipbuytrigger[0].zip );
    zipbuytrigger[0].zipdamagevolume enablelinkto();
    zipbuytrigger[0].zipdamagevolume linkto( zipbuytrigger[0].zip );

    for ( i = 0; i < zipbuytrigger[0].attachspot.size; i++ )
        zipbuytrigger[0].attachspot[i] linkto( zipbuytrigger[0].zip );

    for ( i = 0; i < zipbuytrigger[0].tempclip.size; i++ )
        zipbuytrigger[0].tempclip[i] linkto( zipbuytrigger[0].zip );

    zipbuytrigger[0].handlebox linkto( zipbuytrigger[0].zip );
    zipbuytrigger[0].handle.angles = vectorscale( ( 0, -1, 0 ), 19.6 );
    zippowertrigger = getent( "zip_lever_trigger", "targetname" );
    zippowertrigger.lever = getent( zippowertrigger.target, "targetname" );
    zippowertrigger sethintstring( &"ZOMBIE_ZIPLINE_ACTIVATE" );
    zippowertrigger setcursorhint( "HINT_NOICON" );
    zippowertrigger waittill( "trigger", who );
    ziphintdeactivated = getent( "zipline_deactivated_hint_trigger", "targetname" );
    ziphintdeactivated delete();
    zippowertrigger thread recallzipswitch( 180 );
    zippowertrigger waittill( "recallLeverDone" );

    if ( !is_german_build() )
        who thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "level", "zipline" );

    zippowertrigger delete();
    statictrig thread activatezip( undefined );
    statictrig waittill( "zipDone" );
    statictrig playsound( "platform_bang" );
    zipbuytrigger[0].blocker connectpaths();
    zipbuytrigger[0].blocker notsolid();
    play_sound_at_pos( "door_rotate_open", zipbuytrigger[0].blocker.origin );
    zipbuytrigger[0].blocker rotateyaw( 80, 1 );
    zipbuytrigger[0].blocker waittill( "rotatedone" );
    zipbuytrigger[0].blocker thread objectsolid();
    waittime = 40;
/#
    if ( getdvarint( #"_id_FA81816F" ) > 0 )
        waittime = 5;
#/
    wait( waittime );
    statictrig thread recallzipswitch( -180 );
    statictrig waittill( "recallLeverDone" );
    array_thread( zipbuytrigger, ::zipthink );
}

zip_rope_audio()
{
    zip_rope = getentarray( "zip_line_rope", "targetname" );

    for ( i = 0; i < zip_rope.size; i++ )
    {
        if ( isdefined( zip_rope[i].script_sound ) )
            zip_rope[i] thread rope_sounds();
    }
}

zip_line_audio()
{
    level thread zip_rope_audio();
    zip_audio = getentarray( "zip_line_wheel", "targetname" );

    for ( i = 0; i < zip_audio.size; i++ )
    {
        if ( isdefined( zip_audio[i].script_label ) )
            zip_audio[i] playsound( zip_audio[i].script_label );

        if ( isdefined( zip_audio[i].script_sound ) )
            zip_audio[i] playloopsound( zip_audio[i].script_sound, 1 );

        zip_audio[i] thread zip_line_stopsound();
    }
}

rope_sounds()
{
    level endon( "machine_off" );

    while ( true )
    {
        wait( randomfloatrange( 0.3, 0.8 ) );
        self playsound( self.script_sound );
    }
}

zip_line_stopsound()
{
    level waittill( "machine_off" );
    self stoploopsound( 0.1 );

    if ( isdefined( self.script_label ) )
        self playsound( "motor_stop_left" );
}

recallzipswitch( dir )
{
    self.lever rotatepitch( dir, 0.5 );
    org = getent( "zip_line_switch", "targetname" );

    if ( isdefined( org ) )
    {
        play_sound_at_pos( "purchase", org.origin );
        org playsound( "switch" );
    }

    self.lever waittill( "rotatedone" );
    self notify( "recallLeverDone" );
}

zipthink()
{
    self sethintstring( &"ZOMBIE_ZIPLINE_USE" );
    self setcursorhint( "HINT_NOICON" );
    self.zombie_cost = 1500;
    zipbuytrigger = getentarray( "zipline_buy_trigger", "targetname" );

    if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "nonstatic" )
    {
        self.triggeron = 1;
        self unlink();
        self thread monitorziphint();
    }

    while ( true )
    {
        self waittill( "trigger", who );

        if ( who in_revive_trigger() )
            continue;

        if ( is_player_valid( who ) )
        {
            if ( who.score >= self.zombie_cost )
            {
                if ( !level.zipinuse )
                {
                    if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "nonstatic" && who istouching( self.volume ) || isdefined( self.script_noteworthy ) && self.script_noteworthy == "static" )
                    {
                        level.zipinuse = 1;

                        for ( i = 0; i < zipbuytrigger.size; i++ )
                        {
                            if ( isdefined( zipbuytrigger[i].script_noteworthy ) && zipbuytrigger[i].script_noteworthy == "nonstatic" )
                            {
                                zipbuytrigger[i] notify( "stopstringmonitor" );
                                zipbuytrigger[i] linkto( zipbuytrigger[i].zip );
                                zipbuytrigger[i] sethintstring( "" );
                                continue;
                            }

                            if ( isdefined( zipbuytrigger[i].script_noteworthy ) && zipbuytrigger[i].script_noteworthy == "static" && !isdefined( level.direction ) )
                                zipbuytrigger[i] trigger_off();
                        }

                        play_sound_at_pos( "purchase", who.origin );

                        if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "static" )
                        {
                            self thread recallzipswitch( 180 );
                            self waittill( "recallLeverDone" );
                        }

                        who maps\mp\zombies\_zm_score::minus_to_player_score( self.zombie_cost );

                        if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "nonstatic" )
                            self thread activatezip( who );
                        else if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "static" )
                            self thread activatezip( undefined );

                        self waittill( "zipDone" );

                        if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "nonstatic" )
                        {
                            self unlink();
                            self triggeroffsumpf();
                        }

                        waittime = 40;
/#
                        if ( getdvarint( #"_id_FA81816F" ) > 0 )
                            waittime = 5;
#/
                        wait( waittime );

                        if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "static" )
                        {
                            self thread recallzipswitch( -180 );
                            self waittill( "recallLeverDone" );
                        }

                        for ( i = 0; i < zipbuytrigger.size; i++ )
                        {
                            if ( isdefined( zipbuytrigger[i].script_noteworthy ) && zipbuytrigger[i].script_noteworthy == "nonstatic" )
                            {
                                zipbuytrigger[i] sethintstring( &"ZOMBIE_ZIPLINE_USE" );
                                zipbuytrigger[i] setcursorhint( "HINT_NOICON" );
                                zipbuytrigger[i] triggeron();
                                zipbuytrigger[i] thread monitorziphint();
                            }

                            if ( isdefined( zipbuytrigger[i].script_noteworthy ) && zipbuytrigger[i].script_noteworthy == "static" && !isdefined( level.direction ) )
                                zipbuytrigger[i] trigger_on();
                        }

                        level.zipinuse = 0;
                    }
                }
            }
        }
    }
}

triggeronsumpf()
{
    if ( isdefined( self.triggeron ) && !self.triggeron )
    {
        self.origin = ( self.origin[0], self.origin[1], self.origin[2] + 10000 );
        self.triggeron = 1;
    }
}

triggeroffsumpf()
{
    if ( isdefined( self.triggeron ) && self.triggeron )
    {
        self.origin = ( self.origin[0], self.origin[1], self.origin[2] - 10000 );
        self.triggeron = 0;
    }
}

monitorziphint()
{
    self endon( "stopstringmonitor" );

    while ( true )
    {
        players = get_players();
        downedplayers = [];
        aliveplayers = [];
        stoptrigger = 0;

        for ( i = 0; i < players.size; i++ )
        {
            if ( players[i] maps\mp\zombies\_zm_laststand::player_is_in_laststand() && players[i] istouching( self.volume ) )
            {
                downedplayers[downedplayers.size] = players[i];
                continue;
            }

            if ( isdefined( players[i] ) && isalive( players[i] ) )
                aliveplayers[aliveplayers.size] = players[i];
        }

        if ( aliveplayers.size > 0 && downedplayers.size > 0 )
        {
            for ( i = 0; i < aliveplayers.size; i++ )
            {
                for ( p = 0; p < downedplayers.size; p++ )
                {
                    if ( aliveplayers[i] istouching( downedplayers[p].revivetrigger ) )
                    {
                        stoptrigger = 1;
                        break;
                    }
                }

                if ( stoptrigger )
                    break;
            }
        }

        if ( stoptrigger )
            self triggeroffsumpf();
        else
            self triggeronsumpf();

        wait 1;
    }
}

array_remove( a_array, e_ent )
{
    a_temp = [];
    removed_index = undefined;

    for ( i = 0; i < a_array.size; i++ )
    {
        if ( a_array[i] == e_ent )
            removed_index = i;
    }

    for ( i = 0; i < a_array.size; i++ )
    {
        if ( i < removed_index )
        {
            if ( a_array[i] != e_ent )
                a_temp[a_temp.size] = a_array[i];

            continue;
        }

        a_temp[a_temp.size] = a_array[i + 1];
    }

    return a_temp;
}

activatezip( rider )
{
    zombs = getaispeciesarray( "axis" );
    self.riders = [];
    self.canshock = 0;

    for ( i = 0; i < zombs.size; i++ )
    {
        if ( isdefined( zombs[i] ) && isalive( zombs[i] ) && zombs[i] istouching( self.zipdamagevolume ) )
        {
            if ( zombs[i].isdog )
                zombs[i].a.nodeath = 1;
            else
                zombs[i] startragdoll();

            zombs[i] dodamage( zombs[i].health + 600, zombs[i].origin );
        }
    }

    level thread zip_line_audio();
    attachspot = getentarray( self.zip.target, "targetname" );
    peeps = get_players();

    for ( i = 0; i < peeps.size; i++ )
    {
        if ( is_player_valid( peeps[i] ) && ( peeps[i] istouching( self.volume ) || isdefined( rider ) && peeps[i] == rider ) )
        {
            self.riders[self.riders.size] = peeps[i];
            peeps[i] thread magic_bullet_shield();
            peeps[i].on_zipline = 1;
            peeps[i] setstance( "stand" );
            peeps[i] allowcrouch( 0 );
            peeps[i] allowprone( 0 );
            prevdist = undefined;
            playerspot = undefined;
            playerorg = peeps[i] getorigin();

            for ( p = 0; p < attachspot.size; p++ )
            {
                attachorg = attachspot[p] getorigin();
                dist = distance2d( playerorg, attachorg );

                if ( !isdefined( prevdist ) )
                {
                    prevdist = dist;
                    playerspot = attachspot[p];
                    continue;
                }

                if ( dist <= prevdist )
                {
                    prevdist = dist;
                    playerspot = attachspot[p];
                }
            }

            peeps[i] playerlinkto( playerspot, undefined, 0.0, 180, 180, 180, 180, 1 );
            attachspot = array_remove( attachspot, playerspot );
        }
    }

    for ( i = 0; i < self.tempclip.size; i++ )
        self.tempclip[i] notify( "stopmonitorsolid" );

    wait 0.1;

    for ( i = 0; i < self.tempclip.size; i++ )
        self.tempclip[i] notsolid();

    if ( attachspot.size > 0 )
    {
        center = ( 0, 0, 0 );

        for ( i = 0; i < attachspot.size; i++ )
            center = center + attachspot[i] getorigin();

        center = center / attachspot.size;
        physicsexplosionsphere( center, 128, 64, 2 );
    }

    self.handle notify( "stopmonitorsolid" );
    self.handle notsolid();
    self.handle unlink();

    if ( !isdefined( level.direction ) )
        self.handle rotateto( ( 0, -19.6, -65 ), 0.5 );
    else
        self.handle rotateto( ( 0, -19.6, 65 ), 0.5 );

    self.handle waittill( "rotatedone" );
    self.handle thread objectsolid();
    self.handle linkto( self.zip );
    self.zipdamagetrigger thread zipdamage( self );
    self.zipactive = 1;
    self thread spinzippulleys();

    if ( !isdefined( level.direction ) )
    {
        self.aiblocker solid();
        self.aiblocker disconnectpaths();

        for ( i = 0; i < self.riders.size; i++ )
            self.riders[i] thread maps\mp\zombies\_zm::store_crumb( ( 11216, 2883, -648 ) );

        curnode = self.spline;
        level.zrnodes[level.znodes.size - 1] = curnode;
        my_time = 0.3;

        for ( i = 0; i < level.znodes.size - 1; i++ )
        {
            curnode = getent( curnode.target, "targetname" );
            level.zrnodes[level.znodes.size - ( i + 2 )] = curnode;
            self.zip moveto( curnode.origin, my_time );

            if ( i == 3 )
                self.canshock = 1;

            if ( i == 23 )
                self.canshock = 0;

            if ( i > level.znodes.size * 0.666 )
                my_time = my_time + 0.017;
            else if ( i < level.znodes.size * 0.333 )
                my_time = my_time - 0.017;

            wait( my_time - 0.022 );
        }

        self.zip waittill( "movedone" );
        level notify( "machine_done" );
        level.direction = "back";
    }
    else
    {
        for ( i = 0; i < self.riders.size; i++ )
            self.riders[i] thread maps\mp\zombies\_zm::store_crumb( ( 10750, 1516, -501 ) );

        my_time = 0.3;

        for ( i = 1; i < level.zrnodes.size; i++ )
        {
            curnode = level.zrnodes[i];
            self.zip moveto( curnode.origin, my_time );

            if ( i == 4 )
                self.canshock = 1;

            if ( i == 23 )
                self.canshock = 0;

            if ( i > level.znodes.size * 0.666 )
                my_time = my_time + 0.017;
            else if ( i < level.znodes.size * 0.333 )
                my_time = my_time - 0.017;

            wait( my_time - 0.022 );
        }

        self.zip waittill( "movedone" );
        self.aiblocker connectpaths();
        self.aiblocker notsolid();
        level.direction = undefined;
    }

    for ( i = 0; i < self.tempclip.size; i++ )
    {
        if ( !isdefined( level.direction ) && isdefined( self.tempclip[i].script_noteworthy ) && self.tempclip[i].script_noteworthy == "zip_base" )
        {
            self.tempclip[i] solid();
            continue;
        }

        self.tempclip[i] thread objectsolid();
    }

    level notify( "machine_off" );
    self playsound( "platform_bang" );
    self.zipactive = 0;
    wait 0.1;

    for ( i = 0; i < self.riders.size; i++ )
    {
        self.riders[i] unlink();
        self.riders[i] stop_magic_bullet_shield();
        self.riders[i] thread maps\mp\zombies\_zm::store_crumb( self.origin );
        self.riders[i].on_zipline = 0;
        self.riders[i] allowcrouch( 1 );
        self.riders[i] allowprone( 1 );
    }

    self.handle unlink();
    self.handle rotateto( vectorscale( ( 0, -1, 0 ), 19.6 ), 0.5 );
    self.handle waittill( "rotatedone" );
    self.handle thread objectsolid();
    self.handle linkto( self.zip );
    self player_collision_fix();
    self notify( "zipDone" );
}

zipdamage( parent )
{
    while ( true )
    {
        self waittill( "trigger", ent );

        if ( parent.zipactive == 1 && isdefined( ent ) && isalive( ent ) )
        {
            if ( isplayer( ent ) )
                ent thread playerzipdamage( parent );
            else
                ent thread zombiezipdamage();
        }
    }
}

playerzipdamage( parent )
{
    self endon( "death" );
    self endon( "disconnect" );
    players = get_players();

    for ( i = 0; i < parent.riders.size; i++ )
    {
        if ( self == parent.riders[i] )
            return;
    }

    if ( !isdefined( self.zipshock ) && !self maps\mp\zombies\_zm_laststand::player_is_in_laststand() && parent.canshock == 1 )
    {
        self.zipshock = 1;
        self shellshock( "death", 3 );
        wait 2;
        self.zipshock = undefined;
    }
}

zombiezipdamage()
{
    self endon( "death" );

    if ( self.isdog )
        self.a.nodeath = 1;
    else
        self startragdoll();

    self dodamage( self.health + 600, self.origin );
}

objectsolid()
{
    self endon( "stopmonitorsolid" );

    while ( true )
    {
        players = get_players();
        player_touching = 0;

        for ( i = 0; i < players.size; i++ )
        {
            if ( players[i] istouching( self ) )
            {
                player_touching = 1;
                break;
            }
        }

        if ( !player_touching )
        {
            self solid();
            return;
        }

        wait 0.5;
    }
}

spinzippulleys()
{
    pulleys = getentarray( "zip_pulley", "targetname" );

    for ( i = 0; i < pulleys.size; i++ )
        pulleys[i] rotateyaw( 1800, 4.8 );
}

player_collision_fix()
{
    assert( isdefined( self ) );
    assert( isdefined( self.tempclip ) );

    if ( isdefined( level.direction ) )
        return;

    base = undefined;

    for ( i = 0; i < self.tempclip.size; i++ )
    {
        clip = self.tempclip[i];

        if ( isdefined( clip.script_noteworthy ) && clip.script_noteworthy == "zip_base" )
        {
            base = clip;
            break;
        }
    }

    assert( isdefined( base ) );
    z = base.origin[2];
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        player = players[i];

        if ( !is_player_valid( player ) )
            continue;

        if ( !player istouching( base ) )
            continue;

        if ( player.origin[2] < z )
        {
            offset = z + 6;
            origin = ( player.origin[0], player.origin[1], offset );
            player setorigin( origin );
        }
    }
}

zombie_dog_collision()
{
    collision = getentarray( "zombie_dog_clip", "targetname" );

    for ( i = 0; i < collision.size; i++ )
        collision[i] delete();
}
