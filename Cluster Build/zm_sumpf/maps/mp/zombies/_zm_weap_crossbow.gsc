// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\animscripts\zm_shared;

init()
{
    if ( !maps\mp\zombies\_zm_weapons::is_weapon_included( "crossbow_explosive_zm" ) )
        return;

    loadfx( "weapon/crossbow/fx_trail_crossbow_blink_grn_os" );
    loadfx( "weapon/crossbow/fx_trail_crossbow_blink_red_os" );
    onplayerconnect_callback( ::crossbow_on_player_connect );
}

crossbow_on_player_connect()
{
    self thread watch_for_monkey_bolt();
}

watch_for_monkey_bolt()
{
    self endon( "death" );
    self endon( "disconnect" );

    for (;;)
    {
        self waittill( "grenade_fire", grenade, weaponname, parent );

        if ( isdefined( level.zombiemode_cross_bow_fired ) )
            level thread [[ level.zombiemode_cross_bow_fired ]]( grenade, weaponname, parent, self );

        switch ( weaponname )
        {
            case "explosive_bolt_upgraded_zm":
                grenade thread crossbow_monkey_bolt( self );
                break;
        }
    }
}

crossbow_monkey_bolt( player_who_fired )
{
    level thread monkey_bolt_cleanup( self );
    attract_dist_diff = level.monkey_attract_dist_diff;

    if ( !isdefined( attract_dist_diff ) )
        attract_dist_diff = 45;

    num_attractors = level.num_monkey_attractors;

    if ( !isdefined( num_attractors ) )
        num_attractors = 96;

    max_attract_dist = level.monkey_attract_dist;

    if ( !isdefined( max_attract_dist ) )
        max_attract_dist = 1536;

    if ( isdefined( level.monkey_bolt_holder ) )
    {
        is_player = isplayer( level.monkey_bolt_holder );

        if ( is_player || is_true( level.monkey_bolt_holder.can_move_with_bolt ) )
        {
            self create_zombie_point_of_interest( max_attract_dist, num_attractors, 10000, 1 );
            valid_poi = maps\mp\zombies\_zm_utility::check_point_in_enabled_zone( self.origin, undefined, undefined );

            if ( !valid_poi )
                valid_poi = check_point_in_playable_area( self.origin );

            if ( valid_poi )
            {

            }
            else
                player_who_fired.script_noteworthy = undefined;
        }
        else if ( isai( level.monkey_bolt_holder ) )
        {
            level thread wait_for_monkey_bolt_holder_to_die( self, level.monkey_bolt_holder );

            if ( is_true( level.monkey_bolt_holder.is_traversing ) )
                level.monkey_bolt_holder waittill( "zombie_end_traverse" );

            if ( isalive( level.monkey_bolt_holder ) )
                level.monkey_bolt_holder thread monkey_bolt_taunts( self );
            else if ( !isdefined( self ) )
            {
                player_who_fired.script_noteworthy = undefined;
                return;
            }

            self create_zombie_point_of_interest( max_attract_dist, num_attractors, 10000, 1 );
            valid_poi = maps\mp\zombies\_zm_utility::check_point_in_enabled_zone( self.origin, undefined, undefined );

            if ( !valid_poi )
                valid_poi = check_point_in_playable_area( self.origin );

            if ( valid_poi )
                self thread create_zombie_point_of_interest_attractor_positions( 4, attract_dist_diff );
            else
                player_who_fired.script_noteworthy = undefined;
        }
    }
    else
    {
        valid_poi = maps\mp\zombies\_zm_utility::check_point_in_enabled_zone( self.origin, undefined, undefined );

        if ( !valid_poi )
            valid_poi = check_point_in_playable_area( self.origin );

        if ( !valid_poi && is_true( level.use_alternate_poi_positioning ) )
        {
            bkwd = anglestoforward( self.angles ) * -20;
            new_pos = self.origin + bkwd + vectorscale( ( 0, 0, -1 ), 50.0 );
            valid_poi = check_point_in_playable_area( new_pos );

            if ( valid_poi )
            {
                alt_poi = spawn( "script_origin", new_pos );
                alt_poi create_zombie_point_of_interest( max_attract_dist, num_attractors, 10000, 1 );
                alt_poi thread create_zombie_point_of_interest_attractor_positions( 4, attract_dist_diff );
                alt_poi thread wait_for_bolt_death( self );
                return;
            }
        }

        if ( valid_poi )
        {
            self create_zombie_point_of_interest( max_attract_dist, num_attractors, 10000, 1 );
            self thread create_zombie_point_of_interest_attractor_positions( 4, attract_dist_diff );
        }
        else
            player_who_fired.script_noteworthy = undefined;
    }
}

wait_for_bolt_death( bolt )
{
    bolt waittill( "death" );
    self delete();
}

wait_for_monkey_bolt_holder_to_die( bolt, zombie )
{
    bolt endon( "death" );
    zombie waittill( "death" );

    if ( !isdefined( level.delete_monkey_bolt_on_zombie_holder_death ) || !zombie [[ level.delete_monkey_bolt_on_zombie_holder_death ]]() )
        return;

    if ( isdefined( bolt ) )
        bolt delete();
}

monkey_bolt_taunts( ent_grenade )
{
    self endon( "death" );

    if ( isdefined( self.monkey_bolt_taunts ) && self [[ self.monkey_bolt_taunts ]]( ent_grenade ) )
        return;
    else if ( self.isdog || !self.has_legs )
        return;
    else if ( isdefined( self.animname ) && self.animname == "thief_zombie" )
        return;
    else if ( isdefined( self.in_the_ceiling ) && self.in_the_ceiling )
        return;

    while ( isdefined( ent_grenade ) )
    {
        if ( isdefined( level._zombie_board_taunt[self.animname] ) )
        {
            taunt_anim = random( level._zombie_board_taunt[self.animname] );

            if ( self.animname == "zombie" )
                self thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( "taunt", self.animname );

            if ( !isalive( self ) )
                return;

            self.allowdeath = 1;
            self animscripted( self.origin, self.angles, "zm_taunt" );

            if ( !isalive( self ) )
                return;

            self maps\mp\animscripts\zm_shared::donotetracks( "taunt_anim" );
        }

        wait 0.05;
    }

    level.monkey_bolt_holder = undefined;
}

monkey_bolt_cleanup( ent_grenade )
{
    while ( isdefined( ent_grenade ) )
        wait 0.1;

    if ( isdefined( level.monkey_bolt_holder ) )
        level.monkey_bolt_holder = undefined;
}
