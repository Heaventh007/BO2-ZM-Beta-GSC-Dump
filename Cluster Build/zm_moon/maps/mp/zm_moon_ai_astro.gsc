// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\zm_moon_distance_tracking;
#include maps\mp\zombies\_zm_audio;

init()
{
    level.astro_zombie_enter_level = ::moon_astro_enter_level;
}

zombie_set_fake_playername()
{
    self setzombiename( "SpaceZom" );
}

moon_astro_enter_level()
{
    self endon( "death" );
    self hide();
    self.entered_level = 1;
    astro_struct = self moon_astro_get_spawn_struct();

    if ( isdefined( astro_struct ) )
    {
        self forceteleport( astro_struct.origin, astro_struct.angles );
        wait_network_frame();
    }

    playfx( level._effect["astro_spawn"], self.origin );
    self playsound( "zmb_hellhound_bolt" );
    self playsound( "zmb_hellhound_spawn" );
    playrumbleonposition( "explosion_generic", self.origin );
    self playloopsound( "zmb_zombie_astronaut_loop", 1 );
    self thread play_line_if_player_can_see();
    self zombie_set_fake_playername();
    wait_network_frame();
    self show();
}

play_line_if_player_can_see()
{
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( distancesquared( self.origin, players[i].origin ) <= 640000 )
        {
            cansee = self maps\mp\zm_moon_distance_tracking::player_can_see_me( players[i] );

            if ( cansee )
            {
                players[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "astro_spawn" );
                return;
            }
        }
    }
}

moon_astro_get_spawn_struct()
{
    keys = getarraykeys( level.zones );

    for ( i = 0; i < level.zones.size; i++ )
    {
        if ( keys[i] == "nml_zone" )
            continue;

        if ( level.zones[keys[i]].is_occupied )
        {
            locs = getstructarray( level.zones[keys[i]].volumes[0].target + "_astro", "targetname" );

            if ( isdefined( locs ) && locs.size > 0 )
            {
                locs = array_randomize( locs );
                return locs[0];
            }
        }
    }

    for ( i = 0; i < level.zones.size; i++ )
    {
        if ( keys[i] == "nml_zone" )
            continue;

        if ( level.zones[keys[i]].is_active )
        {
            locs = getstructarray( level.zones[keys[i]].volumes[0].target + "_astro", "targetname" );

            if ( isdefined( locs ) && locs.size > 0 )
            {
                locs = array_randomize( locs );
                return locs[0];
            }
        }
    }

    return undefined;
}
