// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_blockers;
#include maps\mp\zombies\_zm_hackables_doors;
#include maps\mp\zm_moon_utility;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm;
#include maps\mp\zm_moon_gravity;
#include maps\mp\zm_moon_amb;

init_zombie_airlocks()
{
    airlock_buys = getentarray( "zombie_airlock_buy", "targetname" );

    for ( i = 0; i < airlock_buys.size; i++ )
        airlock_buys[i] thread airlock_buy_init();

    level thread maps\mp\zombies\_zm_hackables_doors::hack_doors( "zombie_airlock_hackable", maps\mp\zm_moon_utility::moon_door_opened );
    airlock_hacks = getentarray( "zombie_airlock_hackable", "targetname" );

    for ( i = 0; i < airlock_hacks.size; i++ )
        airlock_hacks[i] thread airlock_hack_init();

    airlock_doors = getentarray( "zombie_door_airlock", "script_noteworthy" );

    for ( i = 0; i < airlock_doors.size; i++ )
        airlock_doors[i] thread airlock_init();

    level thread init_door_sounds();
    level thread zombie_moon_receiving_hatch_init();
    level thread moon_glass_breach_init();
}

init_door_sounds()
{
    maps\mp\zombies\_zm_utility::add_sound( "lab_door", "zmb_lab_door_slide" );
    maps\mp\zombies\_zm_utility::add_sound( "electric_metal_big", "zmb_heavy_door_open" );
}

airlock_hack_init()
{
    self.type = undefined;

    if ( isdefined( self.script_flag ) && !isdefined( level.flag[self.script_flag] ) )
    {
        if ( isdefined( self.script_flag ) )
        {
            tokens = strtok( self.script_flag, "," );

            for ( i = 0; i < tokens.size; i++ )
                flag_init( self.script_flag );
        }
    }

    self.trigs = [];
    targets = getentarray( self.target, "targetname" );

    for ( i = 0; i < targets.size; i++ )
    {
        self.trigs[self.trigs.size] = targets[i];

        if ( isdefined( targets[i].classname ) && targets[i].classname == "trigger_multiple" )
            targets[i] trigger_off();
    }

    self setcursorhint( "HINT_NOICON" );
    self.script_noteworthy = "default";
    self sethintstring( &"ZOMBIE_EQUIP_HACKER" );
}

airlock_buy_init()
{
    self.type = undefined;

    if ( isdefined( self.script_flag ) && !isdefined( level.flag[self.script_flag] ) )
    {
        if ( isdefined( self.script_flag ) )
        {
            tokens = strtok( self.script_flag, "," );

            for ( i = 0; i < tokens.size; i++ )
                flag_init( self.script_flag );
        }
    }

    self.trigs = [];
    targets = getentarray( self.target, "targetname" );

    for ( i = 0; i < targets.size; i++ )
    {
        self.trigs[self.trigs.size] = targets[i];

        if ( isdefined( targets[i].classname ) && targets[i].classname == "trigger_multiple" )
            targets[i] trigger_off();
    }

    self setcursorhint( "HINT_NOICON" );

    if ( isdefined( self.script_noteworthy ) && ( self.script_noteworthy == "electric_door" || self.script_noteworthy == "electric_buyable_door" ) )
        self sethintstring( &"ZOMBIE_NEED_POWER" );
    else
        self.script_noteworthy = "default";

    self thread airlock_buy_think();
}

airlock_buy_think()
{
    self endon( "kill_door_think" );
    cost = 1000;

    if ( isdefined( self.zombie_cost ) )
        cost = self.zombie_cost;

    while ( true )
    {
        switch ( self.script_noteworthy )
        {
            case "electric_door":
                flag_wait( "power_on" );
                break;
            case "electric_buyable_door":
                flag_wait( "power_on" );
                self set_hint_string( self, "default_buy_door_" + cost );

                if ( !self airlock_buy() )
                    continue;

                break;
            default:
                self set_hint_string( self, "default_buy_door_" + cost );

                if ( !self airlock_buy() )
                    continue;

                self moon_door_opened();
                break;
        }
    }
}

moon_door_opened()
{
    self notify( "door_opened" );

    if ( isdefined( self.script_flag ) )
    {
        tokens = strtok( self.script_flag, "," );

        for ( i = 0; i < tokens.size; i++ )
            flag_set( tokens[i] );
    }

    for ( i = 0; i < self.trigs.size; i++ )
    {
        self.trigs[i] thread trigger_on();
        self.trigs[i] thread change_door_models();
    }

    play_sound_at_pos( "purchase", self.origin );
    all_trigs = getentarray( self.target, "target" );

    for ( i = 0; i < all_trigs.size; i++ )
        all_trigs[i] trigger_off();
}

change_door_models()
{
    doors = getentarray( self.target, "targetname" );

    for ( i = 0; i < doors.size; i++ )
    {
        if ( isdefined( doors[i].model ) && doors[i].model == "p_zom_moon_lab_airlock_door01_left_locked" )
            doors[i] setmodel( "p_zom_moon_lab_airlock_door01_left" );
        else if ( isdefined( doors[i].model ) && doors[i].model == "p_zom_moon_lab_airlock_door01_right_locked" )
            doors[i] setmodel( "p_zom_moon_lab_airlock_door01_right" );
        else if ( isdefined( doors[i].model ) && doors[i].model == "p_zom_moon_mine_airlock_door03_single_locked" )
            doors[i] setmodel( "p_zom_moon_mine_airlock_door03_single" );

        doors[i] thread airlock_connect_paths();
    }
}

airlock_connect_paths()
{
    if ( self.classname == "script_brushmodel" )
    {
        self notsolid();
        self connectpaths();

        if ( !isdefined( self._door_open ) || self._door_open == 0 )
            self solid();
    }
}

airlock_buy()
{
    self waittill( "trigger", who, force );

    if ( getdvarint( #"zombie_unlock_all" ) > 0 || is_true( force ) )
        return true;

    if ( !who usebuttonpressed() )
        return false;

    if ( who in_revive_trigger() )
        return false;

    if ( is_player_valid( who ) )
    {
        players = get_players();

        if ( who.score >= self.zombie_cost )
            who maps\mp\zombies\_zm_score::minus_to_player_score( self.zombie_cost );
        else
        {
            play_sound_at_pos( "no_purchase", self.origin );
            who maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "door_deny", undefined, 0 );
            return false;
        }
    }

    return true;
}

airlock_init()
{
    self.type = undefined;
    self._door_open = 0;
    targets = getentarray( self.target, "targetname" );
    self.doors = [];

    for ( i = 0; i < targets.size; i++ )
    {
        targets[i] maps\mp\zombies\_zm_blockers::door_classify( self );
        targets[i].startpos = targets[i].origin;
    }

    self thread airlock_think();
}

airlock_think()
{
    while ( true )
    {
        self waittill( "trigger", who );

        if ( isdefined( self.doors[0].startpos ) && self.doors[0].startpos != self.doors[0].origin )
            continue;

        for ( i = 0; i < self.doors.size; i++ )
            self.doors[i] thread airlock_activate( 0.25, 1 );

        self._door_open = 1;

        while ( self moon_airlock_occupied() || isdefined( self.doors[0].door_moving ) && self.doors[0].door_moving == 1 )
            wait 0.1;

        self thread door_clean_up_corpses();

        for ( i = 0; i < self.doors.size; i++ )
            self.doors[i] thread airlock_activate( 0.25, 0 );

        self._door_open = 0;
    }
}

airlock_activate( time, open )
{
    if ( !isdefined( time ) )
        time = 1;

    if ( !isdefined( open ) )
        open = 1;

    if ( isdefined( self.door_moving ) )
        return;

    self.door_moving = 1;
    self notsolid();

    if ( self.classname == "script_brushmodel" )
    {
        if ( open )
            self connectpaths();
    }

    if ( isdefined( self.script_sound ) )
    {
        if ( open )
            self playsound( "zmb_airlock_open" );
        else
            self playsound( "zmb_airlock_close" );
    }

    scale = 1;

    if ( !open )
        scale = -1;

    switch ( self.script_string )
    {
        case "slide_apart":
            if ( isdefined( self.script_vector ) )
            {
                vector = vectorscale( self.script_vector, scale );

                if ( open )
                {
                    if ( isdefined( self.startpos ) )
                        self moveto( self.startpos + vector, time );
                    else
                        self moveto( self.origin + vector, time );

                    self._door_open = 1;
                }
                else
                {
                    if ( isdefined( self.startpos ) )
                        self moveto( self.startpos, time );
                    else
                        self moveto( self.origin - vector, time );

                    self._door_open = 0;
                }

                self thread maps\mp\zombies\_zm_blockers::door_solid_thread();
            }

            break;
    }
}

moon_airlock_occupied()
{
    is_occupied = 0;
    zombies = getaiarray( level.zombie_team );

    for ( i = 0; i < zombies.size; i++ )
    {
        if ( zombies[i] istouching( self ) )
            is_occupied++;
    }

    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] istouching( self ) )
            is_occupied++;
    }

    if ( is_occupied > 0 )
    {
        if ( isdefined( self.doors[0].startpos ) && self.doors[0].startpos == self.doors[0].origin )
        {
            for ( i = 0; i < self.doors.size; i++ )
                self.doors[i] thread airlock_activate( 0.25, 1 );

            self._door_open = 1;
        }

        return true;
    }
    else
        return false;
}

door_clean_up_corpses()
{
    corpses = getcorpsearray();

    if ( isdefined( corpses ) )
    {
        for ( i = 0; i < corpses.size; i++ )
        {
            if ( corpses[i] istouching( self ) )
                corpses[i] thread door_remove_corpses();
        }
    }
}

door_remove_corpses()
{
    if ( isdefined( level._effect["dog_gib"] ) )
        playfx( level._effect["dog_gib"], self.origin );

    self delete();
}

zapper_light_green( light_name, key_name )
{
    zapper_lights = getentarray( light_name, key_name );

    for ( i = 0; i < zapper_lights.size; i++ )
    {
        zapper_lights[i] setmodel( "zombie_trap_switch_light_on_green" );

        if ( isdefined( zapper_lights[i].fx ) )
            zapper_lights[i].fx delete();

        zapper_lights[i].fx = maps\mp\zombies\_zm_net::network_safe_spawn( "trap_light_green", 2, "script_model", zapper_lights[i].origin );
        zapper_lights[i].fx setmodel( "tag_origin" );
        zapper_lights[i].fx.angles = zapper_lights[i].angles + vectorscale( ( -1, 0, 0 ), 90.0 );
        playfxontag( level._effect["zapper_light_ready"], zapper_lights[i].fx, "tag_origin" );
    }
}

zapper_light_red( light_name, key_name )
{
    zapper_lights = getentarray( light_name, key_name );

    for ( i = 0; i < zapper_lights.size; i++ )
    {
        zapper_lights[i] setmodel( "zombie_trap_switch_light_on_red" );

        if ( isdefined( zapper_lights[i].fx ) )
            zapper_lights[i].fx delete();

        zapper_lights[i].fx = maps\mp\zombies\_zm_net::network_safe_spawn( "trap_light_red", 2, "script_model", zapper_lights[i].origin );
        zapper_lights[i].fx setmodel( "tag_origin" );
        zapper_lights[i].fx.angles = zapper_lights[i].angles + vectorscale( ( -1, 0, 0 ), 90.0 );
        playfxontag( level._effect["zapper_light_notready"], zapper_lights[i].fx, "tag_origin" );
    }
}

moon_intermission()
{
    self closemenu();
    self closeingamemenu();
    level endon( "stop_intermission" );
    self endon( "disconnect" );
    self endon( "death" );
    self notify( "_zombie_game_over" );
    self.score = self.score_total;
    self.sessionstate = "intermission";
    self.spectatorclient = -1;
    self.killcamentity = -1;
    self.archivetime = 0;
    self.psoffsettime = 0;
    self.friendlydamage = undefined;
    points = getstructarray( "intermission", "targetname" );

    for ( i = 0; i < points.size; i++ )
    {
        if ( flag( "enter_nml" ) )
        {
            if ( points[i].script_noteworthy == "moon" )
                arrayremovevalue( points, points[i] );

            continue;
        }

        if ( points[i].script_noteworthy == "earth" )
            arrayremovevalue( points, points[i] );
    }

    if ( !isdefined( points ) || points.size == 0 )
    {
        points = getentarray( "info_intermission", "classname" );

        if ( points.size < 1 )
        {
/#
            println( "NO info_intermission POINTS IN MAP" );
#/
            return;
        }
    }

    self.game_over_bg = newclienthudelem( self );
    self.game_over_bg.horzalign = "fullscreen";
    self.game_over_bg.vertalign = "fullscreen";
    self.game_over_bg setshader( "black", 640, 480 );
    self.game_over_bg.alpha = 1;
    org = undefined;

    while ( true )
    {
        points = array_randomize( points );

        for ( i = 0; i < points.size; i++ )
        {
            point = points[i];

            if ( !isdefined( org ) )
                self spawn( point.origin, point.angles );

            if ( isdefined( points[i].target ) )
            {
                if ( !isdefined( org ) )
                {
                    org = spawn( "script_model", self.origin + vectorscale( ( 0, 0, -1 ), 60.0 ) );
                    org setmodel( "tag_origin" );
                }

                org.origin = points[i].origin;
                org.angles = points[i].angles;

                for ( j = 0; j < get_players().size; j++ )
                {
                    player = get_players()[j];
                    player camerasetposition( org );
                    player camerasetlookat();
                    player cameraactivate( 1 );
                }

                speed = 20;

                if ( isdefined( points[i].speed ) )
                    speed = points[i].speed;

                target_point = getstruct( points[i].target, "targetname" );
                dist = distance( points[i].origin, target_point.origin );
                time = dist / speed;
                q_time = time * 0.25;

                if ( q_time > 1 )
                    q_time = 1;

                self.game_over_bg fadeovertime( q_time );
                self.game_over_bg.alpha = 0;
                org moveto( target_point.origin, time, q_time, q_time );
                org rotateto( target_point.angles, time, q_time, q_time );
                wait( time - q_time );
                self.game_over_bg fadeovertime( q_time );
                self.game_over_bg.alpha = 1;
                wait( q_time );
                continue;
            }

            self.game_over_bg fadeovertime( 1 );
            self.game_over_bg.alpha = 0;
            wait 5;
            self.game_over_bg thread maps\mp\zombies\_zm::fade_up_over_time( 1 );
        }
    }
}

hacker_location_random_init()
{
    hacker_tool_array = [];
    hacker_pos = undefined;
    level.hacker_tool_positions = [];
    hacker = getentarray( "zombie_equipment_upgrade", "targetname" );

    for ( i = 0; i < hacker.size; i++ )
    {
        if ( isdefined( hacker[i].zombie_equipment_upgrade ) && hacker[i].zombie_equipment_upgrade == "equip_hacker_zm" )
        {
            hacker_tool_array[hacker_tool_array.size] = hacker[i];
            struct = spawnstruct();
            struct.trigger_org = hacker[i].origin;
            struct.model_org = getent( hacker[i].target, "targetname" ).origin;
            struct.model_ang = getent( hacker[i].target, "targetname" ).angles;
            level.hacker_tool_positions[level.hacker_tool_positions.size] = struct;
        }
    }

    if ( hacker_tool_array.size > 1 )
    {
        hacker_pos = hacker_tool_array[randomint( hacker_tool_array.size )];
        arrayremovevalue( hacker_tool_array, hacker_pos );
        array_thread( hacker_tool_array, ::hacker_position_cleanup );
    }
}

hacker_position_cleanup()
{
    model = getent( self.target, "targetname" );

    if ( isdefined( model ) )
        model delete();

    if ( isdefined( self ) )
        self delete();
}

moon_glass_breach_init()
{
    level.glass = getentarray( "moon_breach_glass", "targetname" );
    array_thread( level.glass, ::glass_breach_think );
    flag_wait( "start_zombie_round_logic" );
    players = get_players();

    for ( i = 0; i < players.size; i++ )
        players[i] thread check_for_grenade_throw();
}

glass_gets_destroyed()
{
    if ( isdefined( self.fxpos_array ) )
    {
        for ( i = 0; i < self.fxpos_array.size; i++ )
            playfx( level._effect["glass_impact"], self.fxpos_array[i].origin, anglestoforward( self.fxpos_array[i].angles ) );
    }

    if ( isdefined( self.script_noteworthy ) )
    {
        level thread send_client_notify_for_breach( self.script_noteworthy );
        _zones = getentarray( self.script_noteworthy, "targetname" );

        if ( isdefined( _zones ) )
        {
            for ( i = 0; i < _zones.size; i++ )
                _zones[i].script_string = "lowgravity";

            level thread maps\mp\zm_moon_gravity::zone_breached( self.script_noteworthy );
        }
    }

    wait_network_frame();

    if ( isdefined( self.model ) && self.damage_state == 0 )
    {
        self setmodel( self.model + "_broken" );
        self.damage_state = 1;
        return;
    }
    else
    {
        self delete();
        return;
    }
}

wait_for_grenade_explode( player )
{
    player endon( "projectile_impact" );
    self waittill( "explode", grenade_origin );
    self thread check_for_grenade_damage_on_window( grenade_origin );
}

wait_for_projectile_impact( grenade )
{
    grenade endon( "explode" );
    self waittill( "projectile_impact", weapon_name, position );
    self thread check_for_grenade_damage_on_window( position );
}

check_for_grenade_damage_on_window( grenade_origin )
{
    radiussqtocheck = 44096;

    for ( i = 0; i < level.glass.size; i++ )
    {
        if ( level.glass[i].damage_state == 0 )
        {
            glass_destroyed = 0;

            for ( j = 0; j < level.glass[i].fxpos_array.size; j++ )
            {
                glass_origin = level.glass[i].fxpos_array[j].origin;

                if ( distancesquared( glass_origin, grenade_origin ) < radiussqtocheck )
                {
                    glass_destroyed = 1;
                    break;
                }
            }

            if ( glass_destroyed )
            {
                level.glass[i] glass_gets_destroyed();
                level.glass[i].damage_state = 1;
            }
        }
    }
}

check_for_grenade_throw()
{
    while ( true )
    {
        self waittill( "grenade_fire", grenade, weapname );
        grenade thread wait_for_grenade_explode( self );
        self thread wait_for_projectile_impact( grenade );
    }
}

glass_breach_think()
{
    level endon( "intermission" );
    self.fxpos_array = [];

    if ( isdefined( self.target ) )
        self.fxpos_array = getstructarray( self.target, "targetname" );

    self.health = 99999;
    self setcandamage( 1 );
    self.damage_state = 0;

    while ( true )
    {
        self waittill( "damage", amount, attacker, direction, point, dmg_type );

        if ( isplayer( attacker ) && ( dmg_type == "MOD_PROJECTILE" || dmg_type == "MOD_PROJECTILE_SPLASH" ) )
        {
            if ( self.damage_state == 0 )
            {
                self glass_gets_destroyed();
                self.damage_state = 1;
            }
        }
    }
}

send_client_notify_for_breach( zone )
{
    switch ( zone )
    {
        case "bridge_zone":
            if ( !is_true( level.audio_zones_breached["1"] ) )
            {
                clientnotify( "Az1" );
                level.audio_zones_breached["1"] = 1;

                if ( flag( "power_on" ) )
                    level thread maps\mp\zm_moon_amb::play_mooncomp_vox( "vox_mcomp_breach_start" );
            }

            break;
        case "generator_exit_east_zone":
            if ( !is_true( level.audio_zones_breached["4a"] ) )
            {
                clientnotify( "Az4a" );
                level.audio_zones_breached["4a"] = 1;

                if ( flag( "power_on" ) )
                    level thread maps\mp\zm_moon_amb::play_mooncomp_vox( "vox_mcomp_breach_labs" );
            }

            break;
        case "enter_forest_east_zone":
            if ( !is_true( level.audio_zones_breached["4b"] ) )
            {
                clientnotify( "Az4b" );
                level.audio_zones_breached["4b"] = 1;

                if ( flag( "power_on" ) )
                    level thread maps\mp\zm_moon_amb::play_mooncomp_vox( "vox_mcomp_breach_labs" );
            }

            break;
    }
}

zombie_moon_receiving_hatch_init()
{
    hatches = getentarray( "recieving_hatch", "targetname" );
    array_thread( hatches, ::zombie_moon_hatch );
}

zombie_moon_hatch()
{
    scale = 1;
    flag_wait( "power_on" );
    self playsound( "evt_loading_door_start" );

    if ( isdefined( self.script_vector ) )
    {
        vector = vectorscale( self.script_vector, scale );
        self moveto( self.origin + vector, 1.0 );

        if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "hatch_clip" )
            self thread maps\mp\zombies\_zm_blockers::disconnect_paths_when_done();
        else
        {
            self notsolid();
            self connectpaths();
        }

        wait 1;
        self playsound( "evt_loading_door_end" );
    }
}
