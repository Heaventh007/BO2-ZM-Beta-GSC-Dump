// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zm_moon_utility;
#include maps\mp\zm_moon_wasteland;
#include maps\mp\zm_moon_teleporter;
#include maps\mp\gametypes_zm\_spawning;
#include maps\mp\zombies\_zm;
#include maps\mp\zombies\_zm_weap_quantum_bomb;
#include maps\mp\zm_moon_fx;
#include maps\mp\animscripts\zm_death;
#include maps\mp\zombies\_load;
#include maps\mp\zm_moon_amb;
#include maps\mp\zm_moon_sq;
#include maps\mp\zm_moon;
#include maps\mp\zombies\_zm_ai_dogs;
#include maps\mp\zombies\_zm_ai_quad;
#include maps\mp\zombies\_zm_equip_gasmask;
#include maps\mp\zombies\_zm_equip_hacker;
#include maps\mp\_sticky_grenade;
#include maps\mp\zombies\_zm_weap_black_hole_bomb;
#include maps\mp\zombies\_zm_weap_microwavegun;
#include maps\mp\zombies\_zm_weap_bowie;
#include maps\mp\zombies\_zm_weap_ballistic_knife;
#include maps\mp\zombies\_zm_weap_claymore;
#include maps\mp\zm_moon_digger;
#include maps\mp\zm_moon_achievement;
#include maps\mp\zm_moon_distance_tracking;
#include maps\mp\zm_moon_gravity;
#include maps\mp\zm_moon_jump_pad;
#include maps\mp\zombies\_zm_equipment;
#include maps\mp\zombies\_zm_hackables_wallbuys;
#include maps\mp\zombies\_zm_hackables_perks;
#include maps\mp\zombies\_zm_hackables_packapunch;
#include maps\mp\zombies\_zm_hackables_boards;
#include maps\mp\zombies\_zm_hackables_doors;
#include maps\mp\zombies\_zm_hackables_powerups;
#include maps\mp\zombies\_zm_hackables_box;
#include maps\mp\zombies\_zm_blockers;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_powerups;
#include character\c_usa_dempsey_zm;
#include character\c_rus_nikolai_zm;
#include character\c_jap_takeo_zm;
#include character\c_ger_richtofen_zm;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\zombies\_zm_game_module;
#include maps\mp\zombies\_zm_laststand;

main()
{
    level.default_game_mode = "zclassic";
    level.use_multiple_spawns = 1;
    level._num_overriden_models = 0;
    level._use_choke_weapon_hints = 1;
    level._use_choke_blockers = 1;
    level._use_extra_blackhole_anims = ::init_extra_blackhole_anims;
    level._special_blackhole_bomb_structs = ::blackhole_bomb_area_check;
    level._limited_equipment = [];
    level._limited_equipment[level._limited_equipment.size] = "equip_hacker_zm";
    level._override_blackhole_destination_logic = ::get_blackholebomb_destination_point;
    level._blackhole_bomb_valid_area_check = ::blackhole_bomb_in_invalid_area;
    level.quantum_bomb_prevent_player_getting_teleported = ::quantum_bomb_prevent_player_getting_teleported_override;
    level._no_water_risers = 1;
    level.use_clientside_board_fx = 1;
    level.riser_fx_on_client = 1;
    level.risers_use_low_gravity_fx = 1;
    maps\mp\gametypes_zm\_spawning::level_use_unified_spawning( 1 );
    level._round_start_func = maps\mp\zombies\_zm::round_start;
    maps\mp\zombies\_zm_weap_quantum_bomb::init_registration();
    maps\mp\zm_moon_fx::main();
    maps\mp\zombies\_zm::init_fx();
    maps\mp\animscripts\zm_death::precache_gib_fx();
    level.zombiemode = 1;
    maps\mp\zombies\_load::main();
    maps\mp\zm_moon_amb::main();
    precache_items();

    if ( getdvarint( #"_id_F273BD1C" ) > 0 )
        return;

    level thread maps\mp\zm_moon_sq::start_moon_sidequest();
    init_strings();
    register_clientfields();
    init_level_specific_wall_buy_fx();
    level.player_out_of_playable_area_monitor = 1;
    level.player_out_of_playable_area_monitor_callback = ::zombie_moon_player_out_of_playable_area_monitor_callback;
    level thread moon_create_life_trigs();
    level.zombie_anim_override = maps\mp\zm_moon::anim_override_func;
    level.traps = [];
    level.round_think_func = ::moon_round_think_func;
    level.random_pandora_box_start = 1;
    level.door_dialog_function = maps\mp\zombies\_zm::play_door_dialog;
    level.quad_move_speed = 35;
    level.quad_explode = 1;
    level.dogs_enabled = 1;
    level.dog_spawn_func = maps\mp\zombies\_zm_ai_dogs::dog_spawn_factory_logic;
    level.custom_ai_type = [];
    level.custom_ai_type[level.custom_ai_type.size] = maps\mp\zombies\_zm_ai_quad::init;
    level.custom_ai_type[level.custom_ai_type.size] = maps\mp\zombies\_zm_ai_dogs::init;
    level thread hacker_location_random_init();
    level._zombie_custom_add_weapons = ::custom_add_weapons;
    include_weapons();
    include_powerups();
    include_equipment_for_level();
    maps\mp\zombies\_zm_equip_gasmask::init();
    maps\mp\zombies\_zm_equip_hacker::init();
    precachemodel( "viewmodel_zom_pressure_suit_arms" );
    precachemodel( "c_zom_moon_pressure_suit_body_player" );
    precachemodel( "c_zom_moon_pressure_suit_helm" );
    precachemodel( "c_rus_nikolai_dlc5_head_psuit" );
    level.zombiemode_gasmask_reset_player_model = ::gasmask_reset_player_model;
    level.zombiemode_gasmask_reset_player_viewmodel = ::gasmask_reset_player_set_viewmodel;
    level.zombiemode_gasmask_change_player_headmodel = ::gasmask_change_player_headmodel;
    level.zombiemode_gasmask_set_player_model = ::gasmask_set_player_model;
    level.zombiemode_gasmask_set_player_viewmodel = ::gasmask_set_player_viewmodel;
    level.register_offhand_weapons_for_level_defaults_override = ::moon_offhand_weapon_overrride;
    level.zombiemode_offhand_weapon_give_override = ::offhand_weapon_give_override;
    level.givecustomloadout = ::givecustomloadout;
    level.precachecustomcharacters = ::precachecustomcharacters;
    level.givecustomcharacters = ::givecustomcharacters;
    initcharacterstartindex();
    level.use_zombie_heroes = 1;
    level.zombiemode_using_pack_a_punch = 1;
    level.zombiemode_using_additionalprimaryweapon_perk = 1;
    level.zombiemode_using_deadshot_perk = 1;
    level.zombiemode_using_divetonuke_perk = 1;
    level.zombiemode_using_doubletap_perk = 1;
    level.zombiemode_using_juggernaut_perk = 1;
    level.zombiemode_using_marathon_perk = 1;
    level.zombiemode_using_revive_perk = 1;
    level.zombiemode_using_sleightofhand_perk = 1;
    level.moon_startmap = 1;
    level._zombiemode_blocker_trigger_extra_thread = ::hacker_hides_blocker_trigger_thread;
    maps\mp\zombies\_zm::init();
    level thread maps\mp\zombies\_zm::register_sidequest( "EOA", "ZOMBIE_TEMPLE_SIDEQUEST" );
    level thread maps\mp\zombies\_zm::register_sidequest( "MOON", "ZOMBIE_MOON_SIDEQUEST_TOTAL" );
    maps\mp\_sticky_grenade::init();
    maps\mp\zombies\_zm_weap_black_hole_bomb::init();
    maps\mp\zombies\_zm_weap_microwavegun::init();
    maps\mp\zombies\_zm_weap_quantum_bomb::init();
    maps\mp\zombies\_zm_weap_bowie::init();
    maps\mp\zombies\_zm_weap_ballistic_knife::init();
    maps\mp\zombies\_zm_weap_claymore::init();
    level.zone_manager_init_func = ::moon_zone_init;
    init_zones[0] = "bridge_zone";
    init_zones[1] = "nml_zone";
    level thread maps\mp\zombies\_zm_zonemgr::manage_zones( init_zones );
    level.zombie_ai_limit = 24;
    level maps\mp\zm_moon_digger::digger_init_flags();
    level thread maps\mp\zm_moon_achievement::init();
    level thread electric_switch();
    level thread maps\mp\zm_moon_distance_tracking::zombie_tracking_init();
    init_no_mans_land();
    level thread teleporter_check_for_endgame();
    level thread teleporter_function( "generator_teleporter" );
    level thread teleporter_function( "nml_teleporter" );
    level thread vision_set_init();
    level thread init_zombie_airlocks();
    level thread setup_water_physics();
    set_zombie_var( "zombie_intermission_time", 15 );
    set_zombie_var( "zombie_between_round_time", 10 );
    level thread maps\mp\zm_moon_digger::digger_init();
    maps\mp\zm_moon_gravity::init();
    maps\mp\zm_moon_jump_pad::init();
    level thread maps\mp\zm_moon_gravity::zombie_moon_update_player_gravity();
    level thread maps\mp\zm_moon_gravity::zombie_moon_update_player_float();
    level thread init_hackables();
/#
    execdevgui( "devgui_zombie_moon" );
    level.custom_devgui = ::moon_devgui;
#/
    level.custom_intermission = ::moon_intermission;
    level thread no_mans_land_power();
    level thread cliff_fall_death();
    level thread setup_fields();
    level thread wait_for_end_game();
    level.tunnel_6_destroyed = getent( "tunnel_6_destroyed", "targetname" );
    level.tunnel_6_destroyed hide();
    level.tunnel_11_destroyed = getent( "tunnel_11_destroyed", "targetname" );
    level.tunnel_11_destroyed hide();
    level.perk_lost_func = ::moon_perk_lost;
    level.check_valid_spawn_override = ::moon_respawn_override;
    level._zombiemode_post_respawn_callback = ::moon_post_respawn_callback;
    level thread end_game_vision_and_fog_fix();
    level._poi_override = ::moon_bhb_poi_control;
    level._override_quad_explosion = ::override_quad_explosion;
    level.zombie_speed_up = ::moon_speed_up;
    level.ai_astro_explode = ::moon_push_zombies_when_astro_explodes;
}

moon_push_zombies_when_astro_explodes( position )
{
    level.quantum_bomb_cached_closest_zombies = undefined;
    self thread maps\mp\zombies\_zm_weap_quantum_bomb::quantum_bomb_zombie_fling_result( position );
}

moon_post_respawn_callback()
{
    self setclientfieldtoplayer( "gasmaskoverlay", 0 );

    if ( !maps\mp\zombies\_zm_equipment::limited_equipment_in_use( "equip_hacker_zm" ) )
        self maps\mp\zombies\_zm_equipment::set_equipment_invisibility_to_player( "equip_hacker_zm", 0 );
}

setup_fields()
{
    flag_wait( "power_on" );
    exploder( 140 );
}

no_mans_land_power()
{
    level thread turn_area51_perks_on();
    level notify( "Pack_A_Punch_on" );
}

turn_area51_perks_on()
{
    machine = getentarray( "vending_sleight", "targetname" );

    for ( i = 0; i < machine.size; i++ )
        machine[i] setmodel( "zombie_vending_sleight_on" );

    level notify( "specialty_fastreload_power_on" );
    machine2 = getentarray( "vending_jugg", "targetname" );

    for ( i = 0; i < machine2.size; i++ )
    {
        machine2[i] setmodel( "zombie_vending_jugg_on" );
        machine2[i] playsound( "zmb_perks_power_on" );
    }

    level notify( "specialty_armorvest_power_on" );
}

init_hackables()
{
    level thread maps\mp\zombies\_zm_hackables_wallbuys::hack_wallbuys();
    level thread maps\mp\zombies\_zm_hackables_perks::hack_perks();
    level thread maps\mp\zombies\_zm_hackables_packapunch::hack_packapunch();
    level thread maps\mp\zombies\_zm_hackables_boards::hack_boards();
    level thread maps\mp\zombies\_zm_hackables_doors::hack_doors( "zombie_airlock_buy", maps\mp\zm_moon_utility::moon_door_opened );
    level thread maps\mp\zombies\_zm_hackables_doors::hack_doors();
    level thread maps\mp\zombies\_zm_hackables_powerups::hack_powerups();
    level thread maps\mp\zombies\_zm_hackables_box::box_hacks();
    level thread packapunch_hack_think();
    level thread pack_gate_poi_init();
}

hacker_hides_blocker_trigger_thread()
{
    self endon( "death" );
    maps\mp\zombies\_zm_equip_hacker::hide_hint_when_hackers_active();
}

zombie_moon_player_out_of_playable_area_monitor_callback()
{
    if ( is_true( self._padded ) )
        return false;

    return true;
}

moon_create_life_trigs()
{

}

packapunch_hack_think()
{
    flag_init( "packapunch_hacked" );
    time = 30;
    pack_gates = getentarray( "zombieland_gate", "targetname" );

    for ( i = 0; i < pack_gates.size; i++ )
        pack_gates[i].startpos = pack_gates[i].origin;

    while ( true )
    {
        level waittill( "packapunch_hacked" );
        flag_clear( "packapunch_hacked" );
        array_thread( pack_gates, ::pack_gate_activate );
        level thread pack_gate_poi_activate( time );
        wait( time );
        flag_set( "packapunch_hacked" );
        maps\mp\zombies\_zm_equip_hacker::register_pooled_hackable_struct( level._pack_hack_struct, maps\mp\zombies\_zm_hackables_packapunch::packapunch_hack );
    }
}

pack_gate_poi_init()
{
    pack_zombieland_poi = getentarray( "zombieland_poi", "targetname" );

    for ( i = 0; i < pack_zombieland_poi.size; i++ )
    {
        pack_zombieland_poi[i] create_zombie_point_of_interest( undefined, 30, 0, 0 );
        pack_zombieland_poi[i] thread create_zombie_point_of_interest_attractor_positions( 4, 45 );
    }
}

pack_gate_poi_activate( time )
{
    pack_enclosure = getent( "pack_enclosure", "targetname" );
    pack_zombieland_poi = getentarray( "zombieland_poi", "targetname" );
    players = get_players();
    num_players_inside = 0;

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] istouching( pack_enclosure ) )
            num_players_inside++;
    }

    if ( num_players_inside != players.size )
        return;

    level thread activate_zombieland_poi_positions( time );
    level thread watch_for_exit( pack_zombieland_poi );

    while ( !flag( "packapunch_hacked" ) )
    {
        zombies = getaiarray( level.zombie_team );

        for ( i = 0; i < zombies.size; i++ )
        {
            if ( zombies[i] istouching( pack_enclosure ) )
            {
                zombies[i].in_pack_enclosure = 1;
                zombies[i] thread moon_zombieland_ignore_poi();
                continue;
            }

            if ( !is_true( zombies[i]._poi_pack_set ) )
            {
                zombies[i] thread switch_between_zland_poi();
                zombies[i] thread moon_nml_bhb_present();
                zombies[i]._poi_pack_set = 1;
            }
        }

        wait 1.0;
    }

    flag_wait( "packapunch_hacked" );
    level notify( "stop_pack_poi" );
    zombies = getaiarray( level.zombie_team );

    for ( i = 0; i < zombies.size; i++ )
        zombies[i]._poi_pack_set = 0;

    for ( i = 0; i < pack_zombieland_poi.size; i++ )
        pack_zombieland_poi[i] deactivate_zombie_point_of_interest();
}

switch_between_zland_poi()
{
    self endon( "death" );
    level endon( "packapunch_hacked" );
    self endon( "nml_bhb" );
    poi_array = getentarray( "zombieland_poi", "targetname" );

    for ( x = 0; x < poi_array.size; x++ )
    {
        if ( is_true( poi_array[x].poi_active ) )
            self add_poi_to_ignore_list( poi_array[x] );
    }

    for ( poi_array = array_randomize( poi_array ); !flag( "packapunch_hacked" ); poi_array = array_randomize( poi_array ) )
    {
        for ( i = 0; i < poi_array.size; i++ )
        {
            self remove_poi_from_ignore_list( poi_array[i] );
            self waittill_any_or_timeout( randomintrange( 2, 5 ), "goal", "bad_path" );
            self add_poi_to_ignore_list( poi_array[i] );
        }
    }
}

remove_ignore_on_poi( poi_array )
{
    self endon( "death" );
    level waittill( "stop_pack_poi" );

    for ( i = 0; i < poi_array.size; i++ )
        self remove_poi_from_ignore_list( poi_array[i] );

    self._poi_pack_set = 0;
}

activate_zombieland_poi_positions( time )
{
    level endon( "stop_pack_poi" );
    pack_zombieland_poi = getentarray( "zombieland_poi", "targetname" );

    for ( i = 0; i < pack_zombieland_poi.size; i++ )
    {
        poi = pack_zombieland_poi[i];
        poi activate_zombie_point_of_interest();
    }
}

watch_for_exit( poi_array )
{
    while ( players_in_zombieland() && !flag( "packapunch_hacked" ) )
        wait 0.1;

    level notify( "stop_pack_poi" );

    for ( i = 0; i < poi_array.size; i++ )
        poi_array[i] deactivate_zombie_point_of_interest();
}

players_in_zombieland()
{
    pack_enclosure = getent( "pack_enclosure", "targetname" );
    players = get_players();
    num_players_inside = 0;

    for ( i = 0; i < players.size; i++ )
    {
        if ( players[i] istouching( pack_enclosure ) )
            num_players_inside++;
    }

    if ( num_players_inside != players.size )
        return false;

    return true;
}

check_for_avoid_poi()
{
    if ( is_true( self.in_pack_enclosure ) )
        return true;

    return false;
}

pack_gate_activate()
{
    time = 1;
    self notsolid();

    if ( isdefined( self.script_vector ) )
    {
        self playsound( "amb_teleporter_gate_start" );
        self moveto( self.startpos + self.script_vector, time );
        self thread pack_gate_closed();
        flag_wait( "packapunch_hacked" );
        self notsolid();

        if ( self.classname == "script_brushmodel" )
            self connectpaths();

        self playsound( "amb_teleporter_gate_start" );
        self moveto( self.startpos, time );
        self thread maps\mp\zombies\_zm_blockers::door_solid_thread();
    }
}

pack_gate_closed()
{
    self waittill( "movedone" );
    self.door_moving = undefined;

    while ( true )
    {
        players = get_players();
        player_touching = 0;

        for ( i = 0; i < players.size; i++ )
        {
            if ( players[i] istouching( self ) )
            {
                player_touching = 1;
                break;
            }
        }

        if ( !player_touching )
        {
            self solid();
            self disconnectpaths();
            return;
        }

        wait 1;
    }
}

moon_nml_bhb_present()
{
    self endon( "death" );
    nml_bhb = undefined;
    pack_zombieland_poi = getentarray( "zombieland_poi", "targetname" );
    pack_enclosure = getent( "pack_enclosure", "targetname" );

    while ( !flag( "packapunch_hacked" ) )
    {
        zombie_pois = getentarray( "zombie_poi", "script_noteworthy" );

        for ( i = 0; i < zombie_pois.size; i++ )
        {
            if ( isdefined( zombie_pois[i].targetname ) && zombie_pois[i].targetname == "zm_bhb" )
            {
                if ( moon_zmb_and_bhb_touching_trig( zombie_pois[i] ) )
                {
                    nml_bhb = zombie_pois[i];
                    self remove_poi_from_ignore_list( nml_bhb );
                    continue;
                }

                self add_poi_to_ignore_list( zombie_pois[i] );
            }
        }

        if ( isdefined( nml_bhb ) )
        {
            self notify( "nml_bhb" );

            for ( j = 0; j < pack_zombieland_poi.size; j++ )
                self add_poi_to_ignore_list( pack_zombieland_poi[j] );
        }
        else
        {
            wait 0.1;
            continue;
        }

        while ( isdefined( nml_bhb ) )
            wait 0.1;

        self thread switch_between_zland_poi();
        wait 0.1;
    }

    return false;
}

moon_zmb_and_bhb_touching_trig( ent_bhb )
{
    self endon( "death" );

    if ( !isdefined( ent_bhb ) )
        return false;

    pack_trig = getent( "pack_enclosure", "targetname" );

    if ( self istouching( pack_trig ) && isdefined( ent_bhb ) && ent_bhb istouching( pack_trig ) )
        return true;
    else if ( !self istouching( pack_trig ) && isdefined( ent_bhb ) && !ent_bhb istouching( pack_trig ) )
        return true;

    return false;
}

moon_zombieland_ignore_poi()
{
    self endon( "death" );
    nml_poi_array = getentarray( "zombieland_poi", "targetname" );

    if ( is_true( self._zmbl_ignore ) )
        return;

    self._zmbl_ignore = 1;

    for ( i = 0; i < nml_poi_array.size; i++ )
        self add_poi_to_ignore_list( nml_poi_array[i] );

    while ( !flag( "packapunch_hacked" ) )
    {
        bhb_bomb = getentarray( "zm_bhb", "targetname" );

        if ( isdefined( bhb_bomb ) )
        {
            for ( w = 0; w < bhb_bomb.size; w++ )
            {
                if ( !moon_zmb_and_bhb_touching_trig( bhb_bomb[w] ) )
                    self add_poi_to_ignore_list( bhb_bomb[w] );
            }
        }

        wait 0.1;
    }

    for ( x = 0; x < nml_poi_array.size; x++ )
        self remove_poi_from_ignore_list( nml_poi_array[x] );
}

zombie_moon_gravity_init()
{

}

zombie_earth_gravity_init()
{

}

register_clientfields()
{
    registerclientfield( "scriptmover", "digger_moving", 7000, 1, "int" );
    registerclientfield( "scriptmover", "digger_digging", 7000, 1, "int" );
    registerclientfield( "scriptmover", "digger_arm_fx", 7000, 1, "int" );
    registerclientfield( "scriptmover", "dome_malfunction_pad", 7000, 1, "int" );
    registerclientfield( "toplayer", "soul_swap", 7000, 1, "int" );
    registerclientfield( "toplayer", "gasp_rumble", 7000, 1, "int" );
    registerclientfield( "actor", "low_gravity", 7000, 1, "int" );
    registerclientfield( "actor", "ctt", 7000, 1, "int" );
}

precache_items()
{
    flag_init( "between_rounds" );
    precachemodel( "viewmodel_usa_pow_arms" );
    precachemodel( "viewmodel_rus_prisoner_arms" );
    precachemodel( "viewmodel_vtn_nva_standard_arms" );
    precachemodel( "viewmodel_usa_hazmat_arms" );
    precachemodel( "zombie_trap_switch_light_on_red" );
    precachemodel( "zombie_trap_switch_light_on_green" );
    precacheshader( "zom_icon_player_life" );
    precachemodel( "p_rus_rb_lab_warning_light_01" );
    precachemodel( "p_rus_rb_lab_warning_light_01_off" );
    precachemodel( "p_rus_rb_lab_light_core_on" );
    precachemodel( "p_rus_rb_lab_light_core_off" );
    precachemodel( "p_zom_moon_lab_airlock_door01_right" );
    precachemodel( "p_zom_moon_lab_airlock_door01_left" );
    precachemodel( "p_zom_moon_mine_airlock_door03_single" );
    precachemodel( "p_zom_moon_re_glass_1_broken" );
    precachemodel( "p_zom_moon_re_glass_2_broken" );
    precachemodel( "p_zom_moon_re_glass_3_broken" );
    precachemodel( "p_zom_moon_re_glass_4_broken" );
    precachemodel( "p_zom_moon_lab_glass_top_broken" );
    precachemodel( "p_zom_moon_lab_glass_middle_broken" );
    precachemodel( "p_zom_moon_lab_glass_bottom_broken" );
    precachemodel( "p_zom_moon_biodome_hole_broken" );
    precachemodel( "P_zom_moon_earth" );
    precachemodel( "P_zom_moon_earth_dest" );
}

vision_set_init()
{
    flag_wait( "start_zombie_round_logic" );
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {

    }
}

moon_round_think_func()
{
    for (;;)
    {
        maxreward = 50 * level.round_number;

        if ( maxreward > 500 )
            maxreward = 500;

        level.zombie_vars["rebuild_barrier_cap_per_round"] = maxreward;
        level.pro_tips_start_time = gettime();
        level.zombie_last_run_time = gettime();
        level thread maps\mp\zombies\_zm_audio::change_zombie_music( "round_start" );

        if ( level.moon_startmap == 1 )
        {
            level.moon_startmap = 0;
            level thread maps\mp\zombies\_zm::play_level_start_vox_delayed();
            wait 3;
        }
        else
            maps\mp\zombies\_zm::round_one_up();

        players = get_players();
        array_thread( players, maps\mp\zombies\_zm_blockers::rebuild_barrier_reward_reset );

        if ( !flag( "teleporter_used" ) || level.first_round == 1 )
            level thread maps\mp\zombies\_zm::award_grenades_for_survivors();

        bbprint( "zombie_rounds", "round %d player_count %d", level.round_number, players.size );
        level.round_start_time = gettime();
        level thread [[ level.round_spawn_func ]]();
        level notify( "start_of_round" );

        if ( flag( "teleporter_used" ) )
        {
            flag_clear( "teleporter_used" );

            if ( level.prev_round_zombies != 0 )
                level.zombie_total = level.prev_round_zombies;
        }

        [[ level.round_wait_func ]]();

        if ( level.on_the_moon && ( !is_true( level._from_nml ) || level.first_round ) )
            maps\mp\zombies\_zm_powerups::powerup_round_start();

        level.first_round = 0;
        level notify( "end_of_round" );
        flag_set( "between_rounds" );
        uploadstats();

        if ( !flag( "teleporter_used" ) )
        {
            level thread maps\mp\zombies\_zm_audio::change_zombie_music( "round_end" );

            if ( 1 != players.size )
                level thread maps\mp\zombies\_zm::spectators_respawn();
        }

        level maps\mp\zombies\_zm::round_over();
        timer = level.zombie_vars["zombie_spawn_delay"];

        if ( timer > 0.08 )
            level.zombie_vars["zombie_spawn_delay"] = timer * 0.95;
        else if ( timer < 0.08 )
            level.zombie_vars["zombie_spawn_delay"] = 0.08;

        level.zombie_move_speed = level.round_number * level.zombie_vars["zombie_move_speed_multiplier"];

        if ( flag( "teleporter_used" ) )
        {
            if ( level.prev_round_zombies != 0 && !flag( "enter_nml" ) )
                level.round_number = level.nml_last_round;
        }
        else
            level.round_number++;

        level notify( "between_round_over" );
        flag_clear( "between_rounds" );
    }
}

moon_zone_init()
{
    flag_init( "always_on" );
    flag_set( "always_on" );
    add_adjacent_zone( "airlock_bridge_zone", "bridge_zone", "receiving_exit" );
    add_adjacent_zone( "airlock_bridge_zone", "water_zone", "receiving_exit" );
    add_adjacent_zone( "bridge_zone", "water_zone", "receiving_exit" );
    add_adjacent_zone( "airlock_west_zone", "water_zone", "catacombs_west" );
    add_adjacent_zone( "airlock_west_zone", "cata_left_start_zone", "catacombs_west" );
    add_adjacent_zone( "water_zone", "cata_left_start_zone", "catacombs_west" );
    add_adjacent_zone( "cata_left_start_zone", "cata_left_middle_zone", "tunnel_6_door1" );
    add_adjacent_zone( "airlock_east_zone", "water_zone", "catacombs_east" );
    add_adjacent_zone( "airlock_east_zone", "cata_right_start_zone", "catacombs_east" );
    add_adjacent_zone( "cata_right_start_zone", "water_zone", "catacombs_east" );
    add_adjacent_zone( "airlock_east2_zone", "generator_zone", "catacombs_east4" );
    add_adjacent_zone( "airlock_east2_zone", "cata_right_end_zone", "catacombs_east4" );
    add_adjacent_zone( "airlock_west2_zone", "cata_left_middle_zone", "catacombs_west4" );
    add_adjacent_zone( "airlock_west2_zone", "generator_zone", "catacombs_west4" );
    add_adjacent_zone( "cata_right_start_zone", "cata_right_middle_zone", "tunnel_11_door1" );
    add_adjacent_zone( "cata_right_middle_zone", "cata_right_end_zone", "tunnel_11_door2" );
    add_adjacent_zone( "airlock_generator_zone", "generator_zone", "generator_exit_east" );
    add_adjacent_zone( "airlock_generator_zone", "generator_exit_east_zone", "generator_exit_east" );
    add_adjacent_zone( "airlock_digsite_zone", "enter_forest_east_zone", "exit_dig_east" );
    add_adjacent_zone( "airlock_digsite_zone", "tower_zone_east", "exit_dig_east" );
    add_zone_flags( "exit_dig_east", "digsite_group" );
    add_adjacent_zone( "airlock_biodome_zone", "forest_zone", "forest_enter_digsite" );
    add_adjacent_zone( "airlock_biodome_zone", "tower_zone_east2", "forest_enter_digsite" );
    add_adjacent_zone( "forest_zone", "tower_zone_east2", "forest_enter_digsite" );
    add_zone_flags( "forest_enter_digsite", "digsite_group" );
    add_adjacent_zone( "tower_zone_east", "tower_zone_east2", "digsite_group" );
    add_adjacent_zone( "airlock_labs_2_biodome", "enter_forest_east_zone", "enter_forest_east" );
    add_adjacent_zone( "airlock_labs_2_biodome", "forest_zone", "enter_forest_east" );
    add_adjacent_zone( "enter_forest_east_zone", "generator_exit_east_zone", "dig_enter_east" );
}

init_strings()
{
    precachestring( &"ZOMBIE_PARIS_TRANSPORTER_WAITING" );
    precachestring( &"ZOMBIE_PARIS_TRANSPORTER_ACTIVATED" );
    precachestring( &"ZOMBIE_PARIS_TRANSPORTER_ABORTED" );
}

anim_override_func()
{

}

include_weapons()
{
    include_weapon( "knife_zm", 0 );
    include_weapon( "frag_grenade_zm", 0 );
    include_weapon( "claymore_zm", 0 );
    include_weapon( "sticky_grenade_zm", 0 );
    include_weapon( "m1911_zm", 0 );
    include_weapon( "m1911_upgraded_zm", 0 );
    include_weapon( "python_zm" );
    include_weapon( "python_upgraded_zm", 0 );
    include_weapon( "fiveseven_zm" );
    include_weapon( "fiveseven_upgraded_zm", 0 );
    include_weapon( "m14_zm", 0 );
    include_weapon( "m14_upgraded_zm", 0 );
    include_weapon( "m16_zm", 0 );
    include_weapon( "m16_gl_upgraded_zm", 0 );
    include_weapon( "xm8_zm" );
    include_weapon( "xm8_upgraded_zm", 0 );
    include_weapon( "type95_zm" );
    include_weapon( "type95_upgraded_zm", 0 );
    include_weapon( "ak74u_zm", 0 );
    include_weapon( "ak74u_upgraded_zm", 0 );
    include_weapon( "mp5k_zm", 0 );
    include_weapon( "mp5k_upgraded_zm", 0 );
    include_weapon( "mp40_zm", 0 );
    include_weapon( "mp40_upgraded_zm", 0 );
    include_weapon( "beretta93r_zm", 0 );
    include_weapon( "beretta93r_upgraded_zm", 0 );
    include_weapon( "pdw57_zm", 0 );
    include_weapon( "pdw57_upgraded_zm", 0 );
    include_weapon( "kard_zm" );
    include_weapon( "kard_upgraded_zm", 0 );
    include_weapon( "fivesevendw_zm" );
    include_weapon( "fivesevendw_upgraded_zm", 0 );
    include_weapon( "870mcs_zm", 0 );
    include_weapon( "870mcs_upgraded_zm", 0 );
    include_weapon( "rottweil72_zm", 0 );
    include_weapon( "rottweil72_upgraded_zm", 0 );
    include_weapon( "srm1216_zm" );
    include_weapon( "srm1216_upgraded_zm", 0 );
    include_weapon( "saiga12_zm" );
    include_weapon( "saiga12_upgraded_zm", 0 );
    include_weapon( "tar21_zm" );
    include_weapon( "tar21_upgraded_zm", 0 );
    include_weapon( "galil_zm" );
    include_weapon( "galil_upgraded_zm", 0 );
    include_weapon( "hk416_zm" );
    include_weapon( "hk416_upgraded_zm", 0 );
    include_weapon( "sa58_zm" );
    include_weapon( "sa58_upgraded_zm", 0 );
    include_weapon( "barretm82_zm" );
    include_weapon( "barretm82_upgraded_zm", 0 );
    include_weapon( "dsr50_zm" );
    include_weapon( "dsr50_upgraded_zm", 0 );
    include_weapon( "rpd_zm" );
    include_weapon( "rpd_upgraded_zm", 0 );
    include_weapon( "hamr_zm" );
    include_weapon( "hamr_upgraded_zm", 0 );
    include_weapon( "usrpg_zm" );
    include_weapon( "usrpg_upgraded_zm", 0 );
    include_weapon( "m32_zm" );
    include_weapon( "m32_upgraded_zm", 0 );
    include_weapon( "minigun_zm" );
    include_weapon( "zombie_black_hole_bomb" );
    include_weapon( "zombie_quantum_bomb" );
    include_weapon( "ray_gun_zm" );
    include_weapon( "ray_gun_upgraded_zm", 0 );
    include_weapon( "microwavegundw_zm" );
    include_weapon( "microwavegundw_upgraded_zm", 0 );
    include_weapon( "knife_ballistic_zm" );
    include_weapon( "knife_ballistic_upgraded_zm", 0 );
    include_weapon( "knife_ballistic_bowie_zm", 0 );
    include_weapon( "knife_ballistic_bowie_upgraded_zm", 0 );
    level._uses_retrievable_ballisitic_knives = 1;
    add_limited_weapon( "m1911_zm", 0 );
    add_limited_weapon( "knife_ballistic_zm", 1 );
    add_limited_weapon( "microwavegundw_zm", 1 );
}

givecustomloadout( takeallweapons, alreadyspawned )
{
    self giveweapon( "knife_zm" );
    self give_start_weapon( 1 );
}

precachecustomcharacters()
{
    character\c_usa_dempsey_zm::precache();
    character\c_rus_nikolai_zm::precache();
    character\c_jap_takeo_zm::precache();
    character\c_ger_richtofen_zm::precache();
    precachemodel( "viewmodel_usa_pow_arms" );
    precachemodel( "viewmodel_rus_prisoner_arms" );
    precachemodel( "viewmodel_vtn_nva_standard_arms" );
    precachemodel( "viewmodel_usa_hazmat_arms" );
    precachemodel( "c_ger_richtofen_dlc5_head" );
    precachemodel( "c_jap_takeo_dlc5_head" );
    precachemodel( "c_rus_nikolai_dlc5_head_psuit" );
    precachemodel( "c_usa_dempsey_dlc5_head" );
}

initcharacterstartindex()
{
    level.characterstartindex = randomint( 4 );
}

selectcharacterindextouse()
{
    if ( level.characterstartindex >= 4 )
        level.characterstartindex = 0;

    self.characterindex = level.characterstartindex;
    level.characterstartindex++;
    return self.characterindex;
}

givecustomcharacters()
{
    self detachall();

    switch ( self selectcharacterindextouse() )
    {
        case 0:
            self character\c_usa_dempsey_zm::main();
            self setviewmodel( "viewmodel_usa_pow_arms" );
            self.characterindex = 0;
            break;
        case 1:
            self character\c_rus_nikolai_zm::main();
            self setviewmodel( "viewmodel_rus_prisoner_arms" );
            self.characterindex = 1;
            break;
        case 2:
            self character\c_jap_takeo_zm::main();
            self setviewmodel( "viewmodel_vtn_nva_standard_arms" );
            self.characterindex = 2;
            break;
        case 3:
            self character\c_ger_richtofen_zm::main();
            self setviewmodel( "viewmodel_usa_hazmat_arms" );
            self.characterindex = 3;
            break;
    }

    self setmovespeedscale( 1 );
    self setsprintduration( 4 );
    self setsprintcooldown( 0 );
}

gasmask_get_head_model( entity_num, gasmask_active )
{
    if ( gasmask_active )
        return "c_zom_moon_pressure_suit_helm";

    switch ( entity_num )
    {
        case 0:
            return "c_usa_dempsey_dlc5_head";
        case 1:
            return "c_rus_nikolai_dlc5_head_psuit";
        case 2:
            return "c_jap_takeo_dlc5_head";
        case 3:
            return "c_ger_richtofen_dlc5_head";
    }
}

gasmask_change_player_headmodel( entity_num, gasmask_active )
{
    if ( isdefined( self.headmodel ) )
        self detach( self.headmodel, "" );

    self.headmodel = gasmask_get_head_model( entity_num, gasmask_active );
    self attach( self.headmodel, "", 1 );
}

gasmask_set_player_model( entity_num )
{
    player_is_nikolai = 0;

    if ( 1 == entity_num )
    {
        player_is_nikolai = 1;

        if ( isdefined( self.headmodel ) )
            self detach( self.headmodel, "" );
    }

    self setmodel( "c_zom_moon_pressure_suit_body_player" );

    if ( player_is_nikolai )
    {
        self.headmodel = gasmask_get_head_model( entity_num, 0 );
        self attach( self.headmodel, "", 1 );
    }
}

gasmask_set_player_viewmodel( entity_num )
{
    self setviewmodel( "viewmodel_zom_pressure_suit_arms" );
    self clientnotify( "gmsk" );
}

gasmask_reset_player_model( entity_num )
{
    if ( isdefined( self.zm_random_char ) )
        entity_num = self.zm_random_char;

    self detach( self.headmodel, "" );

    switch ( entity_num )
    {
        case 0:
            self character\c_usa_dempsey_zm::main();
            break;
        case 1:
            self character\c_rus_nikolai_zm::main();
            break;
        case 2:
            self character\c_jap_takeo_zm::main();
            break;
        case 3:
            self character\c_ger_richtofen_zm::main();
            break;
    }
}

gasmask_reset_player_set_viewmodel( entity_num )
{
    if ( isdefined( self.zm_random_char ) )
        entity_num = self.zm_random_char;

    switch ( self.entity_num )
    {
        case 0:
            self setviewmodel( "viewmodel_usa_pow_arms" );
            self clientnotify( "gmsk" );
            break;
        case 1:
            self setviewmodel( "viewmodel_rus_prisoner_arms" );
            self clientnotify( "gmsk" );
            break;
        case 2:
            self setviewmodel( "viewmodel_vtn_nva_standard_arms" );
            self clientnotify( "gmsk" );
            break;
        case 3:
            self setviewmodel( "viewmodel_usa_hazmat_arms" );
            self clientnotify( "gmsk" );
            break;
    }
}

moon_offhand_weapon_overrride()
{
    register_lethal_grenade_for_level( "frag_grenade_zm" );
    register_lethal_grenade_for_level( "sticky_grenade_zm" );
    level.zombie_lethal_grenade_player_init = "frag_grenade_zm";
    register_tactical_grenade_for_level( "zombie_black_hole_bomb" );
    level.zombie_tactical_grenade_player_init = undefined;
    register_tactical_grenade_for_level( "zombie_quantum_bomb" );
    register_placeable_mine_for_level( "claymore_zm" );
    level.zombie_placeable_mine_player_init = undefined;
    register_melee_weapon_for_level( "knife_zm" );
    register_melee_weapon_for_level( "bowie_knife_zm" );
    level.zombie_melee_weapon_player_init = "knife_zm";
    register_equipment_for_level( "equip_gasmask_zm" );
    register_equipment_for_level( "equip_hacker_zm" );
    level.zombie_equipment_player_init = undefined;
}

offhand_weapon_give_override( str_weapon )
{
    self endon( "death" );

    if ( is_tactical_grenade( str_weapon ) && isdefined( self get_player_tactical_grenade() ) && !self is_player_tactical_grenade( str_weapon ) )
    {
        self setweaponammoclip( self get_player_tactical_grenade(), 0 );
        self takeweapon( self get_player_tactical_grenade() );
    }

    if ( str_weapon == "zombie_black_hole_bomb" )
    {
        self maps\mp\zombies\_zm_weap_black_hole_bomb::player_give_black_hole_bomb();
        return true;
    }

    if ( str_weapon == "zombie_quantum_bomb" )
    {
        self maps\mp\zombies\_zm_weap_quantum_bomb::player_give_quantum_bomb();
        return true;
    }

    return false;
}

include_powerups()
{
    include_powerup( "nuke" );
    include_powerup( "insta_kill" );
    include_powerup( "double_points" );
    include_powerup( "full_ammo" );
    include_powerup( "carpenter" );
    include_powerup( "fire_sale" );
    include_powerup( "free_perk" );
    include_powerup( "random_weapon" );
    include_powerup( "bonus_points_player" );
    include_powerup( "bonus_points_team" );
    include_powerup( "lose_points_team" );
    include_powerup( "lose_perk" );
    include_powerup( "empty_clip" );
}

include_equipment_for_level()
{
    include_equipment( "equip_gasmask_zm" );
    include_equipment( "equip_hacker_zm" );
}

init_sounds()
{

}

electric_switch()
{
    trig = getent( "use_elec_switch", "targetname" );
    trig sethintstring( &"ZOMBIE_ELECTRIC_SWITCH" );
    trig setcursorhint( "HINT_NOICON" );
    level thread wait_for_power();
    trig thread maps\mp\zombies\_zm_perks::vending_machine_trigger_think();
    trig waittill( "trigger", user );

    if ( isdefined( trig ) )
        trig delete();

    maps\mp\zombies\_zm_game_module::turn_power_on_and_open_doors();
    user thread delayed_poweron_vox();
}

delayed_poweron_vox()
{
    self endon( "death" );
    self endon( "disconnect" );
    wait 11.5;

    if ( isdefined( self ) )
        self thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "poweron" );
}

wait_for_power()
{
    master_switch = getent( "elec_switch", "targetname" );
    master_switch notsolid();
    flag_wait( "power_on" );
    master_switch rotateroll( -90, 0.3 );
    master_switch playsound( "zmb_switch_flip" );
    level notify( "revive_on" );
    wait_network_frame();
    level notify( "doubletap_on" );
    wait_network_frame();
    level notify( "divetonuke_on" );
    wait_network_frame();
    level notify( "marathon_on" );
    wait_network_frame();
    level notify( "deadshot_on" );
    wait_network_frame();
    level notify( "additionalprimaryweapon_on" );
    wait_network_frame();
    level notify( "electric_door" );
    clientnotify( "ZPO" );
    master_switch waittill( "rotatedone" );
    playfx( level._effect["switch_sparks"], getstruct( "elec_switch_fx", "targetname" ).origin );
    master_switch playsound( "zmb_turn_on" );
}

moon_devgui( cmd )
{
/#
    cmd_strings = strtok( cmd, " " );

    switch ( cmd_strings[0] )
    {
        case "power":
            trigger = getent( "use_elec_switch", "targetname" );

            if ( !isdefined( trigger ) )
                return;

            iprintln( "Activating power" );
            trigger notify( "trigger", get_players()[0] );
            break;
        case "warp_nml":
            players = get_players();
            teleporter = getent( "generator_teleporter", "targetname" );

            for ( i = 0; i < players.size; i++ )
                players[i] setorigin( teleporter.origin );

            break;
        case "digger_hangar":
            maps\mp\zm_moon_digger::digger_activate( "hangar" );
            break;
        case "digger_teleporter":
            maps\mp\zm_moon_digger::digger_activate( "teleporter" );
            break;
        case "digger_biodome":
            maps\mp\zm_moon_digger::digger_activate( "biodome" );
            break;
        case "digger_speed":
            level.digger_speed_multiplier = getdvarfloat( #"_id_1261CFA6" );
            iprintlnbold( level.digger_speed_multiplier );
            break;
        case "spawn":
            player = get_players()[0];
            spawnerclass = cmd_strings[1];
            spawners = getentarray( spawnerclass, "classname" );

            if ( !isdefined( spawners ) || spawners.size == 0 )
                return;

            for ( spawnernum = 0; spawners[spawnernum].spawnflags % 2 == 0; spawnernum++ )
            {

            }

            if ( spawnernum >= spawners.size )
                return;

            spawner = spawners[spawnernum];
            guy = undefined;
            direction = player getplayerangles();
            direction_vec = anglestoforward( direction );
            eye = player geteye();
            scale = 8000;
            direction_vec = ( direction_vec[0] * scale, direction_vec[1] * scale, direction_vec[2] * scale );
            trace = bullettrace( eye, eye + direction_vec, 0, undefined );
            originoffset = ( 0, 0, 0 );

            if ( isdefined( guy ) )
            {
                teleportorigin = trace["position"] + originoffset;
                guy forceteleport( teleportorigin, player.angles + vectorscale( ( 0, 1, 0 ), 180.0 ) );
            }

            break;
    }
#/
}

custom_add_weapons()
{
    add_zombie_weapon( "m1911_zm", "m1911_upgraded_zm", &"ZOMBIE_WEAPON_M1911", 50, "pistol", "", undefined );
    add_zombie_weapon( "python_zm", "python_upgraded_zm", &"ZOMBIE_WEAPON_PYTHON", 50, "pistol", "", undefined );
    add_zombie_weapon( "ak74u_zm", "ak74u_upgraded_zm", &"ZOMBIE_WEAPON_AK74U", 1200, "smg", "", undefined );
    add_zombie_weapon( "mp5k_zm", "mp5k_upgraded_zm", &"ZOMBIE_WEAPON_MP5K", 1000, "smg", "", undefined );
    add_zombie_weapon( "srm1216_zm", "srm1216_upgraded_zm", &"ZOMBIE_WEAPON_SRM1216", 50, "shotgun", "", undefined );
    add_zombie_weapon( "rottweil72_zm", "rottweil72_upgraded_zm", &"ZOMBIE_WEAPON_ROTTWEIL72", 500, "shotgun", "", undefined );
    add_zombie_weapon( "m14_zm", "m14_upgraded_zm", &"ZOMBIE_WEAPON_M14", 500, "rifle", "", undefined );
    add_zombie_weapon( "m16_zm", "m16_gl_upgraded_zm", &"ZOMBIE_WEAPON_M16", 1200, "burstrifle", "", undefined );
    add_zombie_weapon( "galil_zm", "galil_upgraded_zm", &"ZOMBIE_WEAPON_GALIL", 50, "assault", "", undefined );
    add_zombie_weapon( "sa58_zm", "sa58_upgraded_zm", &"ZOMBIE_WEAPON_SA58", 50, "burstrifle", "", undefined );
    add_zombie_weapon( "frag_grenade_zm", undefined, &"ZOMBIE_WEAPON_FRAG_GRENADE", 250, "grenade", "", undefined );
    add_zombie_weapon( "sticky_grenade_zm", undefined, &"ZOMBIE_WEAPON_STICKY_GRENADE", 250, "grenade", "", undefined );
    add_zombie_weapon( "claymore_zm", undefined, &"ZOMBIE_WEAPON_CLAYMORE", 1000, "grenade", "", undefined );
    add_zombie_weapon( "cymbal_monkey_zm", undefined, &"ZOMBIE_WEAPON_SATCHEL_2000", 2000, "monkey", "", undefined );
    add_zombie_weapon( "ray_gun_zm", "ray_gun_upgraded_zm", &"ZOMBIE_WEAPON_RAYGUN", 10000, "raygun", "", undefined );
    add_zombie_weapon( "knife_ballistic_zm", "knife_ballistic_upgraded_zm", &"ZOMBIE_WEAPON_KNIFE_BALLISTIC", 10, "sickle", "", undefined );
    add_zombie_weapon( "knife_ballistic_bowie_zm", "knife_ballistic_bowie_upgraded_zm", &"ZOMBIE_WEAPON_KNIFE_BALLISTIC", 10, "sickle", "", undefined );
    add_zombie_weapon( "fiveseven_zm", "fiveseven_upgraded_zm", &"ZOMBIE_WEAPON_FIVESEVEN", 50, "pistol", "", undefined );
    add_zombie_weapon( "mp40_zm", "mp40_upgraded_zm", &"ZOMBIE_WEAPON_MP40", 1000, "smg", "", undefined );
    add_zombie_weapon( "beretta93r_zm", "beretta93r_upgraded_zm", &"ZOMBIE_WEAPON_BERETTA93R", 1000, "smg", "", undefined );
    add_zombie_weapon( "pdw57_zm", "pdw57_upgraded_zm", &"ZOMBIE_WEAPON_PDW57", 1000, "smg", "", undefined );
    add_zombie_weapon( "kard_zm", "kard_upgraded_zm", &"ZOMBIE_WEAPON_KARD", 50, "smg", "", undefined );
    add_zombie_weapon( "fivesevendw_zm", "fivesevendw_upgraded_zm", &"ZOMBIE_WEAPON_FIVESEVENDW", 50, "dualwield", "", undefined );
    add_zombie_weapon( "870mcs_zm", "870mcs_upgraded_zm", &"ZOMBIE_WEAPON_ITHACA", 1500, "shotgun", "", undefined );
    add_zombie_weapon( "saiga12_zm", "saiga12_upgraded_zm", &"ZOMBIE_WEAPON_SAIGA12", 50, "shotgun", "", undefined );
    add_zombie_weapon( "xm8_zm", "xm8_upgraded_zm", &"ZOMBIE_WEAPON_XM8", 900, "burstrifle", "", undefined );
    add_zombie_weapon( "type95_zm", "type95_upgraded_zm", &"ZOMBIE_WEAPON_TYPE95", 50, "burstrifle", "", undefined );
    add_zombie_weapon( "tar21_zm", "tar21_upgraded_zm", &"ZOMBIE_WEAPON_TAR21", 1200, "assault", "", undefined );
    add_zombie_weapon( "hk416_zm", "hk416_upgraded_zm", &"ZOMBIE_WEAPON_HK416", 100, "assault", "", undefined );
    add_zombie_weapon( "barretm82_zm", "barretm82_upgraded_zm", &"ZOMBIE_WEAPON_BARRETM82", 2500, "sniper", "", undefined );
    add_zombie_weapon( "dsr50_zm", "dsr50_upgraded_zm", &"ZOMBIE_WEAPON_DSR50", 50, "sniper", "", undefined );
    add_zombie_weapon( "rpd_zm", "rpd_upgraded_zm", &"ZOMBIE_WEAPON_RPD", 4000, "mg", "", undefined );
    add_zombie_weapon( "hamr_zm", "hamr_upgraded_zm", &"ZOMBIE_WEAPON_HAMR", 50, "mg", "", undefined );
    add_zombie_weapon( "usrpg_zm", "usrpg_upgraded_zm", &"ZOMBIE_WEAPON_USRPG", 2000, "launcher", "", undefined );
    add_zombie_weapon( "m32_zm", "m32_upgraded_zm", &"ZOMBIE_WEAPON_M32", 2000, "launcher", "", undefined );
    add_zombie_weapon( "zombie_black_hole_bomb", undefined, &"ZOMBIE_WEAPON_SATCHEL_2000", 2000, "gersh", "", undefined );
    add_zombie_weapon( "zombie_quantum_bomb", undefined, &"ZOMBIE_WEAPON_SATCHEL_2000", 2000, "quantum", "", undefined );
    add_zombie_weapon( "microwavegundw_zm", "microwavegundw_upgraded_zm", &"ZOMBIE_WEAPON_MICROWAVEGUN_DW", 10, "microwave", "", undefined );
}

moon_zombie_death_response()
{
    self startragdoll();
    rag_x = randomintrange( -50, 50 );
    rag_y = randomintrange( -50, 50 );
    rag_z = randomintrange( 25, 45 );
    force_min = 75;
    force_max = 100;

    if ( self.damagemod == "MOD_MELEE" )
    {
        force_min = 40;
        force_max = 50;
        rag_z = 15;
    }
    else if ( self.damageweapon == "m1911_zm" )
    {
        force_min = 60;
        force_max = 75;
        rag_z = 20;
    }
    else if ( self.damageweapon == "870mcs_zm" || self.damageweapon == "870mcs_upgraded_zm" || self.damageweapon == "ithaca_zm" || self.damageweapon == "ithaca_upgraded_zm" || self.damageweapon == "rottweil72_zm" || self.damageweapon == "rottweil72_upgraded_zm" || self.damageweapon == "srm1216_zm" || self.damageweapon == "srm1216_upgraded_zm" || self.damageweapon == "spas_zm" || self.damageweapon == "spas_upgraded_zm" || self.damageweapon == "hs10_zm" || self.damageweapon == "hs10_upgraded_zm" || self.damageweapon == "saiga12_zm" || self.damageweapon == "saiga12_upgraded_zm" )
    {
        force_min = 100;
        force_max = 150;
    }

    scale = randomintrange( force_min, force_max );
    rag_x = self.damagedir[0] * scale;
    rag_y = self.damagedir[1] * scale;
    dir = ( rag_x, rag_y, rag_z );
    self launchragdoll( dir );
    return false;
}

setup_water_physics()
{
    flag_wait( "start_zombie_round_logic" );
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {

    }
}

cliff_fall_death()
{
    trig = getent( "cliff_fall_death", "targetname" );

    if ( isdefined( trig ) )
    {
        while ( true )
        {
            trig waittill( "trigger", who );

            if ( !is_true( who.insta_killed ) )
                who thread insta_kill_player();
        }
    }
}

insta_kill_player()
{
    self endon( "disconnect" );

    if ( is_true( self.insta_killed ) )
        return;

    if ( is_player_killable( self ) )
    {
        self.insta_killed = 1;
        in_last_stand = 0;

        if ( self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
            in_last_stand = 1;

        if ( flag( "solo_game" ) )
        {
            if ( isdefined( self.lives ) && self.lives > 0 )
            {
                self.waiting_to_revive = 1;

                if ( flag( "both_tunnels_breached" ) )
                {
                    point = moon_digger_respawn( self );

                    if ( !isdefined( point ) )
                    {
                        points = getstruct( "bridge_zone", "script_noteworthy" );
                        spawn_points = getstructarray( points.target, "targetname" );
                        num = self.characterindex;
                        point = spawn_points[num];
                    }
                }
                else
                {
                    points = getstruct( "bridge_zone", "script_noteworthy" );
                    spawn_points = getstructarray( points.target, "targetname" );
                    num = self.characterindex;
                    point = spawn_points[num];
                }

                self dodamage( self.health + 1000, ( 0, 0, 0 ) );
                wait 1.5;
                self setorigin( point.origin + vectorscale( ( 0, 0, 1 ), 20.0 ) );
                self.angles = point.angles;

                if ( in_last_stand )
                {
                    flag_set( "instant_revive" );
                    wait_network_frame();
                    flag_clear( "instant_revive" );
                }
                else
                {
                    self thread maps\mp\zombies\_zm_laststand::auto_revive( self );
                    self.waiting_to_revive = 0;
                    self.solo_respawn = 0;
                    self.lives = 0;
                }
            }
            else
                self dodamage( self.health + 1000, ( 0, 0, 0 ) );
        }
        else
        {
            self dodamage( self.health + 1000, ( 0, 0, 0 ) );
            wait_network_frame();
            self.bleedout_time = 0;
        }

        self.insta_killed = 0;
    }
}

moon_respawn_override( player )
{
    if ( flag( "both_tunnels_breached" ) )
    {
        point = moon_digger_respawn( player );

        if ( isdefined( point ) )
        {
            self notify( "one_giant_leap" );
            return point.origin;
        }
    }
    else
        return undefined;

    return undefined;
}

is_player_killable( player, checkignoremeflag )
{
    if ( !isdefined( player ) )
        return false;

    if ( !isalive( player ) )
        return false;

    if ( !isplayer( player ) )
        return false;

    if ( player.sessionstate == "spectator" )
        return false;

    if ( player.sessionstate == "intermission" )
        return false;

    if ( isdefined( checkignoremeflag ) && player.ignoreme )
        return false;

    return true;
}

moon_digger_respawn( revivee )
{
    spawn_points = getstructarray( "player_respawn_point", "targetname" );

    if ( level.zones["airlock_west2_zone"].is_enabled )
    {
        for ( i = 0; i < spawn_points.size; i++ )
        {
            if ( spawn_points[i].script_noteworthy == "airlock_west2_zone" )
            {
                spawn_array = getstructarray( spawn_points[i].target, "targetname" );

                for ( j = 0; j < spawn_array.size; j++ )
                {
                    if ( spawn_array[j].script_int == revivee.entity_num + 1 )
                        return spawn_array[j];
                }

                return spawn_array[0];
            }
        }
    }
    else if ( level.zones["airlock_east2_zone"].is_enabled )
    {
        for ( i = 0; i < spawn_points.size; i++ )
        {
            if ( spawn_points[i].script_noteworthy == "airlock_east2_zone" )
            {
                spawn_array = getstructarray( spawn_points[i].target, "targetname" );

                for ( j = 0; j < spawn_array.size; j++ )
                {
                    if ( spawn_array[j].script_int == revivee.entity_num + 1 )
                        return spawn_array[j];
                }

                return spawn_array[0];
            }
        }
    }

    return undefined;
}

moon_reset_respawn_overide()
{
    level waittill( "between_round_over" );
    level.check_valid_spawn_override = undefined;
}

init_extra_blackhole_anims()
{

}

blackhole_bomb_area_check()
{
    black_hole_teleport_structs = undefined;
    org = spawn( "script_origin", ( 0, 0, 0 ) );

    if ( flag( "enter_nml" ) )
        black_hole_teleport_structs = getstructarray( "struct_black_hole_teleport_nml", "targetname" );
    else if ( flag( "both_tunnels_blocked" ) )
    {
        black_hole_teleport_structs = getstructarray( "struct_black_hole_teleport", "targetname" );
        all_players_trapped = 0;
        final_structs = black_hole_teleport_structs;
        discarded_zones = [];
        all_players = get_players();
        all_zones = getentarray( "player_volume", "script_noteworthy" );
        players_touching = 0;

        for ( x = 0; x < all_zones.size; x++ )
        {
            switch ( all_zones[x].targetname )
            {
                case "airlock_bridge_zone":
                case "airlock_east_zone":
                case "airlock_west_zone":
                case "bridge_zone":
                case "cata_left_middle_zone":
                case "cata_left_start_zone":
                case "cata_right_start_zone":
                case "water_zone":
                    discarded_zones[discarded_zones.size] = all_zones[x];

                    for ( i = 0; i < all_players.size; i++ )
                    {
                        player = all_players[i];
                        equipment = player get_player_equipment();

                        if ( isdefined( equipment ) && equipment == "equip_hacker_zm" )
                        {
                            org delete();
                            return black_hole_teleport_structs;
                        }
                        else if ( player istouching( all_zones[x] ) )
                            players_touching++;
                    }

                    break;
                default:
                    break;
            }
        }

        if ( players_touching == all_players.size )
            all_players_trapped = 1;

        if ( all_players_trapped )
        {
            for ( i = 0; i < black_hole_teleport_structs.size; i++ )
            {
                for ( x = 0; x < discarded_zones.size; x++ )
                {
                    org.origin = black_hole_teleport_structs[i].origin;

                    if ( org istouching( discarded_zones[x] ) )
                        arrayremovevalue( final_structs, black_hole_teleport_structs[i] );
                }
            }

            black_hole_teleport_structs = final_structs;
        }
        else
            black_hole_teleport_structs = getstructarray( "struct_black_hole_teleport", "targetname" );
    }
    else
        black_hole_teleport_structs = getstructarray( "struct_black_hole_teleport", "targetname" );

    org delete();
    return black_hole_teleport_structs;
}

get_blackholebomb_destination_point( black_hole_teleport_structs, ent_player )
{
    player_zones = getentarray( "player_volume", "script_noteworthy" );
    valid_struct = undefined;
    scr_org = undefined;

    for ( x = 0; x < black_hole_teleport_structs.size; x++ )
    {
        if ( !isdefined( scr_org ) )
            scr_org = spawn( "script_origin", black_hole_teleport_structs[x].origin + vectorscale( ( 0, 0, 1 ), 40.0 ) );
        else
            scr_org.origin = black_hole_teleport_structs[x].origin + vectorscale( ( 0, 0, 1 ), 40.0 );

        for ( i = 0; i < player_zones.size; i++ )
        {
            if ( scr_org istouching( player_zones[i] ) )
            {
                if ( isdefined( level.zones[player_zones[i].targetname] ) && is_true( level.zones[player_zones[i].targetname].is_enabled ) )
                {
                    if ( flag( "enter_nml" ) )
                    {
                        valid_struct = black_hole_teleport_structs[x];
                        scr_org delete();
                        return valid_struct;
                    }
                    else if ( ent_player get_current_zone() != player_zones[i].targetname )
                    {
                        valid_struct = black_hole_teleport_structs[x];
                        scr_org delete();
                        return valid_struct;
                    }
                }
            }
        }
    }
}

blackhole_bomb_in_invalid_area( grenade, model, player )
{
    invalid_area = getent( "bhb_invalid_area", "targetname" );

    if ( model istouching( invalid_area ) )
        return true;
    else
        return false;
}

quantum_bomb_prevent_player_getting_teleported_override( position )
{
    if ( is_true( self._padded ) )
        return true;

    return false;
}

wait_for_end_game()
{
    level waittill( "intermission" );
    level clientnotify( "EDR" );
}

moon_perk_lost( perk )
{
    self maps\mp\zombies\_zm_perks::update_perk_hud();
}

moon_black_hole_bomb_poi()
{
    astro = getent( "astronaut_zombie_ai", "targetname" );

    if ( isdefined( astro ) )
        astro add_poi_to_ignore_list( self );
}

end_game_vision_and_fog_fix()
{
    level waittill( "end_game" );
    clientnotify( "ZEG" );
}

moon_bhb_poi_control()
{
    self endon( "death" );
    moon_pois = getentarray( "zombie_poi", "script_noteworthy" );
    pack_enclosure = getent( "pack_enclosure", "targetname" );

    if ( !isdefined( moon_pois ) || moon_pois.size == 0 )
        return undefined;

    for ( i = 0; i < moon_pois.size; i++ )
    {
        if ( isdefined( moon_pois[i].targetname ) && moon_pois[i].targetname == "zm_bhb" )
        {
            if ( !flag( "packapunch_hacked" ) )
                return undefined;
            else
            {
                self._bhb_pull = 1;
                bhb_position = self moon_bhb_choice( moon_pois[i] );
                return bhb_position;
            }
        }
    }

    self._bhb_pull = 0;
    return undefined;
}

moon_bhb_choice( ent_poi )
{
    bhb_position = [];
    bhb_position[0] = groundpos( ent_poi.origin + vectorscale( ( 0, 0, 1 ), 100.0 ) );
    bhb_position[1] = self;

    if ( isdefined( ent_poi.initial_attract_func ) )
        self thread [[ ent_poi.initial_attract_func ]]( ent_poi );

    if ( isdefined( ent_poi.arrival_attract_func ) )
        self thread [[ ent_poi.arrival_attract_func ]]( ent_poi );

    return bhb_position;
}

override_quad_explosion( quad )
{
    if ( isdefined( quad.in_low_gravity ) && quad.in_low_gravity == 1 )
        quad.can_explode = 0;
}

moon_speed_up()
{
    self set_zombie_run_cycle( "sprint" );

    if ( is_true( self.in_low_gravity ) )
        self thread maps\mp\zm_moon_gravity::zombie_low_gravity_locomotion();
}

init_level_specific_wall_buy_fx()
{

}
