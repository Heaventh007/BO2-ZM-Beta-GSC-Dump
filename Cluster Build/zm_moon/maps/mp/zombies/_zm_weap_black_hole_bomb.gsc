// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_audio;

init()
{
    if ( !black_hole_bomb_exists() )
        return;

    black_hole_bomb_anim_init();
    level._effect["black_hole_bomb_portal"] = loadfx( "maps/zombie/fx_zmb_blackhole_looping" );
    level._effect["black_hole_bomb_portal_exit"] = loadfx( "maps/zombie/fx_zmb_blackhole_exit" );
    level._effect["black_hole_bomb_zombie_soul"] = loadfx( "maps/zombie/fx_zmb_blackhole_zombie_death" );
    level._effect["black_hole_bomb_zombie_destroy"] = loadfx( "maps/zombie/fx_zmb_blackhole_zombie_flare" );
    level._effect["black_hole_bomb_zombie_gib"] = loadfx( "maps/zombie/fx_zombie_dog_explosion" );
    level._effect["black_hole_bomb_event_horizon"] = loadfx( "maps/zombie/fx_zmb_blackhole_implode" );
    level._effect["black_hole_samantha_steal"] = loadfx( "maps/zombie/fx_zmb_blackhole_trap_end" );
    level._effect["black_hole_bomb_zombie_pull"] = loadfx( "maps/zombie/fx_blackhole_zombie_breakup" );
    level._effect["black_hole_bomb_marker_flare"] = loadfx( "maps/zombie/fx_zmb_blackhole_flare_marker" );
/#
    level.zombiemode_devgui_black_hole_bomb_give = ::player_give_black_hole_bomb;
#/
    registerclientfield( "scriptmover", "blackhole", 7000, 1, "int" );
    registerclientfield( "actor", "blackhole", 7000, 1, "int" );
    level.zombie_death_animscript_override = ::black_hole_bomb_corpse_hide;
    level.black_hole_bomb_poi_initial_attract_func = ::black_hole_bomb_initial_attract_func;
    level.black_hole_bomb_poi_arrival_attract_func = ::black_hole_bomb_arrival_attract_func;
    level._black_hole_bomb_zombies_anim_change = [];
    flag_init( "bhb_anim_change_allowed" );
    level thread black_hole_bomb_throttle_anim_changes();
    flag_set( "bhb_anim_change_allowed" );
}

player_give_black_hole_bomb()
{
    self giveweapon( "zombie_black_hole_bomb" );
    self set_player_tactical_grenade( "zombie_black_hole_bomb" );
    self thread player_handle_black_hole_bomb();
}

player_handle_black_hole_bomb()
{
    self notify( "starting_black_hole_bomb" );
    self endon( "disconnect" );
    self endon( "starting_black_hole_bomb" );
    attract_dist_diff = level.black_hole_attract_dist_diff;

    if ( !isdefined( attract_dist_diff ) )
        attract_dist_diff = 10;

    num_attractors = level.num_black_hole_bomb_attractors;

    if ( !isdefined( num_attractors ) )
        num_attractors = 15;

    max_attract_dist = level.black_hole_bomb_attract_dist;

    if ( !isdefined( max_attract_dist ) )
        max_attract_dist = 2056;

    while ( true )
    {
        grenade = get_thrown_black_hole_bomb();

        if ( isdefined( grenade ) )
        {
            if ( self maps\mp\zombies\_zm_laststand::player_is_in_laststand() || is_true( self.intermission ) )
            {
                grenade delete();
                continue;
            }

            grenade hide();
            model = spawn( "script_model", grenade.origin );
            str_weap_model = getweaponmodel( "zombie_black_hole_bomb" );
            model setmodel( str_weap_model );
            model linkto( grenade );
            model.angles = grenade.angles;
            info = spawnstruct();
            info.sound_attractors = [];
            grenade thread monitor_zombie_groans( info );
            velocitysq = 100000000;

            for ( oldpos = grenade.origin; velocitysq != 0; oldpos = grenade.origin )
            {
                wait 0.05;

                if ( !isdefined( grenade ) )
                    break;

                velocitysq = distancesquared( grenade.origin, oldpos );
            }

            if ( isdefined( grenade ) )
            {
                self thread black_hole_bomb_kill_counter( grenade );
                model unlink();
                model.origin = grenade.origin;
                model.angles = grenade.angles;
                model._black_hole_bomb_player = self;
                model.targetname = "zm_bhb";
                model._new_ground_trace = 1;
                grenade resetmissiledetonationtime();

                if ( isdefined( level.black_hole_bomb_loc_check_func ) )
                {
                    if ( [[ level.black_hole_bomb_loc_check_func ]]( grenade, model, info ) )
                        continue;
                }

                if ( isdefined( level._blackhole_bomb_valid_area_check ) )
                {
                    if ( [[ level._blackhole_bomb_valid_area_check ]]( grenade, model, self ) )
                        continue;
                }

                valid_poi = check_point_in_enabled_zone( grenade.origin, undefined, undefined );

                if ( valid_poi )
                {
                    level thread black_hole_bomb_cleanup( grenade, model );

                    if ( isdefined( level._black_hole_bomb_poi_override ) )
                        model thread [[ level._black_hole_bomb_poi_override ]]();

                    model create_zombie_point_of_interest( max_attract_dist, num_attractors, 0, 1, level.black_hole_bomb_poi_initial_attract_func, level.black_hole_bomb_poi_arrival_attract_func );
                    model setclientfield( "blackhole", 1 );
                    grenade thread do_black_hole_bomb_sound( model, info );
                    level thread black_hole_bomb_teleport_init( grenade );
                    grenade.is_valid = 1;
                }
                else
                {
                    self.script_noteworthy = undefined;
                    level thread black_hole_bomb_stolen_by_sam( self, model );
                }
            }
            else
            {
                self.script_noteworthy = undefined;
                level thread black_hole_bomb_stolen_by_sam( self, model );
            }
        }

        wait 0.05;
    }
}

wait_for_attractor_positions_complete()
{
    self waittill( "attractor_positions_generated" );
    self.attract_to_origin = 0;
}

black_hole_bomb_cleanup( parent, model )
{
    model endon( "sam_stole_it" );
    grenade_org = parent.origin;

    while ( true )
    {
        if ( !isdefined( parent ) )
        {
            if ( isdefined( model ) )
            {
                model delete();
                wait_network_frame();
            }

            break;
        }

        wait 0.05;
    }

    level thread black_hole_bomb_corpse_collect( grenade_org );
}

black_hole_bomb_corpse_collect( vec_origin )
{
    wait 0.1;
    corpse_array = getcorpsearray();

    for ( i = 0; i < corpse_array.size; i++ )
    {
        if ( distancesquared( corpse_array[i].origin, vec_origin ) < 36864 )
            corpse_array[i] thread black_hole_bomb_corpse_delete();
    }
}

black_hole_bomb_corpse_delete()
{
    self delete();
}

do_black_hole_bomb_sound( model, info )
{
    monk_scream_vox = 0;

    if ( level.music_override == 0 )
        monk_scream_vox = 0;

    self playsound( "wpn_gersh_device_exp" );
    self playloopsound( "wpn_gersh_device_loop_close" );
    fakeorigin = self.origin;
    self waittill( "explode", position );
    playsoundatposition( "wpn_gersh_device_implode", fakeorigin );

    if ( isdefined( model ) )
    {

    }

    for ( i = 0; i < info.sound_attractors.size; i++ )
    {
        if ( isdefined( info.sound_attractors[i] ) )
            info.sound_attractors[i] notify( "black_hole_bomb_blown_up" );
    }

    if ( !monk_scream_vox )
        play_sound_in_space( "zmb_vox_monkey_explode", position );
}

get_thrown_black_hole_bomb()
{
    self endon( "disconnect" );
    self endon( "starting_black_hole_bomb" );

    while ( true )
    {
        self waittill( "grenade_fire", grenade, weapname );

        if ( weapname == "zombie_black_hole_bomb" )
            return grenade;

        wait 0.05;
    }
}

monitor_zombie_groans( info )
{
    self endon( "explode" );

    while ( true )
    {
        if ( !isdefined( self ) )
            return;

        if ( !isdefined( self.attractor_array ) )
        {
            wait 0.05;
            continue;
        }

        for ( i = 0; i < self.attractor_array.size; i++ )
        {
            if ( array_check_for_dupes( info.sound_attractors, self.attractor_array[i] ) )
            {
                if ( isdefined( self.origin ) && isdefined( self.attractor_array[i].origin ) )
                {
                    if ( distancesquared( self.origin, self.attractor_array[i].origin ) < 250000 )
                    {
                        info.sound_attractors[info.sound_attractors.size] = self.attractor_array[i];
                        self.attractor_array[i] thread play_zombie_groans();
                    }
                }
            }
        }

        wait 0.05;
    }
}

play_zombie_groans()
{
    self endon( "death" );
    self endon( "black_hole_bomb_blown_up" );

    while ( true )
    {
        if ( isdefined( self ) )
        {
            self playsound( "zmb_vox_zombie_groan" );
            wait( randomfloatrange( 2, 3 ) );
        }
        else
            return;
    }
}

black_hole_bomb_exists()
{
    return isdefined( level.zombie_weapons["zombie_black_hole_bomb"] );
}

black_hole_bomb_initial_attract_func( ent_poi )
{
    self endon( "death" );

    if ( isdefined( self.pre_black_hole_bomb_run_combatanim ) )
        return;

    if ( isdefined( self.script_string ) && self.script_string == "riser" )
    {
        while ( is_true( self.in_the_ground ) )
            wait 0.05;
    }

    soul_spark_end = ent_poi.origin;
    soul_burst_range = 2500;
    pulled_in_range = 16384;
    inner_range = 1048576;
    outer_edge = 4227136;
    distance_to_black_hole = 1410065408;
    self._distance_to_black_hole = 1410065408;
    self._black_hole_bomb_collapse_death = 0;
    self._black_hole_attract_walk = 0;
    self._black_hole_attract_run = 0;
    self._current_black_hole_bomb_origin = ent_poi.origin;
    self._normal_run_blend_time = 0.2;
    self._black_hole_bomb_tosser = ent_poi._black_hole_bomb_player;
    self._black_hole_bomb_being_pulled_in_fx = 0;
    self.deathanim = self black_hole_bomb_death_while_attracted();

    if ( !isdefined( self._bhb_ent_flag_init ) )
    {
        self ent_flag_init( "bhb_anim_change" );
        self._bhb_ent_flag_init = 1;
    }

    if ( isdefined( level._black_hole_attract_override ) )
        level [[ level._black_hole_attract_override ]]();

    while ( isdefined( ent_poi ) )
    {
        self._distance_to_black_hole = distancesquared( self.origin, self._current_black_hole_bomb_origin );

        if ( self._black_hole_attract_walk == 0 && ( self._distance_to_black_hole < outer_edge && self._distance_to_black_hole > inner_range ) )
        {
            if ( isdefined( self._bhb_walk_attract ) )
                self [[ self._bhb_walk_attract ]]();
            else
                self black_hole_bomb_attract_walk();
        }

        if ( self._black_hole_attract_run == 0 && ( self._distance_to_black_hole < inner_range && self._distance_to_black_hole > pulled_in_range ) )
        {
            if ( isdefined( self._bhb_run_attract ) )
                self [[ self._bhb_run_attract ]]();
            else
                self black_hole_bomb_attract_run();
        }

        if ( self._distance_to_black_hole < pulled_in_range && self._distance_to_black_hole > soul_burst_range )
        {
            self._black_hole_bomb_collapse_death = 1;

            if ( isdefined( self._bhb_horizon_death ) )
                self [[ self._bhb_horizon_death ]]( self._current_black_hole_bomb_origin, ent_poi );
            else
                self black_hole_bomb_event_horizon_death( self._current_black_hole_bomb_origin, ent_poi );
        }

        if ( self._distance_to_black_hole < soul_burst_range )
        {
            self._black_hole_bomb_collapse_death = 1;

            if ( isdefined( self._bhb_horizon_death ) )
                self [[ self._bhb_horizon_death ]]( self._current_black_hole_bomb_origin, ent_poi );
            else
                self black_hole_bomb_event_horizon_death( self._current_black_hole_bomb_origin, ent_poi );
        }

        wait 0.1;
    }

    self thread black_hole_bomb_escaped_zombie_reset();
}

black_hole_bomb_store_movement_anim()
{
    self endon( "death" );
    current_anim = self.run_combatanim;
    anim_keys = getarraykeys( level.scr_anim[self.animname] );

    for ( j = 0; j < anim_keys.size; j++ )
    {
        if ( level.scr_anim[self.animname][anim_keys[j]] == current_anim )
            return anim_keys[j];
    }

/#
    assertmsg( "couldn't find zombie run anim in the array keys" );
#/
}

black_hole_bomb_being_pulled_fx()
{
    self endon( "death" );
    wait_network_frame();
    self setclientfield( "blackhole", 1 );
    self._black_hole_bomb_being_pulled_in_fx = 1;
}

black_hole_bomb_attract_walk()
{
    self endon( "death" );
    flag_wait( "bhb_anim_change_allowed" );
    level._black_hole_bomb_zombies_anim_change = add_to_array( level._black_hole_bomb_zombies_anim_change, self, 0 );
    self ent_flag_wait( "bhb_anim_change" );
    self.a.runblendtime = 0.9;
    self clear_run_anim();

    if ( self.has_legs )
    {
        rand = randomintrange( 1, 4 );
        self.needs_run_update = 1;
        self._had_legs = 1;
        self setanimstatefromasd( "zm_move_blackhole_walk" );
    }
    else
    {
        rand = randomintrange( 1, 3 );
        self.needs_run_update = 1;
        self._had_legs = 0;
        self setanimstatefromasd( "zm_move_blackhole_walk_crawl" );
    }

    if ( is_true( self.nogravity ) )
    {
        self animmode( "none" );
        self.nogravity = undefined;
    }

    self._black_hole_attract_walk = 1;
    self._bhb_change_anim_notified = 1;
    self.a.runblendtime = self._normal_run_blend_time;
}

black_hole_bomb_attract_run()
{
    self endon( "death" );
    rand = randomintrange( 1, 4 );
    flag_wait( "bhb_anim_change_allowed" );
    level._black_hole_bomb_zombies_anim_change = add_to_array( level._black_hole_bomb_zombies_anim_change, self, 0 );
    self ent_flag_wait( "bhb_anim_change" );
    self.a.runblendtime = 0.9;
    self clear_run_anim();

    if ( self.has_legs )
    {
        self.needs_run_update = 1;
        self setanimstatefromasd( "zm_move_blackhole_walk_fast" );
    }
    else
    {
        self.needs_run_update = 1;
        self setanimstatefromasd( "zm_move_blackhole_walk_fast_crawl" );
    }

    if ( is_true( self.nogravity ) )
    {
        self animmode( "none" );
        self.nogravity = undefined;
    }

    self._black_hole_attract_run = 1;
    self._bhb_change_anim_notified = 1;
    self.a.runblendtime = self._normal_run_blend_time;
}

black_hole_bomb_death_anim()
{
    self endon( "death" );
    flt_moveto_time = 0.7;
    rand = randomintrange( 1, 4 );

    if ( self.has_legs )
        death_animation_state = "zm_black_hole_attracted_death";
    else
        death_animation_state = "zm_black_hole_attracted_death_crawl";

    return death_animation_state;
}

black_hole_bomb_death_while_attracted()
{
    self endon( "death" );
    death_animation = undefined;
    rand = randomintrange( 1, 5 );

    if ( self.has_legs )
        death_animation_state = "zm_black_hole_attracted_death";

    return death_animation_state;
}

black_hole_bomb_arrival_attract_func( ent_poi )
{
    self endon( "death" );
    self endon( "zombie_acquire_enemy" );
    self endon( "path_timer_done" );
    soul_spark_end = ent_poi.origin;
    self waittill( "goal" );

    if ( isdefined( self._bhb_horizon_death ) )
        self [[ self._bhb_horizon_death ]]( self._current_black_hole_bomb_origin, ent_poi );
    else
        self black_hole_bomb_event_horizon_death( self._current_black_hole_bomb_origin, ent_poi );
}

black_hole_bomb_event_horizon_death( vec_black_hole_org, grenade )
{
    self endon( "death" );

    if ( !isdefined( grenade ) )
        return;

    self maps\mp\zombies\_zm_spawner::zombie_eye_glow_stop();
    self playsound( "wpn_gersh_device_kill" );
    self.deathanim = black_hole_bomb_death_anim();
    playfxontag( level._effect["black_hole_bomb_zombie_destroy"], self, "tag_origin" );
    grenade notify( "black_hole_bomb_kill" );
    self dodamage( self.health + 50, self.origin + vectorscale( ( 0, 0, 1 ), 50.0 ), self._black_hole_bomb_tosser, grenade, "MOD_CRUSH" );
}

black_hole_bomb_corpse_hide()
{
    if ( isdefined( self._black_hole_bomb_collapse_death ) && self._black_hole_bomb_collapse_death == 1 )
    {
        playfxontag( level._effect["black_hole_bomb_zombie_gib"], self, "tag_origin" );
        self ghost();
    }

    if ( isdefined( self._black_hole_bomb_being_pulled_in_fx ) && self._black_hole_bomb_being_pulled_in_fx == 1 )
    {

    }
}

black_hole_bomb_escaped_zombie_reset()
{
    self endon( "death" );
    flag_wait( "bhb_anim_change_allowed" );
    level._black_hole_bomb_zombies_anim_change = add_to_array( level._black_hole_bomb_zombies_anim_change, self, 0 );
    self ent_flag_wait( "bhb_anim_change" );
    self.a.runblendtime = 0.9;
    self.needs_run_update = 1;

    if ( !self.has_legs )
    {
        if ( self.zombie_move_speed == "walk" )
            self setanimstatefromasd( "zm_move_walk_crawl" );
        else if ( self.zombie_move_speed == "run" )
            self setanimstatefromasd( "zm_move_run_crawl" );
        else if ( self.zombie_move_speed == "sprint" )
            self setanimstatefromasd( "zm_move_sprint_crawl" );
        else
            self setanimstatefromasd( "zm_move_run_crawl" );
    }
    else if ( self.zombie_move_speed == "walk" )
        self setanimstatefromasd( "zm_move_walk" );
    else if ( self.zombie_move_speed == "run" )
        self setanimstatefromasd( "zm_move_run" );
    else if ( self.zombie_move_speed == "sprint" )
        self setanimstatefromasd( "zm_move_sprint" );
    else
        self setanimstatefromasd( "zm_move_run" );

    self.pre_black_hole_bomb_run_combatanim = undefined;
    self._black_hole_attract_walk = 0;
    self._black_hole_attract_run = 0;
    self._bhb_change_anim_notified = 1;
    self._black_hole_bomb_being_pulled_in_fx = 0;
    self.a.runblendtime = self._normal_run_blend_time;
    self.deathanim = undefined;
    self._had_legs = undefined;
    self._bhb_ent_flag_init = 0;
}

black_hole_bomb_throttle_anim_changes()
{
    if ( !isdefined( level._black_hole_bomb_zombies_anim_change ) )
        level._black_hole_bomb_zombies_anim_change = [];

    int_max_num_zombies_per_frame = 7;
    array_zombies_allowed_to_switch = [];

    while ( isdefined( level._black_hole_bomb_zombies_anim_change ) )
    {
        if ( level._black_hole_bomb_zombies_anim_change.size == 0 )
        {
            wait 0.1;
            continue;
        }

        array_zombies_allowed_to_switch = level._black_hole_bomb_zombies_anim_change;

        for ( i = 0; i < array_zombies_allowed_to_switch.size; i++ )
        {
            if ( isdefined( array_zombies_allowed_to_switch[i] ) && isalive( array_zombies_allowed_to_switch[i] ) )
                array_zombies_allowed_to_switch[i] ent_flag_set( "bhb_anim_change" );

            if ( i >= int_max_num_zombies_per_frame )
                break;
        }

        flag_clear( "bhb_anim_change_allowed" );

        for ( i = 0; i < array_zombies_allowed_to_switch.size; i++ )
        {
            if ( !isdefined( array_zombies_allowed_to_switch[i]._bhb_ent_flag_init ) )
            {
                array_zombies_allowed_to_switch[i] ent_flag_init( "bhb_anim_change" );
                array_zombies_allowed_to_switch[i]._bhb_ent_flag_init = 1;
            }

            if ( array_zombies_allowed_to_switch[i] ent_flag( "bhb_anim_change" ) )
                arrayremovevalue( level._black_hole_bomb_zombies_anim_change, array_zombies_allowed_to_switch[i] );
        }

        level._black_hole_bomb_zombies_anim_change = array_removedead( level._black_hole_bomb_zombies_anim_change );
        arrayremovevalue( level._black_hole_bomb_zombies_anim_change, undefined );
        flag_set( "bhb_anim_change_allowed" );
        wait_network_frame();
        wait 0.1;
    }
}

black_hole_bomb_teleport_init( ent_grenade )
{
    if ( !isdefined( ent_grenade ) )
        return;

    teleport_trigger = spawn( "trigger_radius", ent_grenade.origin, 0, 64, 70 );
    ent_grenade thread black_hole_bomb_trigger_monitor( teleport_trigger );
    ent_grenade waittill( "explode" );
    teleport_trigger notify( "black_hole_complete" );
    wait 0.1;
    teleport_trigger delete();
}

black_hole_bomb_trigger_monitor( ent_trigger )
{
    ent_trigger endon( "black_hole_complete" );

    while ( true )
    {
        ent_trigger waittill( "trigger", ent_player );

        if ( isplayer( ent_player ) && !ent_player isonground() && !is_true( ent_player.lander ) )
            ent_trigger thread black_hole_teleport_trigger_thread( ent_player, ::black_hole_time_before_teleport, ::black_hole_teleport_cancel );

        wait 0.1;
    }
}

black_hole_time_before_teleport( ent_player, str_endon )
{
    ent_player endon( str_endon );

    if ( !bullettracepassed( ent_player geteye(), self.origin + vectorscale( ( 0, 0, 1 ), 65.0 ), 0, ent_player ) )
        return;

    black_hole_teleport_structs = getstructarray( "struct_black_hole_teleport", "targetname" );
    chosen_spot = undefined;

    if ( isdefined( level._special_blackhole_bomb_structs ) )
        black_hole_teleport_structs = [[ level._special_blackhole_bomb_structs ]]();

    if ( !isdefined( black_hole_teleport_structs ) || black_hole_teleport_structs.size == 0 )
        return;

    black_hole_teleport_structs = array_randomize( black_hole_teleport_structs );

    if ( isdefined( level._override_blackhole_destination_logic ) )
        chosen_spot = [[ level._override_blackhole_destination_logic ]]( black_hole_teleport_structs, ent_player );
    else
    {
        for ( i = 0; i < black_hole_teleport_structs.size; i++ )
        {
            if ( check_point_in_enabled_zone( black_hole_teleport_structs[i].origin, undefined, undefined ) && ent_player get_current_zone() != black_hole_teleport_structs[i].script_string )
            {
                chosen_spot = black_hole_teleport_structs[i];
                break;
            }
        }
    }

    if ( isdefined( chosen_spot ) )
    {
        self playsound( "zmb_gersh_teleporter_out" );
        ent_player thread black_hole_teleport( chosen_spot );
    }
}

black_hole_teleport_cancel( ent_player )
{

}

black_hole_teleport( struct_dest )
{
    self endon( "death" );

    if ( !isdefined( struct_dest ) )
        return;

    prone_offset = vectorscale( ( 0, 0, 1 ), 49.0 );
    crouch_offset = vectorscale( ( 0, 0, 1 ), 20.0 );
    stand_offset = ( 0, 0, 0 );
    destination = undefined;

    if ( self getstance() == "prone" )
        destination = struct_dest.origin + prone_offset;
    else if ( self getstance() == "crouch" )
        destination = struct_dest.origin + crouch_offset;
    else
        destination = struct_dest.origin + stand_offset;

    if ( isdefined( level._black_hole_teleport_override ) )
        level [[ level._black_hole_teleport_override ]]( self );

    black_hole_bomb_create_exit_portal( struct_dest.origin );
    self freezecontrols( 1 );
    self disableoffhandweapons();
    self disableweapons();
    self dontinterpolate();
    self setorigin( destination );
    self setplayerangles( struct_dest.angles );
    self enableoffhandweapons();
    self enableweapons();
    self freezecontrols( 0 );
    self thread slightly_delayed_player_response();
}

slightly_delayed_player_response()
{
    wait 1;
    self maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "teleport_gersh" );
}

black_hole_teleport_trigger_thread( ent, on_enter_payload, on_exit_payload )
{
    ent endon( "death" );
    self endon( "black_hole_complete" );

    if ( ent black_hole_teleport_ent_already_in_trigger( self ) )
        return;

    self black_hole_teleport_add_trigger_to_ent( ent );
    endon_condition = "leave_trigger_" + self getentitynumber();

    if ( isdefined( on_enter_payload ) )
        self thread [[ on_enter_payload ]]( ent, endon_condition );

    while ( isdefined( ent ) && ent istouching( self ) && isdefined( self ) )
        wait 0.01;

    ent notify( endon_condition );

    if ( isdefined( ent ) && isdefined( on_exit_payload ) )
        self thread [[ on_exit_payload ]]( ent );

    if ( isdefined( ent ) )
        self black_hole_teleport_remove_trigger_from_ent( ent );
}

black_hole_teleport_add_trigger_to_ent( ent )
{
    if ( !isdefined( ent._triggers ) )
        ent._triggers = [];

    ent._triggers[self getentitynumber()] = 1;
}

black_hole_teleport_remove_trigger_from_ent( ent )
{
    if ( !isdefined( ent._triggers ) )
        return;

    if ( !isdefined( ent._triggers[self getentitynumber()] ) )
        return;

    ent._triggers[self getentitynumber()] = 0;
}

black_hole_teleport_ent_already_in_trigger( trig )
{
    if ( !isdefined( self._triggers ) )
        return false;

    if ( !isdefined( self._triggers[trig getentitynumber()] ) )
        return false;

    if ( !self._triggers[trig getentitynumber()] )
        return false;

    return true;
}

black_hole_bomb_kill_counter( grenade )
{
    self endon( "death" );
    grenade endon( "death" );
    kill_count = 0;

    for (;;)
    {
        grenade waittill( "black_hole_bomb_kill" );
        kill_count++;

        if ( kill_count == 4 )
            self maps\mp\zombies\_zm_audio::create_and_play_dialog( "kill", "gersh_device" );

        if ( 5 <= kill_count )
            self notify( "black_hole_kills_achievement" );
    }
}

black_hole_bomb_create_exit_portal( pos )
{
    exit_portal_fx_spot = spawn( "script_model", pos );
    exit_portal_fx_spot setmodel( "tag_origin" );
    playfxontag( level._effect["black_hole_bomb_portal_exit"], exit_portal_fx_spot, "tag_origin" );
    exit_portal_fx_spot thread black_hole_bomb_exit_clean_up();
    exit_portal_fx_spot playsound( "zmb_gersh_teleporter_go" );
}

black_hole_bomb_exit_clean_up()
{
    wait 4.0;
    self delete();
}

black_hole_bomb_stolen_by_sam( ent_grenade, ent_model )
{
    if ( !isdefined( ent_model ) )
        return;

    direction = ent_model.origin;
    direction = ( direction[1], direction[0], 0 );

    if ( direction[1] < 0 || direction[0] > 0 && direction[1] > 0 )
        direction = ( direction[0], direction[1] * -1, 0 );
    else if ( direction[0] < 0 )
        direction = ( direction[0] * -1, direction[1], 0 );

    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        if ( isalive( players[i] ) )
            players[i] playlocalsound( level.zmb_laugh_alias );
    }

    playfxontag( level._effect["black_hole_samantha_steal"], ent_model, "tag_origin" );
    ent_model movez( 60, 1.0, 0.25, 0.25 );
    ent_model vibrate( direction, 1.5, 2.5, 1.0 );
    ent_model waittill( "movedone" );
    ent_model delete();
}

#using_animtree("zm_moon_basic");

black_hole_bomb_anim_init()
{
    if ( isdefined( level._use_extra_blackhole_anims ) )
        [[ level._use_extra_blackhole_anims ]]();

    level.scr_anim["zombie"]["black_hole_death_1"] = %ai_zombie_blackhole_death_v1;
    level.scr_anim["zombie"]["black_hole_death_2"] = %ai_zombie_blackhole_death_v2;
    level.scr_anim["zombie"]["black_hole_death_3"] = %ai_zombie_blackhole_death_v3;
    level.scr_anim["zombie"]["crawler_black_hole_death_1"] = %ai_zombie_blackhole_crawl_death_v1;
    level.scr_anim["zombie"]["crawler_black_hole_death_2"] = %ai_zombie_blackhole_crawl_death_v2;
    level.scr_anim["zombie"]["crawler_black_hole_death_3"] = %ai_zombie_blackhole_crawl_death_v3;
}
