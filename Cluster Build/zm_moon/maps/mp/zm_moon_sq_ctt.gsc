// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_audio;

init_1()
{
    level._active_tanks = [];
    maps\mp\zombies\_zm_spawner::add_custom_zombie_spawn_logic( ::tank_volume_death_check );
    declare_sidequest_stage( "tanks", "ctt1", ::init_stage_1, ::stage_logic, ::exit_stage_1 );
}

init_stage_1()
{
    level._active_tanks = [];
    level._cur_stage_name = "ctt1";
    level._ctt_pause_flag = "sam_switch_thrown";
    level._charge_flag = "first_tanks_charged";
    add_tank( "sq_first_tank" );
    clientnotify( "ctt1" );
    level thread setup_and_play_ctt1_vox();
}

exit_stage_1( success )
{
    kill_tanks();
}

init_2()
{
    declare_sidequest_stage( "tanks", "ctt2", ::init_stage_2, ::stage_logic, ::exit_stage_2 );
}

init_stage_2()
{
    level._active_tanks = [];
    level._cur_stage_name = "ctt2";
    level._ctt_pause_flag = "cvg_placed";
    level._charge_flag = "second_tanks_charged";
}

exit_stage_2( success )
{
    flag_set( "second_tanks_charged" );
    kill_tanks();
}

stage_logic()
{
    if ( level._cur_stage_name == "ctt2" )
    {
        s = getstruct( "sq_vg_final", "targetname" );
        r_close = 0;

        while ( !r_close )
        {
            players = get_players();

            for ( i = 0; i < players.size; i++ )
            {
                ent_num = players[i].characterindex;

                if ( isdefined( players[i].zm_random_char ) )
                    ent_num = players[i].zm_random_char;

                if ( ent_num == 3 )
                {
                    d = distancesquared( players[i].origin, s.origin );

                    if ( d < 57600 )
                    {
                        r_close = 1;
                        players[i] playsound( "vox_plr_3_quest_step6_0" );
                        break;
                    }
                }
            }

            wait 0.1;
        }

        add_tank( "sq_first_tank", "sq_second_tank" );
        clientnotify( "ctt2" );
        level thread setup_and_play_ctt2_vox();
        level thread hit_sam();
    }

    while ( true )
    {
        if ( all_tanks_full() )
        {
            play_sound_in_space( "evt_souls_full", ( 0, 0, 0 ) );
            level notify( "ctt_aud_note" );
            break;
        }

        wait 0.1;
    }

    clientnotify( "ctto" );
    flag_set( level._charge_flag );
    flag_wait( level._ctt_pause_flag );
    drain_tanks();

    for ( i = 0; i < level._active_tanks.size; i++ )
    {
        tank = level._active_tanks[i];
        tank.capacitor moveto( tank.capacitor.origin + vectorscale( ( 0, 0, 1 ), 12.0 ), 2 );
        tank.tank moveto( tank.tank.origin - vectorscale( ( 0, 0, 1 ), 57.156 ), 2 );
        tank.tank playsound( "evt_tube_move_down" );
        tank.tank thread play_delayed_stop_sound( 2 );
        tank trigger_off();
    }

    wait 2.0;

    if ( level._cur_stage_name == "ctt2" )
        flag_set( "second_tanks_drained" );
    else
        flag_set( "first_tanks_drained" );

    stage_completed( "tanks", level._cur_stage_name );
}

play_delayed_stop_sound( time )
{
    wait( time );
    self playsound( "evt_tube_stop" );
}

build_sam_stage( percent, l )
{
    s = spawnstruct();
    s.percent = percent;
    s.line = l;
    return s;
}

percent_full()
{
    max_fill = 0;
    fill = 0;

    for ( i = 0; i < level._active_tanks.size; i++ )
    {
        max_fill = max_fill + level._active_tanks[i].max_fill;
        fill = fill + level._active_tanks[i].fill;
    }

    return fill / max_fill;
}

hit_sam()
{
    level endon( "tanks_ctt2_over" );
    stages = array( build_sam_stage( 0.1, "vox_plr_4_quest_step6_1" ), build_sam_stage( 0.2, "vox_plr_4_quest_step6_1a" ), build_sam_stage( 0.3, "vox_plr_4_quest_step6_2" ), build_sam_stage( 0.4, "vox_plr_4_quest_step6_2a" ), build_sam_stage( 0.5, "vox_plr_4_quest_step6_3" ), build_sam_stage( 0.6, "vox_plr_4_quest_step6_3a" ), build_sam_stage( 0.7, "vox_plr_4_quest_step6_4" ), build_sam_stage( 0.9, "vox_plr_4_quest_step6_5" ) );
    index = 0;
    targ = getstruct( "sq_sam", "targetname" );
    targ = getstruct( targ.target, "targetname" );

    while ( index < stages.size )
    {
        stage = stages[index];

        while ( percent_full() < stage.percent )
            wait 0.1;

        level.skit_vox_override = 1;
        level thread play_sam_vo( stage.line, targ.origin, index );
        level.skit_vox_override = 0;
        index++;
    }
}

play_sam_vo( _line, origin, index )
{
    level clientnotify( "st1" );
    snd_ent = spawn( "script_origin", origin );
    snd_ent playsound( _line, index + "_snddone" );
    snd_ent waittill( index + "_snddone" );
    level clientnotify( "sp1" );
    snd_ent delete();
}

drain_tanks()
{
    for ( i = 0; i < level._active_tanks.size; i++ )
    {
        tank = level._active_tanks[i];
        tank.fill_model moveto( tank.fill_model.origin - vectorscale( ( 0, 0, 1 ), 65.0 ), 1.5, 0.1, 0.1 );
        tank.tank stoploopsound( 1 );
        tank.tank playsound( "evt_souls_flush" );
        tank.fill_model thread delay_hide();
        tank.fill = 0;
    }

    wait 2;
}

delay_hide()
{
    wait 2;
    self ghost();
}

all_tanks_full()
{
    if ( level._active_tanks.size == 0 )
        return false;

    for ( i = 0; i < level._active_tanks.size; i++ )
    {
        tank = level._active_tanks[i];

        if ( tank.fill < tank.max_fill )
            return false;
    }

    return true;
}

kill_tanks()
{
    clientnotify( "ctto" );
    tanks = getentarray( "ctt_tank", "script_noteworthy" );

    for ( i = 0; i < tanks.size; i++ )
    {
        tank = tanks[i];
        tank.capacitor delete();
        tank.capacitor = undefined;
        tank.tank = undefined;
        tank.fill_model delete();
        tank.fill_model = undefined;
        tank delete();
    }
}

movetopos( pos )
{
    self moveto( pos, 1 );
}

add_tank( tank_name, other_tank_name )
{
    tanks = getstructarray( tank_name, "targetname" );

    if ( isdefined( other_tank_name ) )
        tanks = arraycombine( tanks, getstructarray( other_tank_name, "targetname" ), 0, 0 );

    for ( i = 0; i < tanks.size; i++ )
    {
        tank = tanks[i];
        radius = 32;

        if ( isdefined( tank.radius ) )
            radius = tank.radius;

        height = 72;

        if ( isdefined( tank.height ) )
            height = tank.height;

        tank_trigger = spawn( "trigger_radius", tank.origin, 1, radius, height );
        tank_trigger.script_noteworthy = "ctt_tank";
        capacitor_struct = getstruct( tank.target, "targetname" );
        capacitor_model = spawn( "script_model", capacitor_struct.origin + vectorscale( ( 0, 0, 1 ), 18.0 ) );
        capacitor_model.angles = capacitor_struct.angles;
        capacitor_model setmodel( capacitor_struct.model );
        capacitor_model thread movetopos( capacitor_struct.origin );
        tank_trigger.capacitor = capacitor_model;
        tank_model = getent( capacitor_struct.target, "targetname" );
        tank_model thread movetopos( tank_model.origin + vectorscale( ( 0, 0, 1 ), 57.156 ) );
        tank_model playsound( "evt_tube_move_up" );
        tank_model thread play_delayed_stop_sound( 1 );
        tank_trigger.tank = tank_model;
        tank_trigger.fill = 0;
        scalar = 1.0;
        scalar = scalar + ( get_players().size - 1 ) * 0.33;
        tank_trigger.max_fill = int( tank_model.script_int * scalar );
        max_fill = getstruct( tank_model.target, "targetname" );
        tank_trigger.tank.fill_step = ( max_fill.origin[2] - ( tank_model.origin[2] + 56 ) ) / tank_trigger.max_fill;
        tank_fill_model = spawn( "script_model", tank_trigger.tank.origin + vectorscale( ( 0, 0, 1 ), 56.0 ) );
        tank_fill_model setmodel( max_fill.model );
        tank_fill_model.base_level = tank_trigger.tank.origin + vectorscale( ( 0, 0, 1 ), 56.0 );
        tank_fill_model ghost();
        tank_trigger.fill_model = tank_fill_model;
        level._active_tanks[level._active_tanks.size] = tank_trigger;
    }
}

do_tank_fill( actor, tank )
{
    if ( tank.fill >= tank.max_fill )
    {
        tank.tank playloopsound( "evt_souls_full_loop", 1 );
        return;
    }

    actor setclientfield( "ctt", 1 );
    wait 0.5;

    if ( tank.fill <= 0 )
        level notify( "ctt_first_kill" );

    if ( isdefined( tank ) && tank.fill < tank.max_fill )
    {
        tank.fill++;
        tank.fill_model.origin = tank.fill_model.origin + ( 0, 0, tank.tank.fill_step );
        tank.fill_model show();
    }
}

tank_volume_death_check()
{
    self waittill( "death" );

    if ( !isdefined( self ) )
        return;

    for ( i = 0; i < level._active_tanks.size; i++ )
    {
        if ( isdefined( level._active_tanks[i] ) )
        {
            if ( self istouching( level._active_tanks[i] ) )
            {
                level thread do_tank_fill( self, level._active_tanks[i] );
                return;
            }
        }
    }
}

setup_and_play_ctt1_vox()
{
    level thread ctt1_first_kill_vox();
    level thread ctt1_full_vox();
    level thread vox_override_while_near_tank();
    level thread ctt1_fifty_percent_vox();
}

ctt1_first_kill_vox()
{
    level waittill( "ctt_first_kill" );

    for ( i = 0; i < level._active_tanks.size; i++ )
    {
        player = get_closest_player( level._active_tanks[i].origin );

        if ( isdefined( player ) )
        {
            player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest4", undefined, 0, 1 );
            return;
        }
    }
}

ctt1_fifty_percent_vox()
{
    while ( percent_full() < 0.5 )
        wait 0.5;

    players = get_players();
    players[randomintrange( 0, players.size )] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest4", undefined, 1, 1 );
}

ctt1_full_vox()
{
    level waittill( "ctt_aud_note" );
    players = get_players();
    players[randomintrange( 0, players.size )] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest4", undefined, 2, 1 );
}

vox_override_while_near_tank()
{
    while ( !flag( "sam_switch_thrown" ) )
    {
        while ( level.zones["generator_zone"].is_occupied )
        {
            level.skit_vox_override = 1;

            if ( flag( "sam_switch_thrown" ) )
                break;

            wait 1;
        }

        level.skit_vox_override = 0;
        wait 1;
    }

    level.skit_vox_override = 1;
    wait 10;
    level.skit_vox_override = 0;
}

setup_and_play_ctt2_vox()
{
    level thread vox_override_while_near_tank2();
}

ctt2_full_vox()
{
    level waittill( "ctt_aud_note" );
    players = get_players();
    players[randomintrange( 0, players.size )] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest6", undefined, 6, 1 );
}

vox_override_while_near_tank2()
{
    while ( !flag( "cvg_placed" ) )
    {
        while ( level.zones["generator_zone"].is_occupied )
        {
            level.skit_vox_override = 1;

            if ( flag( "cvg_placed" ) )
                break;

            wait 1;
        }

        level.skit_vox_override = 0;
        wait 1;
    }

    level.skit_vox_override = 1;
    wait 10;
    level.skit_vox_override = 0;
}
