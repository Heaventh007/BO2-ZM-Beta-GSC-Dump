// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_moon_sq_ss;
#include maps\mp\zm_moon_sq_osc;
#include maps\mp\zm_moon_sq_sc;
#include maps\mp\zm_moon_sq_ctt;
#include maps\mp\zm_moon_sq_ctvg;
#include maps\mp\zm_moon_sq_be;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\zm_moon_sq;
#include maps\mp\zombies\_zm;
#include maps\mp\zm_moon_sq_datalogs;
#include maps\mp\zombies\_zm_audio;

init()
{
    precachemodel( "p_zom_moon_py_collector_fill" );
    precachemodel( "p_zom_moon_py_collector" );
    precachemodel( "p_zom_moon_py_capacitor" );
    precachemodel( "p_glo_data_recorder01_static_reel" );
    ss_buttons = getentarray( "sq_ss_button", "targetname" );

    for ( i = 0; i < ss_buttons.size; i++ )
    {
        ss_buttons[i] usetriggerrequirelookat();
        ss_buttons[i] sethintstring( "" );
        ss_buttons[i] setcursorhint( "HINT_NOICON" );
    }

    flag_init( "first_tanks_charged" );
    flag_init( "second_tanks_charged" );
    flag_init( "first_tanks_drained" );
    flag_init( "second_tanks_drained" );
    flag_init( "c_built" );
    flag_init( "vg_charged" );
    flag_init( "switch_done" );
    flag_init( "be2" );
    flag_init( "ss1" );
    flag_init( "soul_swap_done" );
    declare_sidequest( "sq", ::init_sidequest, ::sidequest_logic, ::complete_sidequest, ::generic_stage_start, ::generic_stage_complete );
    declare_sidequest_icon( "sq", "vril", "zom_hud_icon_vril" );
    declare_sidequest_icon( "sq", "anti115", "zom_hud_icon_meteor" );
    declare_sidequest_icon( "sq", "generator", "hud_icon_vril_combo" );
    declare_sidequest_icon( "sq", "cgenerator", "hud_icon_vril_combo_select" );
    declare_sidequest_icon( "sq", "wire", "hud_icon_wire" );
    declare_sidequest_icon( "sq", "datalog", "zom_icon_theater_reel" );
    maps\mp\zm_moon_sq_ss::init_1();
    maps\mp\zm_moon_sq_ss::init_2();
    maps\mp\zm_moon_sq_osc::init();
    maps\mp\zm_moon_sq_sc::init();
    maps\mp\zm_moon_sq_sc::init_2();
    declare_sidequest( "tanks", undefined, undefined, undefined, undefined, undefined );
    maps\mp\zm_moon_sq_ctt::init_1();
    maps\mp\zm_moon_sq_ctt::init_2();
    declare_sidequest( "ctvg", undefined, undefined, undefined, undefined, undefined );
    maps\mp\zm_moon_sq_ctvg::init();
    declare_sidequest( "be", undefined, undefined, undefined, undefined, undefined );
    maps\mp\zm_moon_sq_be::init();
    precache_moon_sidequest_assets();
}

precache_moon_sidequest_assets()
{
    precachemodel( "tag_origin_animate" );
    sidequest_names = getarraykeys( level._zombie_sidequests );

    for ( i = 0; i < sidequest_names.size; i++ )
    {
        sq = level._zombie_sidequests[sidequest_names[i]];
        icon_keys = getarraykeys( sq.icons );

        for ( j = 0; j < icon_keys.size; j++ )
            precacheshader( sq.icons[icon_keys[j]] );

        stage_names = getarraykeys( sq.stages );

        for ( j = 0; j < stage_names.size; j++ )
        {
            stage = sq.stages[stage_names[j]];

            for ( k = 0; k < stage.assets.size; k++ )
            {
                asset = stage.assets[k];

                if ( isdefined( asset.type ) && asset.type == "struct" )
                {
                    if ( isdefined( asset.struct.model ) )
                        precachemodel( asset.struct.model );
                }
            }
        }
    }
}

reward()
{
    level notify( "moon_sidequest_achieved" );
    players = get_players();
    array_thread( players, ::give_perk_reward );
}

watch_for_respawn()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill_either( "spawned_player", "player_revived" );
        waittillframeend;
        self setmaxhealth( level.zombie_vars["zombie_perk_juggernaut_health"] );
    }
}

give_perk_reward()
{
    if ( isdefined( self._retain_perks ) )
        return;

    if ( !isdefined( level._sq_perk_array ) )
    {
        level._sq_perk_array = [];
        machines = getentarray( "zombie_vending", "targetname" );

        for ( i = 0; i < machines.size; i++ )
            level._sq_perk_array[level._sq_perk_array.size] = machines[i].script_noteworthy;
    }

    for ( i = 0; i < level._sq_perk_array.size; i++ )
    {
        if ( !self hasperk( level._sq_perk_array[i] ) )
        {
            self playsound( "evt_sq_bag_gain_perks" );
            self maps\mp\zombies\_zm_perks::give_perk( level._sq_perk_array[i] );
            wait 0.25;
        }
    }

    self._retain_perks = 1;
    self thread watch_for_respawn();
}

start_moon_sidequest()
{
    maps\mp\zm_moon_sq::init();
    flag_wait( "start_zombie_round_logic" );
    sidequest_start( "sq" );
}

init_sidequest()
{
    players = get_players();
    level._all_previous_done = 0;
    level._zombiemode_sidequest_icon_offset = -32;

    for ( i = 0; i < players.size; i++ )
    {
        entnum = players[i].characterindex;
/#
        println( "**** entnum " + entnum );
#/

        if ( isdefined( players[i].zm_random_char ) )
            entnum = players[i].zm_random_char;

        if ( entnum == 3 )
        {
            devmode = 0;

            if ( devmode )
            {
                players[i] add_sidequest_icon( "sq", "generator" );
                level._all_previous_done = 1;
                continue;
            }

            if ( level.onlinegame )
            {
                if ( maps\mp\zombies\_zm::is_sidequest_previously_completed( "EOA" ) )
                {
                    players[i] add_sidequest_icon( "sq", "generator" );
                    level._all_previous_done = 1;
                    break;
                }
                else
                {
                    players[i] add_sidequest_icon( "sq", "vril" );
                    break;
                }
            }
        }
    }

    level thread tanks();
    level thread cassimir();
    level thread be();
    level thread maps\mp\zm_moon_sq_datalogs::init();

    if ( 1 == getdvarint( #"_id_5D1BFE4D" ) )
        level thread rocket_test();

    level thread rocket_raise();
}

rocket_test()
{
    flag_wait( "power_on" );
    wait 5;
    level notify( "rl" );
    wait 2;
    level notify( "rl" );
    wait 2;
    level notify( "rl" );
    level thread do_launch();
}

rocket_raise( player_num )
{
    rockets = getentarray( "vista_rocket", "targetname" );
    array_thread( rockets, ::nml_show_hide );

    for ( i = 0; i < rockets.size; i++ )
    {
        level waittill( "rl" );
        level clientnotify( "R_R" );
        rockets[i] playsound( "evt_rocket_move_up" );
        s = getstruct( rockets[i].target, "targetname" );
        rockets[i] moveto( s.origin, 4 );
        rockets[i] rotateto( ( 0, 0, 0 ), 4 );
    }

    level waittill( "rl" );
    array_thread( rockets, ::launch );
}

nml_show_hide()
{
    level endon( "intermission" );
    self endon( "death" );

    while ( true )
    {
        flag_wait( "enter_nml" );
        self ghost();
        flag_waitopen( "enter_nml" );
        self show();
    }
}

launch()
{
    level clientnotify( "R_L" );
    wait( randomfloatrange( 0.1, 1 ) );
    self playsound( "evt_rocket_launch" );

    if ( !isdefined( level._n_rockets ) )
        level._n_rockets = 0;

    self.rocket_num = level._n_rockets;
    level._n_rockets++;
/#
    println( "Rocket " + self.rocket_num + " launching!" );
    println( "Rocket " + self.rocket_num + " target : " + self.target );
#/
    s = getstruct( self.target, "targetname" );
/#
    println( "Rocket " + self.rocket_num + " target's target : " + s.target );
#/

    if ( isdefined( s.target ) )
    {
        start = getvehiclenode( s.target, "targetname" );

        if ( !isdefined( start ) )
            return;

        origin_animate = spawn( "script_model", start.origin );
        origin_animate setmodel( "tag_origin_animate" );
        self linkto( origin_animate, "origin_animate_jnt", ( 0, 0, 0 ), ( 0, 0, 0 ) );
        playfxontag( level._effect["rocket_booster"], self, "tag_origin" );
        vehicle = spawnvehicle( "tag_origin", "rocket_mover", "misc_freefall", start.origin, start.angles );
        origin_animate linkto( vehicle );
        vehicle attachpath( start );
        vehicle startpath();
        vehicle waittill( "reached_end_node" );
        self unlink();
        self delete();
        vehicle delete();
        origin_animate delete();
    }
}

sidequest_logic()
{
    level thread sq_flatcard_logic();
    flag_wait( "power_on" );
    stage_start( "sq", "ss1" );
    flag_wait( "ss1" );
    stage_start( "sq", "osc" );
    level waittill( "sq_osc_over" );
    flag_wait( "complete_be_1" );
    wait 4.0;
    stage_start( "sq", "sc" );
    level waittill( "sq_sc_over" );
    flag_wait( "vg_charged" );
    stage_start( "sq", "sc2" );
    level waittill( "sq_sc2_over" );
    wait 5.0;
    level thread maxis_story_vox();
    level waittill( "sq_ss2_over" );
    flag_wait( "be2" );
    level thread do_launch();
}

do_launch()
{
    play_sound_2d( "vox_xcomp_quest_step8_4" );
    wait 10;
    level notify( "rl" );
    wait 30;
    play_sound_2d( "vox_xcomp_quest_step8_5" );
    wait 30;
    play_sound_2d( "evt_earth_explode" );
    clientnotify( "dte" );
    wait_network_frame();
    wait_network_frame();
    exploder( 2012 );
    wait 2;
    level clientnotify( "SDE" );
    level._dte_done = 1;
    level notify( "moon_sidequest_big_bang_achieved" );
    play_sound_2d( "vox_xcomp_quest_laugh" );
    level thread play_end_lines_in_order();
    reward();
}

play_end_lines_in_order()
{
    level.skit_vox_override = 1;
    players = get_players();
    players[randomintrange( 0, players.size )] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 7, 1 );
    wait 12;
    player = get_specific_player( 0 );

    if ( isdefined( player ) )
    {
        player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 9, 1 );
        wait 5;
    }

    player = get_specific_player( 1 );

    if ( isdefined( player ) )
    {
        player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 9, 1 );
        wait 5;
    }

    player = get_specific_player( 2 );

    if ( isdefined( player ) )
    {
        player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 9, 1 );
        wait 5;
    }

    player = get_specific_player( 3 );

    if ( isdefined( player ) )
    {
        player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 9, 1 );
        wait 5;
    }

    player = get_specific_player( 3 );

    if ( isdefined( player ) )
        player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 10, 1 );

    level.skit_vox_override = 0;
}

get_specific_player( num )
{
    players = get_players();

    for ( i = 0; i < players.size; i++ )
    {
        ent_num = players[i].characterindex;

        if ( isdefined( players[i].zm_random_char ) )
            ent_num = players[i].zm_random_char;

        if ( ent_num == num )
            return players[i];
    }

    return undefined;
}

maxis_story_vox()
{
    s = getstruct( "sq_vg_final", "targetname" );
    level.skit_vox_override = 1;
    play_sound_in_space( "vox_plr_3_quest_step6_9", s.origin );
    wait 2.3;
    play_sound_in_space( "vox_plr_3_quest_step6_11", s.origin );
    wait 10.5;
    play_sound_in_space( "vox_xcomp_quest_step6_14", s.origin );
    level.skit_vox_override = 0;
    stage_start( "sq", "ss2" );
}

be()
{
    stage_start( "be", "stage_one" );
    level waittill( "sq_sc2_over" );
    wait 2.0;
    stage_start( "be", "stage_two" );
}

tanks()
{
    flag_wait( "complete_be_1" );
    wait 4.0;
    stage_start( "tanks", "ctt1" );
    level waittill( "sq_sc_over" );
    flag_wait( "vg_charged" );
    stage_start( "tanks", "ctt2" );
}

cassimir()
{
    stage_start( "ctvg", "build" );
    level waittill( "ctvg_build_over" );
    wait 5.0;
    stage_start( "ctvg", "charge" );
}

cheat_complete_stage()
{
    level endon( "reset_sundial" );

    while ( true )
    {
        if ( getdvar( #"_id_1186DB2D" ) != "" )
        {
            if ( isdefined( level._last_stage_started ) )
            {
                setdvar( "cheat_sq", "" );
                stage_completed( "sq", level._last_stage_started );
            }
        }

        wait 0.1;
    }
}

generic_stage_start()
{
/#
    level thread cheat_complete_stage();
#/
    level._stage_active = 1;
}

generic_stage_complete()
{
    level._stage_active = 0;
}

complete_sidequest()
{
    level thread sidequest_done();
}

sidequest_done()
{

}

get_variant_from_entity_num( player_number )
{
    if ( !isdefined( player_number ) )
        player_number = 0;

    post_fix = "a";

    switch ( player_number )
    {
        case 0:
            post_fix = "a";
            break;
        case 1:
            post_fix = "b";
            break;
        case 2:
            post_fix = "c";
            break;
        case 3:
            post_fix = "d";
            break;
    }

    return post_fix;
}

sq_flatcard_logic()
{
    nml_set = 0;

    while ( true )
    {
        if ( flag( "enter_nml" ) && !nml_set )
        {
            if ( !isdefined( level._dte_done ) )
                level clientnotify( "H_E" );

            nml_set = 1;
        }
        else if ( !flag( "enter_nml" ) && nml_set )
        {
            if ( !isdefined( level._dte_done ) )
                level clientnotify( "S_E" );

            nml_set = 0;
        }

        wait 0.1;
    }
}
