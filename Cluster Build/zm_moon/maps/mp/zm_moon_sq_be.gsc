// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zombies\_zm_weap_quantum_bomb;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_weap_microwavegun;

#using_animtree("fxanim_props_dlc5");

init()
{
    precachemodel( "p_zom_moon_black_egg" );
    precachevehicle( "misc_freefall" );
    level.scr_anim["_be_"]["to_the_right"][0] = %fxanim_zom_ztem_crystal_small_anim;
    level.scr_anim["_be_"]["to_the_left"][0] = %fxanim_zom_ztem_crystal_small_anim;
    level.motivational_struct = getstruct( "struct_motivation", "targetname" );
    assert( isdefined( level.motivational_struct.name ) );

    if ( !isdefined( level.motivational_struct ) )
    {
/#
        println( "$$$$ No structs, reBSP $$$$" );
#/
        return;
    }

    level._be_start = strtok( level.motivational_struct.script_parameters, "," );

    for ( i = 0; i < level._be_start.size; i++ )
        flag_init( level._be_start[i] );

    level._be_complete = strtok( level.motivational_struct.script_flag, "," );

    for ( j = 0; j < level._be_complete.size; j++ )
    {
        if ( !level flag_exists( level._be_complete[j] ) )
            flag_init( level._be_complete[j] );
    }

    level.motivational_array = strtok( level.motivational_struct.script_string, "," );
    level._sliding_doors = getentarray( "zombie_door_airlock", "script_noteworthy" );
    level._sliding_doors = arraycombine( level._sliding_doors, getentarray( "zombie_door", "targetname" ), 0, 0 );
    level._my_speed = 12;
    declare_sidequest_stage( "be", "stage_one", ::init_stage_1, ::stage_logic_1, ::exit_stage_1 );
    declare_sidequest_stage( "be", "stage_two", ::init_stage_2, ::stage_logic_2, ::exit_stage_2 );
}

init_stage_2()
{

}

stage_logic_2()
{
    org = level._be.origin;
    angles = level._be.angles;
    exploder( 405 );
    level._be playsound( "evt_be_insert" );
    level._be stopanimscripted();
    level._be unlink();
    level._be dontinterpolate();
    level._be.origin = org;
    level._be.angles = angles;
    level._be thread wait_for_close_player();

    if ( isdefined( level._be_vehicle ) )
        level._be_vehicle delete();

    if ( isdefined( level._be_origin_animate ) )
    {
        level._be_origin_animate stopanimscripted();
        level._be_origin_animate delete();
    }

    maps\mp\zombies\_zm_weap_quantum_bomb::quantum_bomb_register_result( "be2", undefined, 100, ::be2_validation );
    level._be_pos = level._be.origin;
    level waittill( "be2_validation" );
    maps\mp\zombies\_zm_weap_quantum_bomb::quantum_bomb_deregister_result( "be2" );
    s = getstruct( "be2_pos", "targetname" );
    level._be dontinterpolate();
    level._be.origin = s.origin;
    level.teleport_target_trigger = spawn( "trigger_radius", s.origin + vectorscale( ( 0, 0, -1 ), 70.0 ), 0, 125, 100 );
    level.black_hole_bomb_loc_check_func = ::bhb_teleport_loc_check;
    level waittill( "be2_tp_done" );
    players = get_players();
    players[randomintrange( 0, players.size )] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 2 );
    level.black_hole_bomb_loc_check_func = undefined;
    level._be delete();
    level._be = undefined;
    stage_completed( "be", "stage_two" );
}

wait_for_close_player()
{
    level endon( "be2_validation" );
    self endon( "death" );
    wait 25;

    while ( true )
    {
        players = get_players();

        for ( i = 0; i < players.size; i++ )
        {
            if ( distancesquared( players[i].origin, self.origin ) <= 62500 )
            {
                players[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest8", undefined, 0 );
                return;
            }
        }

        wait 0.5;
    }
}

bhb_teleport_loc_check( grenade, model, info )
{
    if ( isdefined( level.teleport_target_trigger ) && grenade istouching( level.teleport_target_trigger ) )
    {
        level._be setclientfield( "blackhole", 1 );
        level thread teleport_target( grenade, level._be );
        return true;
    }

    return false;
}

teleport_target( grenade, model )
{
    level.teleport_target_trigger delete();
    level.teleport_target_trigger = undefined;
    wait 1.0;
    time = 3.0;
    model moveto( grenade.origin + vectorscale( ( 0, 0, 1 ), 50.0 ), time, time - 0.05 );
    wait( time );
    teleport_targets = getentarray( "vista_rocket", "targetname" );
    model ghost();
    playsoundatposition( "zmb_gersh_teleporter_out", grenade.origin + vectorscale( ( 0, 0, 1 ), 50.0 ) );
    wait 0.5;
    model stoploopsound( 1 );
    wait 0.5;

    for ( i = 0; i < teleport_targets.size; i++ )
        playfx( level._effect["black_hole_bomb_event_horizon"], teleport_targets[i].origin + vectorscale( ( 0, 0, 1 ), 2500.0 ) );

    model playsound( "zmb_gersh_teleporter_go" );
    wait 2.0;
    level notify( "be2_tp_done" );
}

be2_validation( position )
{
    if ( distancesquared( level._be_pos, position ) < 26896 )
        level notify( "be2_validation" );

    return false;
}

exit_stage_2( success )
{
    flag_set( "be2" );
}

init_stage_1()
{
    level thread moon_be_start_capture();
}

stage_logic_1()
{
    flag_wait( "complete_be_1" );
    level._be playsound( "evt_be_insert" );
    exploder( 405 );
    level thread play_vox_on_closest_player( 6 );
    stage_completed( "be", "stage_one" );
}

exit_stage_1( success )
{

}

moon_be_start_capture()
{
    level endon( "end_game" );

    while ( !flag( level._be_complete[0] ) )
    {
        if ( flag( "teleporter_breached" ) && !flag( "teleporter_blocked" ) )
            flag_set( level._be_complete[0] );

        wait 0.1;
    }

    level thread moon_be_activate();
}

moon_be_activate()
{
    start = getstruct( "struct_be_start", "targetname" );
    road_start = getvehiclenode( "vs_stage_1a", "targetname" );

    if ( !isdefined( road_start ) )
    {
/#
        println( "$$$$ Missing road_start, rebsp the level $$$$" );
#/
        wait 1.0;
        return;
    }

    level._be = spawn( "script_model", road_start.origin );
    level._be.angles = road_start.angles;
    level._be setmodel( "p_zom_moon_black_egg" );
    level._be notsolid();
    level._be useanimtree( #animtree );
    level._be.animname = "_be_";
    level._be playloopsound( "evt_sq_blackegg_loop", 1 );
    level._be.stopped = 0;
    level._be thread waittill_player_is_close();
    origin_animate = spawn( "script_model", level._be.origin );
    origin_animate setmodel( "tag_origin_animate" );
    level._be linkto( origin_animate, "origin_animate_jnt", ( 0, 0, 0 ), ( 0, 0, 0 ) );
    level._be_vehicle = spawnvehicle( "tag_origin", "be_mover", "misc_freefall", road_start.origin, road_start.angles );
    level._be_vehicle._be_model = level._be;
    level._be_vehicle._be_org_anim = origin_animate;
    origin_animate linkto( level._be_vehicle );
    level._be_origin_animate = origin_animate;
    level._be_vehicle attachpath( road_start );
    d_trig = spawn( "trigger_damage", level._be_vehicle.origin, 0, 32, 72 );
    start = 0;

    while ( !start )
    {
        d_trig waittill( "damage", amount, attacker, direction, point, dmg_type, modelname, tagname );

        if ( isplayer( attacker ) && moon_be_move( road_start.script_string ) )
        {
            if ( moon_be_move( dmg_type ) )
            {
                level._be playsound( "evt_sq_blackegg_activate" );
                attacker thread play_be_hit_vox( 1 );
                start = 1;
            }
        }
    }

    d_trig delete();
    level._be_vehicle thread moon_be_think();
    level._be startpath();
}

moon_be_think()
{
    self endon( "death" );
    self endon( "finished_path" );
    self endon( "be_stage_one_over" );
    vox_num = 2;
    vox_dude = undefined;

    while ( isdefined( self ) )
    {
        self waittill( "reached_node", node );

        if ( isdefined( node.script_sound ) )
            level._be playsound( node.script_sound );

        if ( isdefined( node.script_flag ) )
            flag_set( node.script_flag );

        if ( isdefined( node.script_string ) )
        {
            self setspeedimmediate( 0 );
            level._be playsound( "evt_sq_blackegg_stop" );
            self thread moon_be_stop_anim();
            d_trig = spawn( "trigger_damage", self.origin, 0, 32, 72 );
            motivation = 0;

            while ( !motivation )
            {
                if ( isdefined( node.script_string ) && node.script_string == "zap" )
                {
                    maps\mp\zombies\_zm_weap_microwavegun::add_microwaveable_object( d_trig );
                    d_trig waittill( "microwaved", vox_dude );
                    maps\mp\zombies\_zm_weap_microwavegun::remove_microwaveable_object( d_trig );
                    motivation = 1;
                }
                else
                {
                    d_trig waittill( "damage", amount, attacker, direction, point, dmg_type, modelname, tagname );

                    if ( isplayer( attacker ) && moon_be_move( node.script_string ) )
                    {
                        motivation = moon_be_move( dmg_type );
                        vox_dude = attacker;
                    }
                }

                self solid();
                wait 0.05;
            }

            if ( isdefined( vox_dude ) )
            {
                vox_dude thread play_be_hit_vox( vox_num );
                vox_num++;
            }

            level._be playsound( "evt_sq_blackegg_activate" );
            d_trig delete();
            self notsolid();
            self setspeed( level._my_speed );
            self thread moon_be_resume_anim();
        }

        if ( isdefined( node.script_waittill ) && node.script_waittill == "sliding_door" )
        {
            self setspeedimmediate( 0 );
            self thread moon_be_stop_anim();
            door_index = get_closest_index_2d( self.origin, level._sliding_doors );

            if ( !isdefined( door_index ) )
            {
/#
                println( "$$$$ door_index is not defined $$$$" );
#/
                wait 1.0;
                continue;
            }

            if ( !isdefined( level._sliding_doors[door_index]._door_open ) )
            {
/#
                println( "$$$$ door is missing knowledge of it being open $$$$" );
#/
                wait 1.0;
                continue;
            }

            if ( !level._sliding_doors[door_index]._door_open )
            {
                level thread play_vox_on_closest_player( 5 );
                level._be playsound( "evt_sq_blackegg_wait" );
                level._be.stopped = 1;
            }

            while ( !level._sliding_doors[door_index]._door_open )
                wait 0.05;

            if ( is_true( level._be.stopped ) )
            {
                level._be playsound( "evt_sq_blackegg_accel" );
                level._be.stopped = 0;
            }

            self setspeed( level._my_speed );
            self thread moon_be_resume_anim();
        }

        if ( isdefined( node.script_hidden ) )
        {
            self setspeedimmediate( 0 );
            self thread moon_be_stop_anim();

            if ( !isdefined( level.flag[node.script_hidden] ) )
                flag_init( node.script_hidden );

            flag_wait( node.script_hidden );
            self setspeed( level._my_speed );
            self thread moon_be_resume_anim();
        }

        if ( isdefined( node.script_parameters ) )
        {
            next_chain_start = getvehiclenode( node.script_parameters, "targetname" );

            if ( !isdefined( next_chain_start ) )
            {
/#
                println( "$$$$ next_chain_start not defined $$$$" );
#/
                wait 1.0;
                continue;
            }

            self setspeedimmediate( 0 );
            level._be playsound( "evt_sq_blackegg_stop" );
            self thread moon_be_stop_anim();
            self attachpath( next_chain_start );

            if ( isdefined( next_chain_start.script_string ) )
            {
                d_trig = spawn( "trigger_damage", self.origin, 0, 32, 72 );
                motivation = 0;

                while ( !motivation )
                {
                    if ( isdefined( next_chain_start.script_string ) && next_chain_start.script_string == "zap" )
                    {
                        maps\mp\zombies\_zm_weap_microwavegun::add_microwaveable_object( d_trig );
                        d_trig waittill( "microwaved", vox_dude );
                        maps\mp\zombies\_zm_weap_microwavegun::remove_microwaveable_object( d_trig );
                        motivation = 1;
                    }
                    else
                    {
                        d_trig waittill( "damage", amount, attacker, direction, point, dmg_type, modelname, tagname );

                        if ( isplayer( attacker ) && moon_be_move( next_chain_start.script_string ) )
                        {
                            motivation = moon_be_move( dmg_type );
                            vox_dude = attacker;
                        }
                    }

                    wait 0.05;
                }

                d_trig delete();
            }

            if ( isdefined( vox_dude ) )
            {
                vox_dude thread play_be_hit_vox( vox_num );
                vox_num++;
            }

            level._be playsound( "evt_sq_blackegg_activate" );
            self setspeed( level._my_speed );
            self startpath();
            self thread moon_be_resume_anim();
        }

        if ( isdefined( node.script_int ) )
            self setspeedimmediate( node.script_int );

        if ( isdefined( node.script_index ) )
            self thread moon_be_anim_swap( node.script_index );
    }
}

moon_be_move( motivation_array )
{
    if ( !isdefined( motivation_array ) )
        return false;

    if ( !isstring( motivation_array ) )
    {
/#
        println( "$$$$ Motivation passed in that wasn't an string $$$$" );
#/
        return false;
    }

    motivational_array = strtok( motivation_array, "," );
    match = 0;

    for ( i = 0; i < motivational_array.size; i++ )
    {
        for ( j = 0; j < level.motivational_array.size; j++ )
        {
            if ( motivational_array[i] == level.motivational_array[j] )
            {
                match = 1;
                return true;
            }
        }
    }

    if ( !match )
    {
/#
        println( "$$$$ No match to motivation $$$$" );
#/

        if ( isdefined( motivational_array[0] ) )
        {
/#
            println( "$$$$ " + motivational_array[0] + " $$$$ " );
#/
        }
        else
        {
/#
            println( "$$$$ Missing str_motivation $$$$" );
#/
        }

        return false;
    }
}

get_closest_index_2d( org, array, dist )
{
    if ( !isdefined( dist ) )
        dist = 9999999;

    if ( array.size < 1 )
        return;

    index = undefined;

    for ( i = 0; i < array.size; i++ )
    {
        newdist = distance2d( array[i].origin, org );

        if ( newdist >= dist )
            continue;

        dist = newdist;
        index = i;
    }

    return index;
}

moon_be_anim_swap( int_anim )
{
    self endon( "death" );

    if ( int_anim == 0 )
    {

    }
    else
    {

    }
}

moon_be_stop_anim()
{
    self endon( "death" );
}

moon_be_resume_anim()
{
    self endon( "death" );
    self endon( "be_stage_one_over" );
    rand = randomint( 1 );

    if ( rand )
    {

    }
    else
    {

    }
}

waittill_player_is_close()
{
    while ( true )
    {
        players = get_players();

        for ( i = 0; i < players.size; i++ )
        {
            if ( distancesquared( players[i].origin, self.origin ) <= 62500 )
            {
                players[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest2", undefined, 0 );
                return;
            }
        }

        wait 0.5;
    }
}

play_be_hit_vox( num )
{
    if ( num > 4 )
        num = num - 4;

    self thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest2", undefined, num );
}

play_vox_on_closest_player( num )
{
    player = get_closest_player( level._be.origin );
    player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "eggs", "quest2", undefined, num );
}
