// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_ambientpackage;
#include clientscripts\mp\_music;
#include clientscripts\mp\_audio;

main()
{
    declaremusicstate( "WAVE" );
    musicaliasloop( "mus_theatre_underscore", 4, 2 );
    declaremusicstate( "EGG" );
    musicalias( "mus_egg", 1 );
    declaremusicstate( "SILENCE" );
    musicalias( "null", 1 );
    declareambientroom( "outside", 1 );
    declareambientpackage( "outside" );
    setambientroomreverb( "outside", "RV_ZOMBIES_OUTDOOR", 1, 1 );
    setambientroomcontext( "outside", "ringoff_plr", "outdoor" );
    setambientroomtone( "outside", "ghost_wind", 1.5, 2 );
    addambientelement( "outside", "ember", 0.1, 0.6, 50, 150 );
    declareambientroom( "int_small_room" );
    declareambientpackage( "int_small_pkg" );
    setambientroomreverb( "int_small_room", "RV_ZOMBIES_MEDIUM_ROOM", 1, 1 );
    setambientroomcontext( "int_small_room", "ringoff_plr", "indoor" );
    declareambientroom( "int_large_room" );
    declareambientpackage( "int_large_pkg" );
    setambientroomreverb( "int_large_room", "RV_ZOMBIES_LARGE_ROOM", 1, 1 );
    setambientroomcontext( "int_large_room", "ringoff_plr", "indoor" );
    declareambientroom( "darkroom" );
    declareambientpackage( "darkroom" );
    setambientroomreverb( "darkroom", "RV_ZOMBIES_MEDIUM_ROOM", 1, 1 );
    setambientroomcontext( "darkroom", "ringoff_plr", "indoor" );
    activateambientpackage( 0, "outside", 0 );
    activateambientroom( 0, "outside", 0 );
    declaremusicstate( "SPLASH_SCREEN" );
    musicalias( "mx_splash_screen", 12 );
    musicwaittilldone();
    declaremusicstate( "WAVE" );
    musicaliasloop( "mus_zombie_wave_loop", 0, 4 );
    declaremusicstate( "EGG" );
    musicalias( "mus_factory_egg", 1 );
    declaremusicstate( "SILENCE" );
    musicalias( "null", 1 );
    thread start_lights();
    thread teleport_pad_init( 0 );
    thread teleport_pad_init( 1 );
    thread teleport_pad_init( 2 );
    thread teleport_2d();
    thread pa_init( 0 );
    thread pa_init( 1 );
    thread pa_init( 2 );
    thread pa_single_init();
    thread pole_fx_audio_init( 0 );
    thread pole_fx_audio_init( 1 );
    thread pole_fx_audio_init( 2 );
    thread homepad_loop();
    thread power_audio_2d();
    thread linkall_2d();
}

start_lights()
{
    level waittill( "pl1" );
    array_thread( getstructarray( "dyn_light", "targetname" ), ::light_sound );
    array_thread( getstructarray( "switch_progress", "targetname" ), ::switch_progress_sound );
    array_thread( getstructarray( "dyn_generator", "targetname" ), ::generator_sound );
    array_thread( getstructarray( "dyn_breakers", "targetname" ), ::breakers_sound );
}

light_sound()
{
    if ( isdefined( self ) )
    {
        playsound( 0, "light_start", self.origin );
        e1 = clientscripts\mp\_audio::playloopat( "light", self.origin );
    }
}

generator_sound()
{
    if ( isdefined( self ) )
    {
        wait 3;
        playsound( 0, "switch_progress", self.origin );
        playsound( 0, "gen_start", self.origin );
        g1 = clientscripts\mp\_audio::playloopat( "gen_loop", self.origin );
    }
}

breakers_sound()
{
    if ( isdefined( self ) )
    {
        playsound( 0, "break_start", self.origin );
        b1 = clientscripts\mp\_audio::playloopat( "break_loop", self.origin );
    }
}

switch_progress_sound()
{
    if ( isdefined( self.script_noteworthy ) )
    {
        if ( self.script_noteworthy == "1" )
            time = 0.5;
        else if ( self.script_noteworthy == "2" )
            time = 1;
        else if ( self.script_noteworthy == "3" )
            time = 1.5;
        else if ( self.script_noteworthy == "4" )
            time = 2;
        else if ( self.script_noteworthy == "5" )
            time = 2.5;
        else
            time = 0;

        wait( time );
        playsound( 0, "switch_progress", self.origin );
    }
}

homepad_loop()
{
    level waittill( "pap1" );
    homepad = getstruct( "homepad_power_looper", "targetname" );
    home_breaker = getstruct( "homepad_breaker", "targetname" );

    if ( isdefined( homepad ) )
        clientscripts\mp\_audio::playloopat( "homepad_power_loop", homepad.origin );

    if ( isdefined( home_breaker ) )
        clientscripts\mp\_audio::playloopat( "break_arc", home_breaker.origin );
}

teleport_pad_init( pad )
{
    telepad = getstructarray( "telepad_" + pad, "targetname" );
    telepad_loop = getstructarray( "telepad_" + pad + "_looper", "targetname" );
    homepad = getstructarray( "homepad", "targetname" );
    level waittill( "tp" + pad );
    array_thread( telepad_loop, ::telepad_loop );
    array_thread( telepad, ::teleportation_audio, pad );
    array_thread( homepad, ::teleportation_audio, pad );
}

telepad_loop()
{
    clientscripts\mp\_audio::playloopat( "power_loop", self.origin );
}

teleportation_audio( pad )
{
    teleport_delay = 2;

    while ( true )
    {
        level waittill( "tpw" + pad );

        if ( isdefined( self.script_sound ) )
        {
            if ( self.targetname == "telepad_" + pad )
            {
                playsound( 0, self.script_sound + "_warmup", self.origin );
                waitrealtime( teleport_delay );
                playsound( 0, self.script_sound + "_cooldown", self.origin );
            }

            if ( self.targetname == "homepad" )
            {
                waitrealtime( teleport_delay );
                playsound( 0, self.script_sound + "_warmup", self.origin );
                playsound( 0, self.script_sound + "_cooldown", self.origin );
            }
        }
    }
}

pa_init( pad )
{
    pa_sys = getstructarray( "pa_system", "targetname" );
    array_thread( pa_sys, ::pa_teleport, pad );
    array_thread( pa_sys, ::pa_countdown, pad );
    array_thread( pa_sys, ::pa_countdown_success, pad );
}

pa_single_init()
{
    pa_sys = getstructarray( "pa_system", "targetname" );
    array_thread( pa_sys, ::pa_electric_trap, "bridge" );
    array_thread( pa_sys, ::pa_electric_trap, "wuen" );
    array_thread( pa_sys, ::pa_electric_trap, "warehouse" );
    array_thread( pa_sys, ::pa_level_start );
    array_thread( pa_sys, ::pa_power_on );
}

pa_countdown( pad )
{
    level endon( "scd" + pad );

    while ( true )
    {
        level waittill( "pac" + pad );
        playsound( 0, "pa_buzz", self.origin );
        self thread pa_play_dialog( "pa_audio_link_start" );

        for ( count = 30; count > 0; count-- )
        {
            play = count == 20 || count == 15 || count <= 10;

            if ( play )
                playsound( 0, "pa_audio_link_" + count, self.origin );

            playsound( 0, "clock_tick_1sec", ( 0, 0, 0 ) );
            waitrealtime( 1 );
        }

        playsound( 0, "pa_buzz", self.origin );
        wait 1.2;
        self thread pa_play_dialog( "pa_audio_link_fail" );
    }

    wait 1;
}

pa_countdown_success( pad )
{
    level waittill( "scd" + pad );
    playsound( 0, "pa_buzz", self.origin );
    wait 1.2;
    self pa_play_dialog( "pa_audio_act_pad_" + pad );
}

pa_teleport( pad )
{
    while ( true )
    {
        level waittill( "tpc" + pad );
        wait 1;
        playsound( 0, "pa_buzz", self.origin );
        wait 1.2;
        self pa_play_dialog( "pa_teleport_finish" );
    }
}

pa_electric_trap( location )
{
    while ( true )
    {
        level waittill( location );
        playsound( 0, "pa_buzz", self.origin );
        wait 1.2;
        self thread pa_play_dialog( "pa_trap_inuse_" + location );
        waitrealtime( 48.5 );
        playsound( 0, "pa_buzz", self.origin );
        wait 1.2;
        self thread pa_play_dialog( "pa_trap_active_" + location );
    }
}

pa_play_dialog( alias )
{
    if ( !isdefined( self.pa_is_speaking ) )
        self.pa_is_speaking = 0;

    if ( self.pa_is_speaking != 1 )
    {
        self.pa_is_speaking = 1;
        self.pa_id = playsound( 0, alias, self.origin );

        while ( soundplaying( self.pa_id ) )
            wait 0.01;

        self.pa_is_speaking = 0;
    }
}

teleport_2d()
{
    while ( true )
    {
        level waittill( "t2d" );
        playsound( 0, "teleport_2d_fnt", ( 0, 0, 0 ) );
        playsound( 0, "teleport_2d_rear", ( 0, 0, 0 ) );
    }
}

power_audio_2d()
{
    wait 2;
    playsound( 0, "power_down_2d", ( 0, 0, 0 ) );
    level waittill( "pl1" );
    playsound( 0, "power_up_2d", ( 0, 0, 0 ) );
}

linkall_2d()
{
    level waittill( "pap1" );
    playsound( 0, "linkall_2d", ( 0, 0, 0 ) );
}

pole_fx_audio_init( pad )
{
    pole = getstructarray( "pole_fx_" + pad, "targetname" );
    array_thread( pole, ::pole_fx_audio, pad );
}

pole_fx_audio( pad )
{
    level waittill( "scd" + pad );

    while ( true )
    {
        playfx( 0, level._effect["zombie_elec_pole_terminal"], self.origin, anglestoforward( self.angles ) );
        playsound( 0, "pole_spark", self.origin );
        waitrealtime( randomintrange( 2, 7 ) );
    }
}

pa_level_start()
{
    wait 2;
    playsound( 0, "pa_buzz", self.origin );
    wait 1.2;
    self pa_play_dialog( "pa_level_start" );
}

pa_power_on()
{
    level waittill( "pl1" );
    playsound( 0, "pa_buzz", self.origin );
    wait 1.2;
    self pa_play_dialog( "pa_power_on" );
}
