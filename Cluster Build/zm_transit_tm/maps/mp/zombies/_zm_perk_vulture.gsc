// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm;
#include maps\mp\zombies\_zm_score;

init_vulture()
{
    level._effect["vulture_perk_zombie_stink"] = loadfx( "maps/zombie/fx_zmb_meat_glow" );
    precachemodel( "p6_zm_perk_vulture_ammo" );
    precachemodel( "p6_zm_perk_vulture_points" );
    setdvarint( "zombies_perk_vulture_pickup_time", 12 );
    setdvarint( "zombies_perk_vulture_pickup_time_stink", 16 );
    setdvarint( "zombies_perk_vulture_drop_chance", 65 );
    setdvarint( "zombies_perk_vulture_ammo_chance", 40 );
    setdvarint( "zombies_perk_vulture_points_chance", 50 );
    setdvarint( "zombies_perk_vulture_stink_chance", 10 );
    level.perk_vulture = spawnstruct();
    level.perk_vulture.zombie_stink_array = [];
}

enable_vulture_perk_for_level()
{
    level.zombiemode_using_vulture_perk = 1;
}

give_vulture_perk()
{
    iprintln( "player " + self getentitynumber() + " has vulture perk!" );
    self.hasperkspecialtyvulture = 1;
    self thread _vulture_perk_think();
}

take_vulture_perk()
{
    iprintln( "player " + self getentitynumber() + " has lost vulture perk!" );
    self.hasperkspecialtyvulture = undefined;
    self notify( "vulture_perk_lost" );
}

do_vulture_death( player )
{
    if ( isdefined( self ) )
        self thread _do_vulture_death( player );
}

_do_vulture_death( player )
{
    if ( should_do_vulture_drop() )
    {
        str_bonus = get_vulture_drop_type();
        str_identifier = "_" + self getentitynumber() + "_" + gettime();
        player thread show_debug_info( self.origin, str_identifier, str_bonus );
        self thread vulture_drop_funcs( self.origin, player, str_identifier, str_bonus );
    }
}

vulture_drop_funcs( v_origin, player, str_identifier, str_bonus )
{
    switch ( str_bonus )
    {
        case "ammo":
            self thread check_vulture_drop_pickup( self.origin, player, str_identifier, str_bonus );
            player thread _vulture_drop_model( str_identifier, "p6_zm_perk_vulture_ammo", v_origin, vectorscale( ( 0, 0, 1 ), 15.0 ) );
            break;
        case "points":
            self thread check_vulture_drop_pickup( self.origin, player, str_identifier, str_bonus );
            player thread _vulture_drop_model( str_identifier, "p6_zm_perk_vulture_points", v_origin, vectorscale( ( 0, 0, 1 ), 15.0 ) );
            break;
        case "stink":
            e_temp = player zombie_drops_stink( self.origin, str_identifier );
            e_temp = player _vulture_spawn_fx( str_identifier, level._effect["vulture_perk_zombie_stink"], v_origin, str_bonus, e_temp );
            clean_up_stink( e_temp );
            break;
    }
}

zombie_drops_stink( v_drop_location, str_identifier )
{
    e_temp = spawn( "script_model", v_drop_location );
    level.perk_vulture.zombie_stink_array[level.perk_vulture.zombie_stink_array.size] = e_temp;
    self delay_notify( str_identifier, getdvarint( #"_id_DDE8D546" ) );
    return e_temp;
}

clean_up_stink( e_temp )
{
    arrayremovevalue( level.perk_vulture.zombie_stink_array, e_temp, 0 );
    e_temp delete();
}

_vulture_drop_model( str_identifier, str_model, v_model_origin, v_offset )
{
    if ( !isdefined( v_offset ) )
        v_offset = ( 0, 0, 0 );

    e_temp = spawn( "script_model", v_model_origin + v_offset );
    e_temp setmodel( str_model );
    self waittill_any( str_identifier, "death", "disconnect" );
    e_temp delete();
}

_vulture_spawn_fx( str_identifier, n_fx_id, v_fx_origin, str_bonus, e_temp )
{
    b_delete = 0;

    if ( !isdefined( e_temp ) )
    {
        e_temp = spawn( "script_model", v_fx_origin );
        b_delete = 1;
    }

    e_temp setmodel( "tag_origin" );
    playfxontag( n_fx_id, e_temp, "tag_origin" );
    self waittill_any( str_identifier, "death", "disconnect" );

    if ( b_delete )
        e_temp delete();

    return e_temp;
}

should_do_vulture_drop()
{
    n_roll = randomint( 100 );
    b_should_drop = n_roll > 100 - getdvarint( #"_id_70E3B3FA" );
    return b_should_drop;
}

get_vulture_drop_type()
{
    n_chance_ammo = getdvarint( #"_id_F75E07AF" );
    n_chance_points = getdvarint( #"_id_D7BCDBE2" );
    n_chance_stink = getdvarint( #"_id_4918C38E" );
    n_total_weight = n_chance_ammo + n_chance_points + n_chance_stink;
    n_cutoff_ammo = n_chance_ammo;
    n_cutoff_points = n_chance_ammo + n_chance_points;
    n_roll = randomint( n_total_weight );

    if ( n_roll < n_cutoff_ammo )
        str_bonus = "ammo";
    else if ( n_roll > n_cutoff_ammo && n_roll < n_cutoff_points )
        str_bonus = "points";
    else
        str_bonus = "stink";

    return str_bonus;
}

show_debug_info( v_drop_point, str_identifier, str_bonus )
{
/#
    if ( getdvarint( #"_id_38E68F2B" ) )
    {
        self endon( str_identifier );
        iprintln( "zombie dropped " + str_bonus );

        for ( i = 0; i < get_vulture_drop_duration( str_bonus ) * 20; i++ )
        {
            circle( v_drop_point, 32, get_debug_circle_color( str_bonus ), 0, 1, 1 );
            wait 0.05;
        }
    }
#/
}

get_vulture_drop_duration( str_bonus )
{
    str_dvar = "zombies_perk_vulture_pickup_time";

    if ( str_bonus == "stink" )
        str_dvar = "zombies_perk_vulture_pickup_time_stink";

    n_duration = getdvarint( str_dvar );
    return n_duration;
}

get_debug_circle_color( str_bonus )
{
    switch ( str_bonus )
    {
        case "ammo":
            v_color = ( 0, 0, 1 );
            break;
        case "points":
            v_color = ( 1, 1, 0 );
            break;
        case "stink":
            v_color = ( 0, 1, 0 );
            break;
        default:
            v_color = ( 1, 1, 1 );
            break;
    }

    return v_color;
}

check_vulture_drop_pickup( v_drop_origin, player, str_identifier, str_bonus )
{
    player endon( "death" );
    player endon( "disconnect" );
    n_times_to_check = int( get_vulture_drop_duration( str_bonus ) / 0.25 );

    for ( i = 0; i < n_times_to_check; i++ )
    {
        b_player_inside_radius = distancesquared( v_drop_origin, player.origin ) < 1024;

        if ( b_player_inside_radius )
            break;

        wait 0.25;
    }

    player notify( str_identifier );

    if ( b_player_inside_radius )
        player give_vulture_bonus( str_bonus );
}

_handle_zombie_stink( b_player_inside_radius )
{
    if ( !isdefined( self.is_in_zombie_stink ) )
        self.is_in_zombie_stink = 0;

    b_in_stink_last_check = self.is_in_zombie_stink;
    self.is_in_zombie_stink = b_player_inside_radius;
    self.ignoreme = self.is_in_zombie_stink;

    if ( self.is_in_zombie_stink && !b_in_stink_last_check )
    {
        if ( get_players().size == 1 )
        {
            level.default_find_exit_position_override = ::vulture_perk_should_zombies_resume_find_flesh;
            self thread maps\mp\zombies\_zm::default_exit_level();
        }
    }
}

vulture_perk_should_zombies_resume_find_flesh()
{
    b_should_find_flesh = !is_player_in_zombie_stink();
    return b_should_find_flesh;
}

is_player_in_zombie_stink()
{
    a_players = get_players();
    b_player_in_zombie_stink = 0;

    for ( i = 0; !b_player_in_zombie_stink && i < a_players.size; i++ )
    {
        if ( isdefined( a_players[i].is_in_zombie_stink ) && a_players[i].is_in_zombie_stink )
            b_player_in_zombie_stink = 1;
    }

    return b_player_in_zombie_stink;
}

give_vulture_bonus( str_bonus )
{
    switch ( str_bonus )
    {
        case "ammo":
            self give_bonus_ammo();
            break;
        case "points":
            self give_bonus_points();
            break;
        case "stink":
            self give_bonus_stink();
            break;
        default:
            assert( "invalid bonus string '" + str_bonus + "' used in give_vulture_bonus()!" );
            break;
    }
}

give_bonus_ammo()
{
    str_weapon_current = self getcurrentweapon();

    if ( str_weapon_current != "none" )
    {
        n_ammo_count_current = self getweaponammostock( str_weapon_current );
        n_ammo_count_max = weaponmaxammo( str_weapon_current );
        n_bullets_refunded = int( n_ammo_count_max * 0.05 );
        self setweaponammostock( str_weapon_current, n_ammo_count_current + n_bullets_refunded );
/#
        if ( getdvarint( #"_id_38E68F2B" ) )
            iprintln( str_weapon_current + " bullets given: " + n_bullets_refunded );
#/
    }
}

give_bonus_points()
{
    self maps\mp\zombies\_zm_score::player_add_points( "vulture", 5 );
}

give_bonus_stink( v_drop_origin )
{
    self _handle_zombie_stink( 0 );
}

_vulture_perk_think()
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "vulture_perk_lost" );

    while ( true )
    {
        b_player_in_zombie_stink = 0;

        if ( !isdefined( level.perk_vulture.zombie_stink_array ) )
            level.perk_vulture.zombie_stink_array = [];

        if ( level.perk_vulture.zombie_stink_array.size > 0 )
        {
            a_close_points = arraysort( level.perk_vulture.zombie_stink_array, self.origin, 1, 300 );

            if ( a_close_points.size > 0 )
                b_player_in_zombie_stink = self _is_player_in_zombie_stink( a_close_points );
        }

        self _handle_zombie_stink( b_player_in_zombie_stink );
        wait( randomfloatrange( 0.25, 0.5 ) );
    }
}

_is_player_in_zombie_stink( a_points )
{
    b_is_in_stink = 0;

    for ( i = 0; i < a_points.size; i++ )
    {
        if ( distancesquared( a_points[i].origin, self.origin ) < 1024 )
            b_is_in_stink = 1;
    }

    return b_is_in_stink;
}
