// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include common_scripts\utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\zombies\_zm_perk_electric_cherry;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\_visionset_mgr;

init()
{
    maps\mp\zombies\_zm_perks::register_perk_thread( "specialty_grenadepulldeath", maps\mp\zombies\_zm_perk_electric_cherry::electric_cherry_reload_attack );
    level.custom_laststand_func = ::electric_cherry_laststand;
    level._effect["electric_cherry_explode"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_electric_cherry_player" );
    level._effect["tesla_shock"] = loadfx( "maps/zombie/fx_zombie_tesla_shock" );
    level._effect["tesla_shock_secondary"] = loadfx( "maps/zombie/fx_zombie_tesla_shock_secondary" );
    set_zombie_var( "tesla_head_gib_chance", 50 );
}

electric_cherry_player_init()
{

}

electric_cherry_laststand()
{
    perk_radius = 500;
    perk_dmg = 1000;
    perk_points = 40;
    perk_delay = 1.5;
    self thread electric_cherry_visionset();
    wait( perk_delay );
    visionsetlaststand( "zm_electric_cherry", 1 );

    if ( isdefined( self ) )
    {
        playfx( level._effect["electric_cherry_explode"], self.origin );
        self playsound( "zmb_cherry_explode" );
        a_zombies = get_round_enemy_array();
        a_zombies = get_array_of_closest( self.origin, a_zombies, undefined, undefined, perk_radius );

        for ( i = 0; i < a_zombies.size; i++ )
        {
            if ( isdefined( self ) && isalive( self ) )
            {
                if ( a_zombies[i].health <= perk_dmg )
                {
                    a_zombies[i] thread electric_cherry_death_fx();
                    self maps\mp\zombies\_zm_score::add_to_player_score( perk_points );
                }
                else
                {
                    a_zombies[i] thread electric_cherry_stun();
                    a_zombies[i] thread electric_cherry_shock_fx();
                }

                wait 0.1;
                a_zombies[i] dodamage( perk_dmg, self.origin, self );
            }
        }
    }
}

electric_cherry_death_fx()
{
    self endon( "death" );
    tag = "J_SpineUpper";
    fx = "tesla_shock";

    if ( self.isdog )
        tag = "J_Spine1";

    self playsound( "zmb_elec_jib_zombie" );
    network_safe_play_fx_on_tag( "tesla_death_fx", 2, level._effect[fx], self, tag );

    if ( isdefined( self.tesla_head_gib_func ) && !self.head_gibbed )
        [[ self.tesla_head_gib_func ]]();
}

electric_cherry_shock_fx()
{
    self endon( "death" );
    tag = "J_SpineUpper";
    fx = "tesla_shock_secondary";

    if ( self.isdog )
        tag = "J_Spine1";

    self playsound( "zmb_elec_jib_zombie" );
    network_safe_play_fx_on_tag( "tesla_shock_fx", 2, level._effect[fx], self, tag );
}

electric_cherry_stun()
{
    self endon( "death" );
    self notify( "stun_zombie" );
    self endon( "stun_zombie" );

    if ( self.health <= 0 )
    {
/#
        iprintln( "trying to stun a dead zombie" );
#/
        return;
    }

    if ( isdefined( self.stun_zombie ) )
    {
        self thread [[ self.stun_zombie ]]();
        return;
    }

    self thread maps\mp\zombies\_zm_ai_basic::start_inert();
}

electric_cherry_visionset()
{
    if ( isdefined( self ) && flag( "solo_game" ) )
    {
        if ( isdefined( level.vsmgr_prio_visionset_zm_electric_cherry ) )
        {
            if ( !isdefined( self.electric_cherry_visionset ) || self.electric_cherry_visionset == 0 )
            {
                maps\mp\_visionset_mgr::vsmgr_activate( "visionset", "zm_electric_cherry", self );
                self.electric_cherry_visionset = 1;
            }
        }
    }

    wait 5;

    if ( isdefined( self ) && isdefined( level.vsmgr_prio_visionset_zm_electric_cherry ) )
    {
        if ( isdefined( self.electric_cherry_visionset ) && self.electric_cherry_visionset )
        {
            maps\mp\_visionset_mgr::vsmgr_deactivate( "visionset", "zm_electric_cherry", self );
            self.electric_cherry_visionset = 0;
        }
        else if ( !flag( "solo_game" ) )
            visionsetlaststand( "zombie_last_stand", 1 );
    }
}

electric_cherry_reload_attack()
{
    self endon( "death" );
    self endon( "disconnect" );
    perk_points = 40;
    self.wait_on_reload = [];

    while ( true )
    {
        self waittill( "reload_start" );
        str_current_weapon = self getcurrentweapon();

        if ( isinarray( self.wait_on_reload, str_current_weapon ) )
            continue;

        self.wait_on_reload[self.wait_on_reload.size] = str_current_weapon;
        n_clip_current = self getweaponammoclip( str_current_weapon );
        n_clip_max = weaponclipsize( str_current_weapon );
        n_fraction = n_clip_current / n_clip_max;
        perk_radius = linear_map( n_fraction, 1.0, 0.0, 8, 128 );
        perk_dmg = linear_map( n_fraction, 1.0, 0.0, 1, 100 );
        self thread check_for_reload_complete( str_current_weapon );

        if ( isdefined( self ) )
        {
            playfx( level._effect["electric_cherry_explode"], self.origin );
            self playsound( "zmb_cherry_explode" );
            a_zombies = get_round_enemy_array();
            a_zombies = get_array_of_closest( self.origin, a_zombies, undefined, undefined, perk_radius );

            for ( i = 0; i < a_zombies.size; i++ )
            {
                if ( isdefined( self ) && isalive( self ) )
                {
                    if ( a_zombies[i].health <= perk_dmg )
                    {
                        a_zombies[i] thread electric_cherry_death_fx();
                        self maps\mp\zombies\_zm_score::add_to_player_score( perk_points );
                    }
                    else
                    {
                        a_zombies[i] thread electric_cherry_stun();
                        a_zombies[i] thread electric_cherry_shock_fx();
                    }

                    wait 0.1;
                    a_zombies[i] dodamage( perk_dmg, self.origin, self );
                }
            }
        }
    }
}

check_for_reload_complete( weapon )
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "player_lost_weapon_" + weapon );
    self thread weapon_replaced_monitor( weapon );

    while ( true )
    {
        self waittill( "reload" );
        str_current_weapon = self getcurrentweapon();

        if ( str_current_weapon == weapon )
        {
            arrayremovevalue( self.wait_on_reload, weapon );
            self notify( "weapon_reload_complete_" + weapon );
            break;
        }
    }
}

weapon_replaced_monitor( weapon )
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "weapon_reload_complete_" + weapon );

    while ( true )
    {
        self waittill( "weapon_change" );
        primaryweapons = self getweaponslistprimaries();

        if ( !isinarray( primaryweapons, weapon ) )
        {
            self notify( "player_lost_weapon_" + weapon );
            arrayremovevalue( self.wait_on_reload, weapon );
            break;
        }
    }
}
