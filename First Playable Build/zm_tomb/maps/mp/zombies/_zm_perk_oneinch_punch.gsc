// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\_utility;
#include common_scripts\utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_score;
#include maps\mp\animscripts\zm_shared;

enable_oneinch_punch_perk_for_level()
{
    maps\mp\zombies\_zm_perks::register_perk_basic_info( "specialty_fastmeleerecovery", "oneinch_punch", 3500, &"ZM_TOMB_PERK_ONEINCH", "zombie_perk_bottle_oneinch" );
    maps\mp\zombies\_zm_perks::register_perk_precache_func( "specialty_fastmeleerecovery", ::one_inch_precache );
    maps\mp\zombies\_zm_perks::register_perk_clientfields( "specialty_fastmeleerecovery", ::one_inch_register_clientfield, ::one_inch_set_clientfield );
    maps\mp\zombies\_zm_perks::register_perk_threads( "specialty_fastmeleerecovery", ::one_inch_punch_melee_attack, ::remove_one_inch_punch );
}

remove_one_inch_punch()
{
    current_melee_weapon = self get_player_melee_weapon();
    self takeweapon( current_melee_weapon );
    self giveweapon( "knife_zm" );
    self set_player_melee_weapon( "knife_zm" );
    self setclientfieldtoplayer( "perk_oneinch_punch", 0 );
}

one_inch_precache()
{
    precacheitem( "one_inch_punch_zm" );
    level._effect["oneinch_impact"] = loadfx( "maps/zombie_tomb/fx_tomb_perk_one_inch_punch" );
    level._effect["punch_knockdown_ground"] = loadfx( "weapon/thunder_gun/fx_thundergun_knockback_ground" );
}

one_inch_register_clientfield()
{
    registerclientfield( "toplayer", "perk_oneinch_punch", 14000, 1, "int" );
}

one_inch_set_clientfield( state )
{
    self setclientfieldtoplayer( "perk_oneinch_punch", state );
}

one_inch_perk_machine_setup( use_trigger, perk_machine, bump_trigger, collision )
{
    use_trigger.script_sound = "mus_perks_revive_jingle";
    use_trigger.script_string = "one_inch_perk";
    use_trigger.script_label = "mus_perks_revive_sting";
    use_trigger.target = "vending_one_inch_punch";
    perk_machine.script_string = "one_inch_perk";
    perk_machine.targetname = "vending_one_inch_punch";
    bump_trigger.script_string = "one_inch_perk";
}

one_inch_punch_melee_attack()
{
    self endon( "player_downed" );
    self endon( "disconnect" );
    self endon( "stop_one_inch_punch_attack" );
    self ent_flag_init( "melee_punch_cooldown" );
    current_melee_weapon = self get_player_melee_weapon();
    self takeweapon( current_melee_weapon );
    self giveweapon( "one_inch_punch_zm" );
    self set_player_melee_weapon( "one_inch_punch_zm" );
    self thread monitor_melee_swipe();
}

monitor_melee_swipe()
{
    self endon( "player_downed" );
    self endon( "disconnect" );

    while ( true )
    {
        while ( !self ismeleeing() )
            wait 0.05;

        earthquake( 0.5, 0.5, self.origin, 300, self );
        self playrumbleonentity( "damage_heavy" );
        v_punch_effect_fwd = anglestoforward( self getplayerangles() );
        v_punch_effect_pos = self geteye() + ( v_punch_effect_fwd[0], v_punch_effect_fwd[1], 0 );
        physicsexplosioncylinder( self.origin, 300, 150, 1 );
        v_forward = anglestoforward( self getplayerangles() ) * 90;
        v_end_pos = self.origin + ( v_forward[0], v_forward[1], 0 );
        trig_death_zone = spawn( "trigger_radius", v_end_pos, 0, 50, 90 );
        a_zombies = get_round_enemy_array();
        a_zombies = get_array_of_closest( self.origin, a_zombies, undefined, undefined, 100 );

        foreach ( zombie in a_zombies )
        {
            if ( self is_player_facing( zombie ) && distancesquared( self.origin, zombie.origin ) <= 4096 )
            {
                self thread zombie_punch_damage( zombie, 1 );
                continue;
            }

            if ( self is_player_facing( zombie ) )
                self thread zombie_punch_damage( zombie, 0.5 );
        }

        trig_death_zone delete();

        while ( self ismeleeing() )
            wait 0.05;

        wait 0.05;
    }
}

is_player_facing( ai_zombie )
{
    forward_dot = vectordot( anglestoforward( self.angles ), vectornormalize( ai_zombie.origin - self.origin ) );

    if ( forward_dot > 0.85 )
        return true;
    else
        return false;
}

is_oneinch_punch_damage()
{
    return isdefined( self.damageweapon ) && self.damageweapon == "one_inch_punch_zm";
}

gib_zombies_head( player )
{
    player endon( "disconnect" );
    self maps\mp\zombies\_zm_spawner::zombie_head_gib();
}

punch_cooldown()
{
    wait 1;
    self ent_flag_set( "melee_punch_cooldown" );
}

zombie_punch_damage( ai_zombie, n_mod )
{
    self endon( "disconnect" );

    if ( !( !isdefined( ai_zombie.ai_state ) && !isdefined( "find_flesh" ) || isdefined( ai_zombie.ai_state ) && isdefined( "find_flesh" ) && ai_zombie.ai_state == "find_flesh" ) )
        return;

    ai_zombie.punch_handle_pain_notetracks = ::handle_punch_pain_notetracks;

    if ( isdefined( n_mod ) )
    {
        n_damage = int( level.zombie_health * n_mod );
        n_points = int( 10 * n_mod );

        if ( n_damage >= ai_zombie.health )
            self thread zombie_punch_death( ai_zombie );

        ai_zombie dodamage( n_damage, ai_zombie.origin, ai_zombie, ai_zombie, "none", "MOD_MELEE", 0, "one_inch_punch_zm" );
        self maps\mp\zombies\_zm_score::add_to_player_score( n_points );
    }

    if ( isdefined( ai_zombie.is_knocked_down ) && ai_zombie.is_knocked_down )
        return;
    else
    {
        ai_zombie.v_punched_from = self.origin;
        ai_zombie animcustom( ::knockdown_zombie_animate );
    }
}

zombie_punch_death( ai_zombie )
{
    ai_zombie thread gib_zombies_head( self );
    ai_zombie startragdoll();
    v_launch = vectornormalize( ai_zombie.origin - self.origin ) * randomintrange( 125, 150 ) + ( 0, 0, randomintrange( 75, 150 ) );
    ai_zombie launchragdoll( v_launch );
}

handle_punch_pain_notetracks( note )
{
    if ( note == "zombie_knockdown_ground_impact" )
        playfx( level._effect["punch_knockdown_ground"], self.origin, anglestoforward( self.angles ), anglestoup( self.angles ) );
}

knockdown_zombie_animate()
{
    self notify( "end_play_punch_pain_anim" );
    self endon( "killanimscript" );
    self endon( "death" );
    self endon( "end_play_punch_pain_anim" );

    if ( isdefined( self.marked_for_death ) && self.marked_for_death )
        return;

    self.allowpain = 0;
    animation_direction = undefined;
    animation_legs = "";
    animation_side = undefined;
    animation_duration = "_default";
    v_forward = vectordot( anglestoforward( self.angles ), vectornormalize( self.v_punched_from - self.origin ) );

    if ( v_forward > 0.6 )
    {
        animation_direction = "back";

        if ( !( isdefined( self.has_legs ) && self.has_legs ) )
            animation_legs = "_crawl";

        if ( randomint( 100 ) > 75 )
            animation_side = "belly";
        else
            animation_side = "back";
    }
    else if ( self.damageyaw > 75 && self.damageyaw < 135 )
    {
        animation_direction = "left";
        animation_side = "belly";
    }
    else if ( self.damageyaw > -135 && self.damageyaw < -75 )
    {
        animation_direction = "right";
        animation_side = "belly";
    }
    else
    {
        animation_direction = "front";
        animation_side = "belly";
    }

    self thread knockdown_zombie_animate_state();
    self setanimstatefromasd( "zm_punch_fall_" + animation_direction + animation_legs );
    self maps\mp\animscripts\zm_shared::donotetracks( "punch_fall_anim", self.punch_handle_pain_notetracks );

    if ( !( isdefined( self.has_legs ) && self.has_legs ) || isdefined( self.marked_for_death ) && self.marked_for_death )
        return;

    if ( isdefined( self.a.gib_ref ) )
    {
        if ( self.a.gib_ref == "no_legs" || self.a.gib_ref == "no_arms" || ( self.a.gib_ref == "left_leg" || self.a.gib_ref == "right_leg" ) && randomint( 100 ) > 25 || ( self.a.gib_ref == "left_arm" || self.a.gib_ref == "right_arm" ) && randomint( 100 ) > 75 )
            animation_duration = "_late";
        else if ( randomint( 100 ) > 75 )
            animation_duration = "_early";
    }
    else if ( randomint( 100 ) > 25 )
        animation_duration = "_early";

    self setanimstatefromasd( "zm_punch_getup_" + animation_side + animation_duration );
    self maps\mp\animscripts\zm_shared::donotetracks( "punch_getup_anim" );
    self.allowpain = 1;
    self notify( "back_up" );
}

knockdown_zombie_animate_state()
{
    self endon( "death" );
    self.is_knocked_down = 1;
    self waittill_any( "damage", "back_up" );
    self.is_knocked_down = 0;
}
