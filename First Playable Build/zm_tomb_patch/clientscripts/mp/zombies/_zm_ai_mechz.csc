// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_utility;

precache()
{

}

#using_animtree("mechz_claw");

init_animtree()
{
    scriptmodelsuseanimtree( #animtree );
}

add_fx_element( index, fx_element, tag_name, min_freq, max_freq )
{
    if ( !isdefined( level.mechz_clientside_fx ) )
        level.mechz_clientside_fx = [];

    if ( !isdefined( level.mechz_clientside_fx_inst ) )
        level.mechz_clientside_fx_inst = [];

    if ( !isdefined( level.mechz_clientside_fx[index] ) )
        level.mechz_clientside_fx[index] = [];

    if ( !isdefined( level.mechz_clientside_fx_inst[index] ) )
        level.mechz_clientside_fx_inst[index] = [];

    new_fx_struct = spawnstruct();
    new_fx_struct.fx_element = loadfx( fx_element );
    new_fx_struct.tag_name = tag_name;
    new_fx_struct.min_freq = min_freq;
    new_fx_struct.max_freq = max_freq;
    curr_size = level.mechz_clientside_fx[index].size;
    level.mechz_clientside_fx[index][curr_size] = new_fx_struct;
}

init()
{
    registerclientfield( "actor", "mechz_fx", 14000, 12, "int", ::mechz_handle_fx );
    add_fx_element( 0, "maps/zombie_tomb/fx_tomb_mech_dmg_armor", "J_Knee_Attach_LE" );
    add_fx_element( 0, "maps/zombie_tomb/fx_tomb_mech_dmg_sparks", "J_Knee_Attach_LE", 0.25, 0.75 );
    add_fx_element( 0, "maps/zombie_tomb/fx_tomb_mech_dmg_steam", "J_Knee_Attach_LE", 0.1, 0.3 );
    add_fx_element( 1, "maps/zombie_tomb/fx_tomb_mech_dmg_armor", "J_Knee_Attach_RI" );
    add_fx_element( 1, "maps/zombie_tomb/fx_tomb_mech_dmg_sparks", "J_Knee_Attach_RI", 0.25, 0.75 );
    add_fx_element( 1, "maps/zombie_tomb/fx_tomb_mech_dmg_steam", "J_Knee_Attach_RI", 0.1, 0.3 );
    add_fx_element( 2, "maps/zombie_tomb/fx_tomb_mech_dmg_armor", "J_ShoulderArmor_LE" );
    add_fx_element( 2, "maps/zombie_tomb/fx_tomb_mech_dmg_sparks", "J_ShoulderArmor_LE", 0.25, 0.75 );
    add_fx_element( 2, "maps/zombie_tomb/fx_tomb_mech_dmg_steam", "J_ShoulderArmor_LE", 0.1, 0.3 );
    add_fx_element( 3, "maps/zombie_tomb/fx_tomb_mech_dmg_armor", "J_ShoulderArmor_RI" );
    add_fx_element( 3, "maps/zombie_tomb/fx_tomb_mech_dmg_sparks", "J_ShoulderArmor_RI", 0.25, 0.75 );
    add_fx_element( 3, "maps/zombie_tomb/fx_tomb_mech_dmg_steam", "J_ShoulderArmor_RI", 0.1, 0.3 );
    add_fx_element( 4, "maps/zombie_tomb/fx_tomb_mech_dmg_sparks", "J_Root_Attach_Right", 0.25, 0.75 );
    add_fx_element( 4, "maps/zombie_tomb/fx_tomb_mech_dmg_steam", "J_Root_Attach_Right", 0.1, 0.3 );
    add_fx_element( 5, "maps/zombie_tomb/fx_tomb_mech_dmg_sparks", "J_Root_Attach_Left", 0.25, 0.75 );
    add_fx_element( 5, "maps/zombie_tomb/fx_tomb_mech_dmg_steam", "J_Root_Attach_Left", 0.1, 0.3 );
    add_fx_element( 6, "maps/zombie_tomb/fx_tomb_mech_wpn_flamethrower", "tag_flamethrower_FX", 0.25 );
    add_fx_element( 7, "maps/zombie_tomb/fx_tomb_mech_jump_booster", "tag_booster_LE_FX", 0.25 );
    add_fx_element( 7, "maps/zombie_tomb/fx_tomb_mech_jump_booster", "tag_booster_RI_FX", 0.25 );
    add_fx_element( 7, "maps/zombie_tomb/fx_tomb_mech_jump_booster_sm", "tag_leg_booster_LE_FX", 0.25 );
    add_fx_element( 7, "maps/zombie_tomb/fx_tomb_mech_jump_booster_sm", "tag_leg_booster_RI_FX", 0.25 );
    add_fx_element( 8, "maps/zombie_tomb/fx_tomb_mech_wpn_source", "tag_claw", 0.5 );
    add_fx_element( 9, "maps/zombie_tomb/fx_tomb_mech_jump_landing", "tag_origin" );
    add_fx_element( 10, "maps/zombie_tomb/fx_tomb_mech_dmg_armor_face", "J_Helmet" );
    add_fx_element( 11, "maps/zombie_tomb/fx_tomb_mech_exhaust_smoke", "tag_back_exhaust_FX" );
    registerclientfield( "toplayer", "mechz_grab", 14000, 1, "int", ::mechz_claw_callback );
    registermechzfootstepcb( "zm_tomb_mech_zombie", ::mechzfootstepcbfunc );
    init_animtree();
}

setup_fx( localclientnum, index, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    for ( i = 0; i < level.mechz_clientside_fx[index].size; i++ )
    {
        fx_struct = level.mechz_clientside_fx[index][i];
        unique_script_id = "kill_fx_" + index + "_" + self getentitynumber();

        if ( isdefined( fx_struct.min_freq ) )
        {
            self thread mechz_do_manual_looping_fx( localclientnum, unique_script_id, fx_struct.tag_name, fx_struct.fx_element, fx_struct.min_freq, fx_struct.max_freq );
            continue;
        }

        self thread mechz_do_auto_looping_fx( localclientnum, index, fx_struct.tag_name, fx_struct.fx_element );
    }
}

cleanup_fx( localclientnum, index, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    unique_script_id = "kill_fx_" + index + "_" + self getentitynumber();
    fx_array = level.mechz_clientside_fx_inst[index];

    if ( isdefined( fx_array ) && fx_array.size > 0 )
    {
        for ( i = fx_array.size - 1; i >= 0; i-- )
        {
            stopfx( localclientnum, fx_array[i] );
            fx_array[i] = undefined;
        }
    }

    self notify( unique_script_id );
}

mechz_handle_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    for ( i = 0; i < level.mechz_clientside_fx.size; i++ )
    {
        set_in_new = ( newval & 1 << i ) != 0;
        set_in_old = ( oldval & 1 << i ) != 0;

        if ( set_in_new && !set_in_old )
        {
            self thread setup_fx( localclientnum, i, bnewent, binitialsnap, fieldname, bwasdemojump );
            continue;
        }

        if ( !set_in_new && set_in_old )
            self thread cleanup_fx( localclientnum, i, bnewent, binitialsnap, fieldname, bwasdemojump );
    }
}

mechz_do_manual_looping_fx( localclientnum, script_id, tag_name, fx_element, min_wait, max_wait )
{
    self endon( script_id );
    self endon( "death" );

    if ( !isdefined( min_wait ) )
    {
        playfxontag( localclientnum, fx_element, self, tag_name );
        return;
    }

    if ( !isdefined( max_wait ) )
        max_wait = min_wait;

    while ( true )
    {
        if ( !isdefined( self ) )
            return;

        playfxontag( localclientnum, fx_element, self, tag_name );
        waitrealtime( randomfloatrange( min_wait, max_wait ) );
    }
}

mechz_do_auto_looping_fx( localclientnum, index, tag_name, fx_element )
{
    curr_size = level.mechz_clientside_fx_inst[index].size;
    level.mechz_clientside_fx_inst[index][curr_size] = playfxontag( localclientnum, fx_element, self, tag_name );
}

mechz_screen_shake_loop( localclientnum )
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "kill_screen_shake" );

    while ( true )
    {
        self earthquake( 0.25, 0.2, self.origin, 150 );
        self playrumbleonentity( localclientnum, "mechz_footsteps" );
        waitrealtime( 0.1 );
    }
}

mechz_claw_callback( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( oldval == 1 && newval == 0 )
    {
        self stoprumble( localclientnum, "mechz_footsteps" );
        self notify( "kill_screen_shake" );
    }
    else if ( newval == 1 )
        self thread mechz_screen_shake_loop( localclientnum );
}

mechzfootstepcbfunc( localclientnum, pos, surface, notetrack, bone )
{
    players = getlocalplayers();

    for ( i = 0; i < players.size; i++ )
    {
        if ( abs( self.origin[2] - players[i].origin[2] ) < 100 )
        {
            players[i] earthquake( 0.5, 0.1, self.origin, 1500 );

            if ( !players[i] isplayer() )
                continue;

            playerlocalclientnum = players[i] getlocalclientnumber();

            if ( isdefined( playerlocalclientnum ) )
                playrumbleonposition( playerlocalclientnum, "mechz_footsteps", self.origin );
        }
    }

    footstepdoeverything();
}

registermechzfootstepcb( aitype, func )
{
    if ( !isdefined( level._footstepcbfuncs ) )
        level._footstepcbfuncs = [];

    if ( isdefined( level._footstepcbfuncs[aitype] ) )
    {
/#
        println( "Attempting to register footstep callback function for ai type " + aitype + " multiple times." );
#/
        return;
    }

    level._footstepcbfuncs[aitype] = func;
}
