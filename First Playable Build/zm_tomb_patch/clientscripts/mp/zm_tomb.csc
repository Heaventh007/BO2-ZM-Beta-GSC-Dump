// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\zombies\_zm_weapons;
#include clientscripts\mp\zombies\_zm_utility;
#include clientscripts\mp\_filter;
#include clientscripts\mp\zombies\_zm_perk_electric_cherry;
#include clientscripts\mp\zombies\_zm_perk_divetonuke;
#include clientscripts\mp\zm_tomb_tank;
#include clientscripts\mp\zm_tomb_giant_robot;
#include clientscripts\mp\zm_tomb_quest_fire;
#include clientscripts\mp\zm_tomb_capture_zones;
#include clientscripts\mp\zombies\_zm_ai_mechz;
#include clientscripts\mp\zombies\_zm_perk_oneinch_punch;
#include clientscripts\mp\zombies\_zm_perk_random;
#include clientscripts\mp\zombies\_zm_challenges;
#include clientscripts\mp\zm_tomb_dig;
#include clientscripts\mp\zm_tomb_fx;
#include clientscripts\mp\zm_tomb_amb;
#include clientscripts\mp\zm_tomb_classic;
#include clientscripts\mp\zombies\_zm;
#include clientscripts\mp\_sticky_grenade;
#include clientscripts\mp\zombies\_zm_weap_beacon;
#include clientscripts\mp\zombies\_zm_weap_riotshield_prison;
#include clientscripts\mp\zombies\_zm_weap_staff_air;
#include clientscripts\mp\zombies\_zm_weap_staff_fire;
#include clientscripts\mp\zombies\_zm_weap_staff_lightning;
#include clientscripts\mp\zombies\_zm_weap_staff_water;
#include clientscripts\mp\zombies\_zm_weap_cymbal_monkey;
#include clientscripts\mp\zombies\_zm_magicbox_tomb;
#include clientscripts\mp\zombies\_zm_powerup_zombie_blood;
#include clientscripts\mp\_visionset_mgr;
#include clientscripts\mp\zombies\_zm_equipment;
#include clientscripts\mp\zombies\_zm_ai_quadrotor;

main()
{
    level._effect["air_glow"] = loadfx( "maps/zombie_tomb/fx_tomb_elem_reveal_air_glow" );
    level._effect["elec_glow"] = loadfx( "maps/zombie_tomb/fx_tomb_elem_reveal_elec_glow" );
    level._effect["fire_glow"] = loadfx( "maps/zombie_tomb/fx_tomb_elem_reveal_fire_glow" );
    level._effect["ice_glow"] = loadfx( "maps/zombie_tomb/fx_tomb_elem_reveal_ice_glow" );
    level._effect["teleport_1p"] = loadfx( "maps/zombie_tomb/fx_tomb_teleport_1p" );
    registerclientfield( "world", "pillbox_turret_anim", 14000, 1, "int", ::play_pillbox_turret_anim, 0 );
    n_bits = getminbitcountfornum( 15 );
    registerclientfield( "world", "packapunch_anim", 14000, n_bits, "int", ::play_pap_anim, 0 );
    registerclientfield( "scriptmover", "generator_damage", 14000, 1, "int", ::damage_generator_fx, 0 );
    registerclientfield( "toplayer", "mud_overlay", 14000, 1, "int", ::do_mud_overlay, 0 );
    registerclientfield( "scriptmover", "crystal_air_fx", 14000, 1, "int", ::crystal_air_fx, 0 );
    registerclientfield( "scriptmover", "crystal_fire_fx", 14000, 1, "int", ::crystal_fire_fx, 0 );
    registerclientfield( "scriptmover", "crystal_lightning_fx", 14000, 1, "int", ::crystal_lightning_fx, 0 );
    registerclientfield( "scriptmover", "crystal_water_fx", 14000, 1, "int", ::crystal_water_fx, 0 );
    registerclientfield( "toplayer", "teleporter_fx", 14000, 1, "int", ::teleporter_fx_play, 0 );
    registerclientfield( "toplayer", "player_rumble_and_shake", 14000, 3, "int", ::player_rumble_and_shake, 0 );
    registerclientfield( "toplayer", "player_rain_level", 14000, 3, "int", ::set_player_rain, 0 );
    registerclientfield( "toplayer", "player_snow_level", 14000, 3, "int", ::set_player_snow, 0 );
    registerclientfield( "toplayer", "player_fog_level", 14000, 1, "int", ::set_player_fog, 0 );
    registerclientfield( "scriptmover", "sky_pillar", 14000, 2, "int", ::sky_pillar_fx, 0 );
    level.default_start_location = "tomb";
    level.default_game_mode = "zclassic";
    level._no_water_risers = 0;
    level.use_new_riser_water = 1;
    level.zombiemode_using_juggernaut_perk = 1;
    level.zombiemode_using_revive_perk = 1;
    level.zombiemode_using_sleightofhand_perk = 1;
    level.zombiemode_using_additionalprimaryweapon_perk = 1;
    level.zombiemode_using_marathon_perk = 1;
    level.zombiemode_using_deadshot_perk = 1;
    level.zombiemode_using_doubletap_perk = 1;
    level.zombiemode_using_random_perk = 1;
    clientscripts\mp\zombies\_zm_perk_electric_cherry::enable_electric_cherry_perk_for_level();
    level.zombiemode_using_additionalprimaryweapon_perk = 1;
    level.zombiemode_using_divetonuke_perk = 1;
    clientscripts\mp\zombies\_zm_perk_divetonuke::enable_divetonuke_perk_for_level();
    level.onplayerconnect = ::player_init_mud_shader;
    clientscripts\mp\zm_tomb_tank::init();
    clientscripts\mp\zm_tomb_giant_robot::init();
    clientscripts\mp\zm_tomb_quest_fire::init_animtree();
    clientscripts\mp\zm_tomb_capture_zones::init_cz_animtree();
    clientscripts\mp\zombies\_zm_ai_mechz::precache();
    clientscripts\mp\zombies\_zm_perk_oneinch_punch::enable_oneinch_punch_perk_for_level();
    clientscripts\mp\zombies\_zm_perk_random::init();
    start_zombie_stuff();
    init_gamemodes();
    clientscripts\mp\zombies\_zm_ai_mechz::init();
    clientscripts\mp\zombies\_zm_challenges::init();
    clientscripts\mp\zombies\_zm_perk_random::init_animtree();
    clientscripts\mp\zm_tomb_dig::init();
    clientscripts\mp\zm_tomb_fx::main();
    thread clientscripts\mp\zm_tomb_amb::main();
    level._entityspawned_override = ::entityspawned_tomb;
    zombe_gametype_premain();
    a_s_generator = getstructarray( "s_generator", "targetname" );

    foreach ( struct in a_s_generator )
        registerclientfield( "world", struct.script_noteworthy, 14000, 4, "int", ::generator_capture_anim, 0 );

    waitforclient( 0 );
    level thread clientscripts\mp\zm_tomb_fx::setup_prop_anims();
    level thread init_fog_vol_to_visionset();
    level thread init_capture_generators();
    level thread init_traps();
    level thread init_custom_pap();
}

#using_animtree("fxanim_props_dlc4");

init_traps()
{
    waitforallclients();
    a_players = getlocalplayers();

    for ( localclientnum = 0; localclientnum < a_players.size; localclientnum++ )
    {
        e_turret = getent( localclientnum, "pillbox_cs", "targetname" );
        e_turret waittill_dobj( localclientnum );
        e_turret useanimtree( #animtree );
        e_turret setanim( %fxanim_zom_tomb_turret_deactivate_anim, 1.0, 0.1, 1 );
        e_turret setanimtime( %fxanim_zom_tomb_turret_deactivate_anim, 1 );
    }
}

init_custom_pap()
{
    waitforallclients();
    a_players = getlocalplayers();

    for ( localclientnum = 0; localclientnum < a_players.size; localclientnum++ )
    {
        e_custom_pap = getent( localclientnum, "pap_cs", "targetname" );
        e_custom_pap waittill_dobj( localclientnum );
        e_custom_pap useanimtree( #animtree );
    }
}

player_init_mud_shader( localclientnum )
{
    player = getlocalplayer( localclientnum );
    clientscripts\mp\_filter::init_filter_indices();
    player map_material_helper( player, "generic_filter_mud_splats" );
    enable_filter_mud_splats( player, 2, 1, 0 );
}

init_capture_generators()
{
    waitforallclients();
    a_s_generator = getstructarray( "s_generator", "targetname" );
    a_players = getlocalplayers();

    for ( localclientnum = 0; localclientnum < a_players.size; localclientnum++ )
    {
        foreach ( struct in a_s_generator )
        {
            struct.m_generator = getent( localclientnum, struct.script_noteworthy, "targetname" );
            struct.m_generator waittill_dobj( localclientnum );
            struct.m_generator thread monitor_movement( localclientnum );
        }
    }
}

monitor_movement( localclientnum )
{
    self useanimtree( #animtree );
    self.n_next_progress = 0;
    self.n_current_progress = 0;
    self.n_movement_rate = 0;
    self.b_generator_active = 0;
    self thread monitor_engine( localclientnum );
    n_last_time = getrealtime();
    wait 0.1;

    while ( true )
    {
        n_interval = ( getrealtime() - n_last_time ) / 1000;
        self.n_next_progress = self.n_next_progress + self.n_movement_rate / 100 * n_interval;

        if ( self.n_next_progress < 0 )
            self.n_next_progress = 0;

        if ( self.n_next_progress >= 1 )
            self.n_next_progress = 1;

        self clearanim( %fxanim_zom_tomb_generator_fluid_up_anim, 0 );
        self clearanim( %fxanim_zom_tomb_generator_fluid_down_anim, 0 );
        self setanim( %fxanim_zom_tomb_generator_fluid_up_anim, self.n_next_progress, 0.1, 1 );
        self setanim( %fxanim_zom_tomb_generator_fluid_down_anim, 1 - self.n_next_progress, 0.1, 1 );
        self.n_current_progress = self.n_next_progress;
        n_last_time = getrealtime();
        wait 0.0167;
    }
}

monitor_engine( localclientnum )
{
    b_tesla_started = 0;
    self.b_machine_active = 0;
    fx_donut_id = undefined;

    while ( true )
    {
        if ( self.n_movement_rate > 0 )
        {
            if ( !b_tesla_started )
            {
                b_tesla_started = 1;
                fx_donut_id[localclientnum] = playfxontag( localclientnum, level._effect["capture_progression"], self, "j_generator_pole" );
            }

            if ( !self.b_generator_active )
            {
                n_anim_length = getanimlength( %fxanim_zom_tomb_generator_start_anim );
                self setanim( %fxanim_zom_tomb_generator_start_anim, 1.0, 0.1, 1 );
                wait( n_anim_length );
                self clearanim( %fxanim_zom_tomb_generator_start_anim, 0 );
                self.b_generator_active = 1;
            }

            self clearanim( %fxanim_zom_tomb_generator_down_idle_anim, 0 );
            self setanim( %fxanim_zom_tomb_generator_up_idle_anim, 1.0, 0.1, 1 );

            while ( self.n_movement_rate > 0 )
                wait 0.05;

            if ( self.n_current_progress >= 1 )
            {
                while ( self.n_movement_rate <= 0 )
                    wait 0.05;
            }
        }
        else if ( self.n_movement_rate < 0 )
        {
            if ( !self.b_generator_active )
            {
                wait 0.05;
                continue;
            }

            self clearanim( %fxanim_zom_tomb_generator_up_idle_anim, 0 );
            self setanim( %fxanim_zom_tomb_generator_down_idle_anim, 1.0, 0.1, 1 );

            while ( self.n_movement_rate <= 0 && self.n_current_progress > 0 )
                wait 0.05;

            if ( self.n_current_progress <= 0 )
            {
                if ( isdefined( fx_donut_id ) )
                {
                    if ( isdefined( fx_donut_id[localclientnum] ) )
                        stopfx( localclientnum, fx_donut_id[localclientnum] );

                    fx_donut_id = undefined;
                }

                b_tesla_started = 0;
                self clearanim( %fxanim_zom_tomb_generator_down_idle_anim, 0 );
                n_anim_length = getanimlength( %fxanim_zom_tomb_generator_end_anim );
                self setanim( %fxanim_zom_tomb_generator_end_anim, 1.0, 0.1, 1 );
                wait( n_anim_length );
                self.b_generator_active = 0;

                while ( self.n_current_progress <= 0 )
                    wait 0.05;
            }
        }

        wait 0.05;
    }
}

generator_capture_anim( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    m_generator = getent( localclientnum, fieldname, "targetname" );
    m_generator.n_movement_rate = newval - 5;
}

init_gamemodes()
{
    add_map_gamemode( "zclassic", undefined, undefined );
    add_map_location_gamemode( "zclassic", "tomb", clientscripts\mp\zm_tomb_classic::precache, clientscripts\mp\zm_tomb_classic::premain, clientscripts\mp\zm_tomb_classic::main );
}

start_zombie_stuff()
{
    include_weapons();
    include_powerups();
    include_equipment_for_level();
    clientscripts\mp\zombies\_zm::init();
    level thread clientscripts\mp\_sticky_grenade::main();
    clientscripts\mp\zombies\_zm_weap_beacon::init();
    clientscripts\mp\zombies\_zm_weap_riotshield_prison::init();
    clientscripts\mp\zombies\_zm_weap_staff_air::init();
    clientscripts\mp\zombies\_zm_weap_staff_fire::init();
    clientscripts\mp\zombies\_zm_weap_staff_lightning::init();
    clientscripts\mp\zombies\_zm_weap_staff_water::init();
    clientscripts\mp\zombies\_zm_weap_cymbal_monkey::init();
    clientscripts\mp\zombies\_zm_magicbox_tomb::init();
    clientscripts\mp\zombies\_zm_powerup_zombie_blood::init();
    clientscripts\mp\_visionset_mgr::vsmgr_register_overlay_info_style_burn( "zm_transit_burn", 14000, 15, 2 );
    clientscripts\mp\_visionset_mgr::vsmgr_register_visionset_info( "zm_prison", 14000, 1, "default", "default" );
    clientscripts\mp\_visionset_mgr::vsmgr_register_overlay_info_style_filter( "zm_tomb_mud_filter", 14000, 1, 2, 0, "generic_filter_mud_splats" );
}

set_filter_mud_splats_amount( player, filterid, amount )
{
    player set_filter_pass_constant( filterid, 0, 0, amount );
}

set_filter_mud_splats_count( player, filterid, count )
{
    player set_filter_pass_constant( filterid, 0, 1, count );
}

set_filter_mud_splats_coverage( player, filterid, coverage )
{
    player set_filter_pass_constant( filterid, 0, 2, coverage );
}

set_filter_mud_splats_life( player, filterid, life )
{
    player set_filter_pass_constant( filterid, 0, 3, life );
}

set_filter_mud_splats_sun( player, filterid, sunx, suny )
{
    player set_filter_pass_constant( filterid, 0, 4, sunx );
    player set_filter_pass_constant( filterid, 0, 5, suny );
}

enable_filter_mud_splats( player, filterid, amount, count )
{
    player set_filter_pass_material( filterid, 0, level.filter_matid["generic_filter_mud_splats"] );
    player set_filter_pass_enabled( filterid, 0, 1 );
    player set_filter_pass_quads( filterid, 0, 60 );
    set_filter_mud_splats_amount( player, filterid, amount );
    set_filter_mud_splats_count( player, filterid, count );
    set_filter_mud_splats_coverage( player, filterid, 1 );
    set_filter_mud_splats_life( player, filterid, 1 );
    set_filter_mud_splats_sun( player, filterid, 0, 0 );
}

disable_filter_mud_splats( player, filterid )
{
    player set_filter_pass_enabled( filterid, 0, 0 );
}

include_equipment_for_level()
{
    clientscripts\mp\zombies\_zm_equipment::include_equipment( "equip_dieseldrone_zm" );
    clientscripts\mp\zombies\_zm_equipment::include_equipment( "alcatraz_shield_zm" );
}

init_fog_vol_to_visionset()
{
    init_fog_vol_to_visionset_monitor( "zm_tomb", 1 );
    fog_vol_to_visionset_set_suffix( "" );
    fog_vol_to_visionset_set_info( 0, "zm_tomb" );
}

init_clientflag_variables()
{

}

register_clientflag_callbacks()
{

}

include_weapons()
{
    include_weapon( "hamr_zm" );
    include_weapon( "hamr_upgraded_zm", 0 );
    include_weapon( "lsat_zm" );
    include_weapon( "lsat_upgraded_zm", 0 );
    include_weapon( "galil_zm" );
    include_weapon( "galil_upgraded_zm", 0 );
    include_weapon( "hk416_zm" );
    include_weapon( "hk416_upgraded_zm", 0 );
    include_weapon( "m14_zm", 0 );
    include_weapon( "m14_upgraded_zm", 0 );
    include_weapon( "mp44_zm", 0 );
    include_weapon( "mp44_upgraded_zm", 0 );
    include_weapon( "scar_zm" );
    include_weapon( "scar_upgraded_zm", 0 );
    include_weapon( "870mcs_zm", 0 );
    include_weapon( "870mcs_upgraded_zm", 0 );
    include_weapon( "ksg_zm", 0 );
    include_weapon( "ksg_upgraded_zm", 0 );
    include_weapon( "saiga12_zm" );
    include_weapon( "saiga12_upgraded_zm", 0 );
    include_weapon( "srm1216_zm" );
    include_weapon( "srm1216_upgraded_zm", 0 );
    include_weapon( "ak74u_zm" );
    include_weapon( "ak74u_upgraded_zm", 0 );
    include_weapon( "mp40_zm", 0 );
    include_weapon( "mp40_upgraded_zm", 0 );
    include_weapon( "uzi_zm" );
    include_weapon( "uzi_upgraded_zm", 0 );
    include_weapon( "evoskorpion_zm" );
    include_weapon( "evoskorpion_upgraded_zm", 0 );
    include_weapon( "ballista_zm", 0 );
    include_weapon( "ballista_upgraded_zm", 0 );
    include_weapon( "dsr50_zm" );
    include_weapon( "dsr50_upgraded_zm", 0 );
    include_weapon( "beretta93r_zm", 0 );
    include_weapon( "beretta93r_upgraded_zm", 0 );
    include_weapon( "fiveseven_zm", 0 );
    include_weapon( "fiveseven_upgraded_zm", 0 );
    include_weapon( "python_zm" );
    include_weapon( "python_upgraded_zm", 0 );
    include_weapon( "c96_zm", 0 );
    include_weapon( "c96_upgraded_zm", 0 );
    include_weapon( "fivesevendw_zm" );
    include_weapon( "fivesevendw_upgraded_zm", 0 );
    include_weapon( "beacon_zm", 0 );
    include_weapon( "alcatraz_shield_zm", 0 );
    include_weapon( "claymore_zm", 0 );
    include_weapon( "cymbal_monkey_zm" );
    include_weapon( "frag_grenade_zm", 0 );
    include_weapon( "knife_zm", 0 );
    include_weapon( "ray_gun_zm" );
    include_weapon( "ray_gun_upgraded_zm", 0 );
    include_weapon( "raygun_mark2_zm", hasdlcavailable( "dlc3" ) );
    include_weapon( "raygun_mark2_upgraded_zm", 0 );
    include_weapon( "sticky_grenade_zm", 0 );
    include_weapon( "usrpg_zm" );
    include_weapon( "usrpg_upgraded_zm", 0 );
    include_weapon( "staff_air_zm", 0 );
    include_weapon( "staff_air_upgraded_zm", 0 );
    include_weapon( "staff_fire_zm", 0 );
    include_weapon( "staff_fire_upgraded_zm", 0 );
    include_weapon( "staff_lightning_zm", 0 );
    include_weapon( "staff_lightning_upgraded_zm", 0 );
    include_weapon( "staff_water_zm", 0 );
    include_weapon( "staff_water_zm_cheap", 0 );
    include_weapon( "staff_water_upgraded_zm", 0 );
    include_weapon( "staff_revive_zm", 0 );
}

include_powerups()
{
    include_powerup( "nuke" );
    include_powerup( "insta_kill" );
    include_powerup( "double_points" );
    include_powerup( "full_ammo" );
    include_powerup( "fire_sale" );
    include_powerup( "free_perk" );
    include_powerup( "zombie_blood" );
    include_powerup( "bonus_points_player" );
    include_powerup( "bonus_points_team" );
}

entityspawned_tomb( localclientnum )
{
    if ( !isdefined( self.type ) )
    {
/#
        println( "Entity type undefined!" );
#/
        return;
    }

    if ( self.type == "player" )
        self thread playerspawned( localclientnum );

    if ( self.type == "vehicle" )
    {
        if ( self.vehicletype == "heli_quadrotor_zm" )
            self thread clientscripts\mp\zombies\_zm_ai_quadrotor::spawned( localclientnum );
    }
}

crystal_air_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
        level.fx_air = playfxontag( localclientnum, level._effect["air_glow"], self, "tag_origin" );
    else
        stopfx( localclientnum, level.fx_air );
}

crystal_fire_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
        level.fx_fire = playfxontag( localclientnum, level._effect["fire_glow"], self, "tag_origin" );
    else
        stopfx( localclientnum, level.fx_fire );
}

crystal_lightning_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
        level.fx_light = playfxontag( localclientnum, level._effect["elec_glow"], self, "tag_origin" );
    else
        stopfx( localclientnum, level.fx_light );
}

crystal_water_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval )
        level.fx_water = playfxontag( localclientnum, level._effect["ice_glow"], self, "tag_origin" );
    else
        stopfx( localclientnum, level.fx_water );
}

teleporter_fx_play( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "disconnect" );

    if ( newval == 1 )
    {
        v_fx_pos = self.origin + vectorscale( ( 0, 0, 1 ), 64.0 ) + anglestoforward( self.angles ) * 60;
        self.e_fx = spawn( localclientnum, v_fx_pos, "script_model" );
        self.e_fx setmodel( "tag_origin" );
        self.fx_teleport = playfxontag( localclientnum, level._effect["teleport_1p"], self.e_fx, "tag_origin" );
    }
    else
    {
        if ( isdefined( self.fx_teleport ) )
            stopfx( localclientnum, self.fx_teleport );

        if ( isdefined( self.e_fx ) )
            self.e_fx delete();
    }
}

sky_pillar_fade( localclientnum, fade_in, fade_time )
{
    self notify( "sky_pillar_fade_stop" );
    self endon( "sky_pillar_fade_stop" );
    self endon( "death" );
    start_val = 0.0;
    end_val = 1.0;

    if ( fade_in )
    {
        start_val = 1.0;
        end_val = 0.0;
    }

    frame_time = 0.0166;
    num_steps = int( fade_time / frame_time );
    step_size = 1.0 / num_steps;

    for ( i = 0; i < num_steps; i++ )
    {
        pct = step_size * i;

        if ( pct < 0.0 )
            pct = 0.0;
        else if ( pct > 1.0 )
            pct = 1.0;

        value = lerpfloat( start_val, end_val, pct );
        self setshaderconstant( localclientnum, 0, value, value, value, value );
        wait( frame_time );
    }
}

sky_pillar_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
    {
        self mapshaderconstant( localclientnum, 0, "ScriptVector0" );
        self thread sky_pillar_fade( localclientnum, 1, 4.0 );
/#
        println( "Sky Pillar Fading In" );
#/
    }
    else if ( newval == 0 )
    {
        self thread sky_pillar_fade( localclientnum, 0, 4.0 );
/#
        println( "Sky Pillar Fading Out" );
#/
    }
    else if ( newval == 2 )
        self notify( "sky_pillar_fade_stop" );
}

player_rumble_and_shake( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self endon( "disconnect" );

    if ( newval == 4 )
        self thread player_generator_rumble( localclientnum );
    else if ( newval == 3 )
    {
        self earthquake( 0.6, 1.5, self.origin, 100 );
        self playrumbleonentity( localclientnum, "artillery_rumble" );
    }
    else if ( newval == 2 )
    {
        self earthquake( 0.3, 1.5, self.origin, 100 );
        self playrumbleonentity( localclientnum, "shotgun_fire" );
    }
    else if ( newval == 1 )
    {
        self earthquake( 0.1, 1.0, self.origin, 100 );
        self playrumbleonentity( localclientnum, "damage_heavy" );
    }
    else
        self notify( "stop_generator_rumble" );
}

player_generator_rumble( localclientnum )
{
    self endon( "disconnect" );
    self endon( "stop_generator_rumble" );

    while ( true )
    {
        if ( isdefined( self ) && self islocalplayer() && isdefined( self ) )
            self playrumbleonentity( localclientnum, "damage_light" );

        wait 0.25;
    }
}

do_mud_overlay( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    self notify( "do_mud_overlay" );
    self endon( "do_mud_overlay" );
    self endon( "death" );

    if ( !isdefined( self.mud_count ) )
        self.mud_count = 0;

    if ( newval == 1 )
    {
        while ( true )
        {
            self.mud_count = self.mud_count + 0.05;

            if ( self.mud_count > 0.7 )
                self.mud_count = 0.7;

            set_filter_mud_splats_count( self, 2, self.mud_count );
            wait 0.05;
        }
    }
    else
    {
        while ( true )
        {
            self.mud_count = self.mud_count - 0.05;

            if ( self.mud_count <= 0 )
            {
                set_filter_mud_splats_count( self, 2, 0 );
                break;
            }

            set_filter_mud_splats_count( self, 2, self.mud_count );
            wait 0.05;
        }
    }
}

play_pap_anim( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    switch ( newval )
    {
        case 1:
            anim_pap = %fxanim_zom_tomb_packapunch_pc1_anim;
            anim_clear = %fxanim_zom_tomb_pack_return_pc1_anim;
            break;
        case 2:
            anim_pap = %fxanim_zom_tomb_packapunch_pc2_anim;
            anim_clear = %fxanim_zom_tomb_pack_return_pc2_anim;
            break;
        case 3:
            anim_pap = %fxanim_zom_tomb_packapunch_pc3_anim;
            anim_clear = %fxanim_zom_tomb_pack_return_pc3_anim;
            break;
        case 4:
            anim_pap = %fxanim_zom_tomb_packapunch_pc4_anim;
            anim_clear = %fxanim_zom_tomb_pack_return_pc4_anim;
            break;
        case 5:
            anim_pap = %fxanim_zom_tomb_packapunch_pc5_anim;
            anim_clear = %fxanim_zom_tomb_pack_return_pc5_anim;
            break;
        case 6:
            anim_pap = %fxanim_zom_tomb_packapunch_pc6_anim;
            anim_clear = %fxanim_zom_tomb_pack_return_pc6_anim;
            break;
        case 7:
            anim_pap = %fxanim_zom_tomb_packapunch_pc7_anim;
            anim_clear = %fxanim_zom_tomb_pack_return_pc7_anim;
            break;
        case 8:
            anim_pap = %fxanim_zom_tomb_pack_return_pc1_anim;
            anim_clear = %fxanim_zom_tomb_packapunch_pc1_anim;
            break;
        case 9:
            anim_pap = %fxanim_zom_tomb_pack_return_pc2_anim;
            anim_clear = %fxanim_zom_tomb_packapunch_pc2_anim;
            break;
        case 10:
            anim_pap = %fxanim_zom_tomb_pack_return_pc3_anim;
            anim_clear = %fxanim_zom_tomb_packapunch_pc3_anim;
            break;
        case 11:
            anim_pap = %fxanim_zom_tomb_pack_return_pc4_anim;
            anim_clear = %fxanim_zom_tomb_packapunch_pc4_anim;
            break;
        case 12:
            anim_pap = %fxanim_zom_tomb_pack_return_pc5_anim;
            anim_clear = %fxanim_zom_tomb_packapunch_pc5_anim;
            break;
        case 13:
            anim_pap = %fxanim_zom_tomb_pack_return_pc6_anim;
            anim_clear = %fxanim_zom_tomb_packapunch_pc6_anim;
            break;
        case 14:
            anim_pap = %fxanim_zom_tomb_pack_return_pc7_anim;
            anim_clear = %fxanim_zom_tomb_packapunch_pc7_anim;
            break;
    }

    t_pap = getent( localclientnum, "pap_cs", "targetname" );
    t_pap clearanim( anim_clear, 0 );
    t_pap setanim( anim_pap, 1.0, 0.1, 1 );
}

play_pillbox_turret_anim( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    e_turret = getent( localclientnum, "pillbox_cs", "targetname" );
    e_turret useanimtree( #animtree );

    if ( newval == 1 )
    {
        e_turret setanim( %fxanim_zom_tomb_turret_activate_anim, 1.0, 0.1, 1 );
        n_anim_length = getanimlength( %fxanim_zom_tomb_turret_activate_anim );
        wait( n_anim_length );
        e_turret hide();
    }
    else
    {
        e_turret show();
        e_turret setanim( %fxanim_zom_tomb_turret_deactivate_anim, 1.0, 0.1, 1 );
    }
}

damage_generator_fx( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    a_s_generator = getstructarray( "s_generator", "targetname" );
    a_zone_structs = get_array_of_closest( self.origin, a_s_generator );
    zone_struct = a_zone_structs[0];

    if ( !isdefined( zone_struct ) )
    {
/#
        println( "Capture Zone Struct : Couldn't find closest struct. at " + self.origin );
#/
        return;
    }

    zone_struct.m_generator = getent( localclientnum, zone_struct.script_noteworthy, "targetname" );
    a_generator_tags = [];
    a_generator_tags[0] = "J_piston_01";
    a_generator_tags[1] = "J_piston_02";
    str_random_fx_tag = random( a_generator_tags );

    if ( newval )
        level.generator_damage_fx = playfxontag( localclientnum, level._effect["elec_switch_spark"], zone_struct.m_generator, str_random_fx_tag );
    else
        stopfx( localclientnum, level.generator_damage_fx );
}

set_player_snow( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 0 )
    {
        self notify( "_snow_thread" );
        setworldfogactivebank( localclientnum, 1 );
    }
    else
    {
        self thread _snow_thread( newval, localclientnum );
        setworldfogactivebank( localclientnum, 2 );
    }
}

set_player_rain( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( !isdefined( self.b_lightning ) )
        self.b_lightning = 0;

    if ( newval == 0 )
    {
        self notify( "_rain_thread" );
        self.b_lightning = 0;
    }
    else
    {
        if ( is_false( self.b_lightning ) )
            self thread _lightning_thread( localclientnum );

        self thread _rain_thread( newval, localclientnum );
    }
}

_rain_thread( n_level, localclientnum )
{
    self notify( "_rain_thread" );
    self endon( "_rain_thread" );
    self endon( "disconnect" );
    self endon( "death" );
    n_wait = 0.5 / n_level;

    while ( true )
    {
        if ( !isdefined( self ) )
            return;

        playfx( localclientnum, level._effect["player_rain"], self.origin );
        wait( n_wait );
    }
}

_snow_thread( n_level, localclientnum )
{
    self notify( "_snow_thread" );
    self endon( "_snow_thread" );
    self endon( "disconnect" );
    self endon( "death" );
    n_wait = 0.5 / n_level;

    while ( true )
    {
        if ( !isdefined( self ) )
            return;

        playfx( localclientnum, level._effect["player_snow"], self.origin );
        wait( n_wait );
    }
}

set_player_fog( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
        setworldfogactivebank( localclientnum, 2 );
    else
        setworldfogactivebank( localclientnum, 1 );
}

_lightning_thread( localclientnum )
{
    self endon( "disconnect" );
    self.b_lightning = 1;

    if ( isdefined( localclientnum ) )
    {
        self waittill_dobj( localclientnum );

        while ( is_true( self.b_lightning ) )
        {
            v_p_angles = self.angles;
            v_forward = anglestoforward( self.angles ) * 25000;
            v_end_pos = self.origin + ( v_forward[0], v_forward[1], 0 );
            v_offset = ( randomintrange( -5000, 5000 ), randomintrange( -5000, 5000 ), randomint( 3000 ) );
            v_end_pos = v_end_pos + v_offset;
            playfx( localclientnum, level._effect["lightning_flash"], v_end_pos );
            playsound( 0, "amb_thunder_clap_zm", v_end_pos );
            serverwait( localclientnum, randomfloatrange( 0.2, 0.3 ) );
            n_level_sunlight = getdvarfloat( #"r_lightTweakSunLight" );
            n_level_exposure = getdvarfloat( #"r_exposureValue" );
            n_strikes = randomintrange( 3, 5 );

            for ( i = 0; i < n_strikes; i++ )
            {
                serverwait( localclientnum, 0.1 );
                n_blend_time = randomfloatrange( 0.1, 0.35 );
                setdvar( "r_exposureTweak", 1 );
                playsound( 0, "amb_thunder_flash_zm", v_end_pos );
                setdvar( "r_exposureValue", randomfloatrange( 2.5, 3.0 ) );
                level thread lerp_dvar( "r_exposureValue", n_level_exposure, n_blend_time, undefined, localclientnum );
                setsaveddvar( "r_lightTweakSunLight", randomfloatrange( 28, 32 ) );
                level thread lerp_dvar( "r_lightTweakSunLight", n_level_sunlight, n_blend_time, 1, localclientnum );
                serverwait( localclientnum, n_blend_time );
                setdvar( "r_exposureTweak", 0 );
            }

            serverwait( localclientnum, randomfloatrange( 5.0, 10.0 ) );
        }
    }
}

lerp_dvar( str_dvar, n_val, n_lerp_time, b_saved_dvar, localclientnum )
{
    n_start_val = getdvarfloat( str_dvar );
    n_time_delta = 0;

    do
    {
        serverwait( localclientnum, 0.05 );
        n_time_delta = n_time_delta + 0.05;
        n_curr_val = lerpfloat( n_start_val, n_val, n_time_delta / n_lerp_time );

        if ( is_true( b_saved_dvar ) )
        {
            setsaveddvar( str_dvar, n_curr_val );
            continue;
        }

        setdvar( str_dvar, n_curr_val );
    }
    while (n_time_delta < n_lerp_time );
}
