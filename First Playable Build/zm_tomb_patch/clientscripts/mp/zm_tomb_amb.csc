// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include clientscripts\mp\_utility;
#include clientscripts\mp\_ambientpackage;
#include clientscripts\mp\_music;
#include clientscripts\mp\_audio;
#include clientscripts\mp\zm_tomb_amb;

main()
{
    declareambientroom( "tomb_outdoor", 1 );
    declareambientpackage( "tomb_outdoor" );
    setambientroomreverb( "tomb_outdoor", "socotra_outdoor", 1, 1 );
    setambientroomtone( "tomb_outdoor", "amb_planes_front", 1, 1 );
    setambientroomcontext( "tomb_outdoor", "ringoff_plr", "outdoor" );
    declaremusicstate( "WAVE" );
    musicaliasloop( "mus_theatre_underscore", 4, 2 );
    declaremusicstate( "EGG" );
    musicalias( "mus_egg", 1 );
    declaremusicstate( "SILENCE" );
    musicalias( "null", 1 );
    registerclientfield( "toplayer", "sndMudSlow", 14000, 1, "int", clientscripts\mp\zm_tomb_amb::sndmudslow );
    level thread sndstartambience();
    level thread flyovers();
}

sndstartambience()
{
    thread snd_start_autofx_audio();
    thread sndnuclearbomb();
}

snd_start_autofx_audio()
{

}

sndnuclearbomb()
{

}

flyovers()
{
    while ( true )
    {
        playsound( 0, "amb_flyover", ( 0, 0, 0 ) );
        wait( randomintrange( 2, 8 ) );
    }
}

sndmudslow( localclientnum, oldval, newval, bnewent, binitialsnap, fieldname, bwasdemojump )
{
    if ( newval == 1 )
        self thread sndactivatemudloop();
    else
        self thread snddeactivatemudloop();
}

sndactivatemudloop()
{
    self endon( "stop_mud" );

    if ( !isdefined( self.sndwadeent ) )
    {
        self.sndwadeent = spawn( 0, self.origin, "script_origin" );
        self.sndwadeent linkto( self, "tag_origin" );
    }

    self.sndwadeent playloopsound( "zmb_tomb_slowed_movement_loop", 1 );

    while ( true )
    {
        mud_speed = abs( self getspeed() );
        mud_vol = scale_speed( 21, 285, 0.1, 1, mud_speed );
        self.sndwadeent setloopstate( "zmb_tomb_slowed_movement_loop", mud_vol, 1 );
        wait 0.1;
    }
}

snddeactivatemudloop()
{
    self notify( "stop_mud" );
    self.sndwadeent stoploopsound( 1.5 );
}

init()
{
    level._entityshutdowncbfunc = clientscripts\mp\zm_tomb_amb::heli_linkto_sound_ents_delete;
    level.helisoundvalues = [];
    init_heli_sound_values( "qrdrone", "turbine_idle", 30, 0.8, 0.0, 16, 0.9, 1.1 );
    init_heli_sound_values( "qrdrone", "turbine_moving", 30, 0.0, 0.9, 20, 0.9, 1.1 );
    init_heli_sound_values( "qrdrone", "turn", 5, 0, 1, 1, 1, 1 );
/#
    if ( getdvar( #"_id_21D60E03" ) == "" )
        setdvar( "helisounds", "" );

    level thread command_parser();
#/
}

init_heli_sound_values( heli_type, part_type, max_speed_vol, min_vol, max_vol, max_speed_pitch, min_pitch, max_pitch )
{
    if ( !isdefined( level.helisoundvalues[heli_type] ) )
        level.helisoundvalues[heli_type] = [];

    if ( !isdefined( level.helisoundvalues[heli_type][part_type] ) )
        level.helisoundvalues[heli_type][part_type] = spawnstruct();

    level.helisoundvalues[heli_type][part_type].speedvolumemax = max_speed_vol;
    level.helisoundvalues[heli_type][part_type].speedpitchmax = max_speed_pitch;
    level.helisoundvalues[heli_type][part_type].volumemin = min_vol;
    level.helisoundvalues[heli_type][part_type].volumemax = max_vol;
    level.helisoundvalues[heli_type][part_type].pitchmin = min_pitch;
    level.helisoundvalues[heli_type][part_type].pitchmax = max_pitch;
/#
    if ( getdvarint( #"_id_55AD9BED" ) > 0 )
    {
        println( "Init Heli Sounds heli_type: " + heli_type );
        println( "Init Heli Sounds part_type: " + part_type );
        println( "Init Heli Sounds max_speed_vol: " + max_speed_vol );
        println( "Init Heli Sounds min_vol: " + min_vol );
        println( "Init Heli Sounds max_vol: " + max_vol );
        println( "Init Heli Sounds max_speed_pitch: " + max_speed_pitch );
        println( "Init Heli Sounds min_pitch: " + min_pitch );
        println( "Init Heli Sounds max_pitch: " + max_pitch );
    }
#/
}

command_parser()
{
/#
    while ( true )
    {
        command = getdvar( #"_id_21D60E03" );

        if ( command != "" )
        {
            success = 1;
            tokens = strtok( command, " " );

            if ( !isdefined( tokens[0] ) || !isdefined( level.helisoundvalues[tokens[0]] ) )
            {
                if ( isdefined( tokens[0] ) )
                    println( "helisounds Did not recognize helicopter type:  " + tokens[0] );
                else
                    println( "helisounds Did not recognize helicopter type" );

                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }
            else if ( !isdefined( tokens[1] ) )
            {
                if ( isdefined( tokens[1] ) )
                    println( "helisounds Did not recognize helicopter part:  " + tokens[0] + " for heli: " + tokens[1] );
                else
                    println( "helisounds Did not recognize helicopter part for heli: " + tokens[0] );

                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }
            else if ( !isdefined( tokens[2] ) )
            {
                println( "helisounds Did not recognize helicopter value name for heli:" + tokens[0] + " part: " + tokens[1] );
                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }
            else if ( !isdefined( tokens[3] ) )
            {
                println( "helisounds Did not recognize helicopter value for heli:" + tokens[0] + " part: " + tokens[1] );
                println( "helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                success = 0;
            }

            if ( success )
            {
                heli_type = tokens[0];
                heli_part = tokens[1];
                value_name = tokens[2];
                value = float( tokens[3] );

                switch ( value_name )
                {
                    case "volumemin":
                        level.helisoundvalues[heli_type][heli_part].volumemin = value;
                        println( "Setting volumeMin to " + value );
                        break;
                    case "volumemax":
                        level.helisoundvalues[heli_type][heli_part].volumemax = value;
                        println( "Setting volumeMax to " + value );
                        break;
                    case "pitchmin":
                        level.helisoundvalues[heli_type][heli_part].pitchmin = value;
                        println( "Setting pitchMin to " + value );
                        break;
                    case "pitchmax":
                        level.helisoundvalues[heli_type][heli_part].pitchmax = value;
                        println( "Setting pitchMax to " + value );
                        break;
                    case "speedvolumemax":
                        level.helisoundvalues[heli_type][heli_part].speedvolumemax = value;
                        println( "Setting speedVolumeMax to " + value );
                        break;
                    case "speedpitchmax":
                        level.helisoundvalues[heli_type][heli_part].speedpitchmax = value;
                        println( "Setting speedPitchMax to " + value );
                        break;
                    default:
                        println( "no case match - helisounds usage: helisounds <heli name> <part name> <value name> <value>" );
                }
            }

            setdvar( "helisounds", "" );
        }

        wait 0.1;
    }
#/
}

init_heli_sounds_player_drone()
{
    setup_heli_sounds( "turbine_idle", "engine", "tag_body", "veh_qrdrone_turbine_idle" );
    setup_heli_sounds( "turbine_moving", "engine", "tag_body", "veh_qrdrone_turbine_moving" );
    setup_heli_sounds( "turn", "engine", "tag_body", "veh_qrdrone_idle_rotate" );
    self.warning_tag = undefined;
}

sound_linkto( parent, tag )
{
    if ( isdefined( tag ) )
        self linkto( parent, tag );
    else
        self linkto( parent, "tag_body" );
}

setup_heli_sounds( bone_location, type, tag, run, dmg1, dmg2, dmg3 )
{
    self.heli[bone_location] = spawnstruct();
    self.heli[bone_location].sound_type = type;
    self.heli[bone_location].run = spawn( 0, self.origin, "script_origin" );
    self.heli[bone_location].run sound_linkto( self, tag );
    self.heli[bone_location].run.alias = run;
    self thread heli_loop_sound_delete( self.heli[bone_location].run );

    if ( isdefined( dmg1 ) )
    {
        self.heli[bone_location].idle = spawn( 0, self.origin, "script_origin" );
        self.heli[bone_location].idle sound_linkto( self, tag );
        self.heli[bone_location].idle.alias = dmg1;
        self thread heli_loop_sound_delete( self.heli[bone_location].dmg1 );
    }

    if ( isdefined( dmg2 ) )
    {
        self.heli[bone_location].idle = spawn( 0, self.origin, "script_origin" );
        self.heli[bone_location].idle sound_linkto( self, tag );
        self.heli[bone_location].idle.alias = dmg2;
        self thread heli_loop_sound_delete( self.heli[bone_location].dmg2 );
    }

    if ( isdefined( dmg3 ) )
    {
        self.heli[bone_location].idle = spawn( 0, self.origin, "script_origin" );
        self.heli[bone_location].idle sound_linkto( self, tag );
        self.heli[bone_location].idle.alias = dmg3;
        self thread heli_loop_sound_delete( self.heli[bone_location].dmg3 );
    }
}

start_helicopter_sounds( localclientnum )
{
    if ( isdefined( self.vehicletype ) )
    {
        self.heli = [];
        self.terrain = [];
        self.sound_ents = [];
        self.cur_speed = 0;
        self.mph_to_inches_per_sec = 17.6;
        self.speed_of_wind = 20;
        self.idle_run_trans_speed = 5;
        self init_heli_sounds_player_drone();
        self play_player_drone_sounds();
    }
}

heli_loop_sound_delete( real_ent )
{
    self waittill( "entityshutdown" );
    real_ent unlink();
    real_ent stoploopsound( 4 );
    real_ent delete();
}

heli_linkto_sound_ents_delete( localclientnum, entity )
{
    entity notify( "entityshutdown" );
}

heli_sound_play( heli_bone )
{
    switch ( heli_bone.sound_type )
    {
        case "engine":
            heli_bone.run playloopsound( heli_bone.run.alias, 2 );
            break;
        case "wind":
            break;
        default:
/#
            println( "^6 unknown helicopter type: " + heli_bone.type + " expecting \"wind\" or \"engine\"" );
#/
            break;
    }
}

play_player_drone_sounds()
{
    self thread heli_idle_run_transition( "qrdrone", "turbine_idle", 0.1, 1 );
    self thread heli_idle_run_transition( "qrdrone", "turbine_moving", 0.1, 1 );
    self thread drone_up_down_transition();
    self thread drone_rotate_angle( "qrdrone", "turn" );
}

heli_idle_run_transition( heli_type, heli_part, wait_time, updown )
{
    self endon( "entityshutdown" );
    heli_bone = self.heli[heli_part];
    run_id = heli_bone.run playloopsound( heli_bone.run.alias, 0.5 );

    if ( !isdefined( wait_time ) )
        wait_time = 0.5;

    while ( isdefined( self ) )
    {
        if ( !isdefined( level.helisoundvalues[heli_type] ) || !isdefined( level.helisoundvalues[heli_type][heli_part] ) )
        {
/#
            println( "^5a speed vol/pitch parameter was not defined." );
#/
            return;
        }

        max_speed_vol = level.helisoundvalues[heli_type][heli_part].speedvolumemax;
        min_vol = level.helisoundvalues[heli_type][heli_part].volumemin;
        max_vol = level.helisoundvalues[heli_type][heli_part].volumemax;
        max_speed_pitch = level.helisoundvalues[heli_type][heli_part].speedpitchmax;
        min_pitch = level.helisoundvalues[heli_type][heli_part].pitchmin;
        max_pitch = level.helisoundvalues[heli_type][heli_part].pitchmax;
        plr_vel = self getvelocity();
        self.cur_speed = abs( sqrt( vectordot( plr_vel, plr_vel ) ) ) / self.mph_to_inches_per_sec;
        run_volume = scale_speed( self.idle_run_trans_speed, max_speed_vol, min_vol, max_vol, self.cur_speed );
        run_pitch = scale_speed( self.idle_run_trans_speed, max_speed_pitch, min_pitch, max_pitch, self.cur_speed );

        if ( isdefined( updown ) )
        {
            if ( !isdefined( self.qrdrone_z_difference ) )
                self.qrdrone_z_difference = 0;

            run_volume_vertical = scale_speed( 5, 50, 0, 1, abs( self.qrdrone_z_difference ) );
            run_volume = run_volume - run_volume_vertical;
        }

        if ( isdefined( run_volume ) && isdefined( run_pitch ) )
        {
            heli_bone.run setloopstate( heli_bone.run.alias, run_volume, run_pitch, 1, 0.15 );
/#
            if ( getdvarint( #"_id_55AD9BED" ) > 0 )
            {
                println( "^5a self.cur_speed = " + self.cur_speed );
                println( "^5a run_pitch . " + run_pitch );
                println( "^5a self.cur_speed = " + self.cur_speed );
                println( "^5a run_volume. " + run_volume );
            }
#/
        }

        wait( wait_time );
    }
}

get_heli_sound_ent( sound_ent )
{
    if ( !isdefined( sound_ent ) )
    {
        tag = "tag_origin";

        if ( isdefined( self.warning_tag ) )
            tag = self.warning_tag;

        sound_ent = spawn( 0, self gettagorigin( tag ), "script_origin" );
        sound_ent linkto( self, tag );
        self thread heli_sound_ent_delete( sound_ent );
    }

    return sound_ent;
}

get_lock_sound_ent()
{
    self.lock_sound_ent = get_heli_sound_ent( self.lock_sound_ent );
    return self.lock_sound_ent;
}

get_leaving_sound_ent()
{
    self.leaving_sound_ent = get_heli_sound_ent( self.leaving_sound_ent );
    return self.leaving_sound_ent;
}

heli_sound_ent_delete( real_ent )
{
    self waittill( "entityshutdown" );
    real_ent stoploopsound( 0.1 );
    real_ent delete();
}

drone_up_down_transition()
{
    self endon( "entityshutdown" );
    volumerate = 1;
    qr_ent_up = spawn( 0, self.origin, "script_origin" );
    qr_ent_down = spawn( 0, self.origin, "script_origin" );
    qr_ent_either = spawn( 0, self.origin, "script_origin" );
    qr_ent_up thread qr_ent_cleanup( self );
    qr_ent_down thread qr_ent_cleanup( self );
    qr_ent_either thread qr_ent_cleanup( self );
    self.qrdrone_z_difference = 0;
    down = qr_ent_down playloopsound( "veh_qrdrone_move_down" );
    qr_ent_down setloopstate( "veh_qrdrone_move_down", 0, 0 );
    up = qr_ent_up playloopsound( "veh_qrdrone_move_up" );
    qr_ent_up setloopstate( "veh_qrdrone_move_up", 0, 0 );
    either = qr_ent_either playloopsound( "veh_qrdrone_vertical" );
    qr_ent_either setloopstate( "veh_qrdrone_vertical", 0, 0 );
    tag = "tag_body";
    qr_ent_up linkto( self, tag );
    qr_ent_down linkto( self, tag );
    qr_ent_either linkto( self, tag );
    self thread drone_button_watch();

    while ( true )
    {
        last_pos = self.origin[2];
        wait 0.1;
        self.qrdrone_z_difference = last_pos - self.origin[2];

        if ( self.qrdrone_z_difference < 0 )
        {
            up_difference = self.qrdrone_z_difference * -1;
            run_volume_up = scale_speed( 5, 40, 0, 1, up_difference );
            run_pitch_up = scale_speed( 5, 40, 0.9, 1.1, up_difference );
            run_volume_either = scale_speed( 5, 50, 0, 1, up_difference );
            run_pitch_either = scale_speed( 5, 50, 0.9, 1.1, up_difference );
        }
        else
        {
            run_volume_up = 0;
            run_pitch_up = 1;
            run_volume_either = scale_speed( 5, 50, 0, 1, self.qrdrone_z_difference );
            run_pitch_either = scale_speed( 5, 50, 0.95, 0.8, self.qrdrone_z_difference );
        }

        run_volume_down = scale_speed( 5, 50, 0, 1, self.qrdrone_z_difference );
        run_pitch_down = scale_speed( 5, 50, 1, 0.8, self.qrdrone_z_difference );
        qr_ent_down setloopstate( "veh_qrdrone_move_down", run_volume_down, run_pitch_down, volumerate );
        qr_ent_up setloopstate( "veh_qrdrone_move_up", run_volume_up, run_pitch_up, volumerate );
        qr_ent_either setloopstate( "veh_qrdrone_vertical", run_volume_either, run_pitch_either, volumerate );
    }
}

qr_ent_cleanup( veh_ent )
{
    veh_ent waittill( "entityshutdown" );
    self delete();
}

drone_rotate_angle( heli_type, heli_part )
{
    self endon( "entityshutdown" );
    level endon( "save_restore" );
    volumerate = 2.5;
    qr_ent_angle = spawn( 0, self.origin, "script_origin" );
    qr_ent_angle thread qr_ent_cleanup( self );
    angle = qr_ent_angle playloopsound( "veh_qrdrone_idle_rotate" );
    setsoundvolume( angle, 0 );
    tag = "tag_body";
    qr_ent_angle linkto( self, tag );

    while ( true )
    {
        last_angle = abs( self.angles[1] );
        wait 0.1;
        turning_speed = last_angle - abs( self.angles[1] );
        abs_turning_speed = abs( turning_speed );
        jet_stick_vol = scale_speed( 0, 5, 0, 0.4, abs_turning_speed );
        jet_stick_pitch = scale_speed( 0, 4, 0.9, 1.05, abs_turning_speed );
        qr_ent_angle setloopstate( "veh_qrdrone_idle_rotate", jet_stick_vol, jet_stick_pitch, volumerate );
    }
}

drone_button_watch()
{
    self endon( "entityshutdown" );
    player = getlocalplayers()[0];
    return_to_zero = 1;

    while ( true )
    {
        if ( abs( self.qrdrone_z_difference ) > 5 && return_to_zero )
        {
            self playsound( 0, "veh_qrdrone_move_start" );
            return_to_zero = 0;
        }
        else if ( abs( self.qrdrone_z_difference ) < 5 && !return_to_zero )
            return_to_zero = 1;

        wait 0.05;
    }
}
