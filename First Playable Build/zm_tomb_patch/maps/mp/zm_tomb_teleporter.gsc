// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\zombies\_zm_craftables;

teleporter_init()
{
    registerclientfield( "toplayer", "teleporter_fx", 14000, 1, "int" );
    precacheshellshock( "lava" );
    level.teleport = [];
    level.n_active_links = 0;
    level.n_countdown = 0;
    level.n_teleport_delay = 0;
    level.teleport_cost = 1500;
    level.n_teleport_cooldown = 0;
    level.is_cooldown = 0;
    level.n_active_timer = -1;
    level.n_teleport_time = 0;
    n_teleporters = 6;

    for ( i = 0; i < n_teleporters; i++ )
    {
        t_teleporter = getent( "trigger_teleport_pad_" + i, "targetname" );

        if ( isdefined( t_teleporter ) )
            level.teleporter_pad_trig[i] = t_teleporter;
    }
}

stargate_teleport_think( index )
{
    t_teleporter = level.teleporter_pad_trig[index];
    t_teleporter setcursorhint( "HINT_NOICON" );
    t_teleporter sethintstring( &"ZM_TOMB_NEED_ALL_CRYSTALS" );

    if ( isdefined( t_teleporter ) )
    {
        while ( true )
        {
            t_teleporter waittill( "trigger", player );
            player playlocalsound( "evt_teleporter_plr" );
            t_teleporter playsound( "evt_teleporter_npc" );
            t_teleporter thread stargate_teleport_player( index, player );
        }
    }
}

stargate_teleport_player( index, player )
{
    n_pos = player.characterindex;

    if ( index == 5 )
        index = randomintrange( 1, 5 );

    prone_offset = vectorscale( ( 0, 0, 1 ), 49.0 );
    crouch_offset = vectorscale( ( 0, 0, 1 ), 20.0 );
    stand_offset = ( 0, 0, 0 );
    image_room = getstruct( "teleport_room_" + n_pos, "targetname" );
    player disableoffhandweapons();
    player disableweapons();

    if ( player getstance() == "prone" )
        desired_origin = image_room.origin + prone_offset;
    else if ( player getstance() == "crouch" )
        desired_origin = image_room.origin + crouch_offset;
    else
        desired_origin = image_room.origin + stand_offset;

    player.teleport_origin = spawn( "script_origin", player.origin );
    player.teleport_origin.angles = player.angles;
    player linkto( player.teleport_origin );
    player.teleport_origin.origin = desired_origin;
    player freezecontrols( 1 );
    wait_network_frame();
    player.teleport_origin.angles = image_room.angles;
    wait 0.05;

    if ( index >= 9 )
        wait 4;
    else
        wait 1;

    if ( index == 0 )
        a_pos = getstructarray( "crypt_teleport_player", "targetname" );
    else if ( index == 1 )
        a_pos = getstructarray( "tank_teleport_player", "targetname" );
    else if ( index == 2 )
        a_pos = getstructarray( "nml_teleport_player", "targetname" );
    else if ( index == 3 )
        a_pos = getstructarray( "trench_teleport_player", "targetname" );
    else if ( index == 4 )
        a_pos = getstructarray( "village_teleport_player", "targetname" );
    else if ( index == 6 )
        a_pos = getstructarray( "head_teleport_player", "targetname" );
    else if ( index == 7 )
        a_pos = getstructarray( "head_2_teleport_player", "targetname" );
    else if ( index == 8 )
        a_pos = getstructarray( "head_3_teleport_player", "targetname" );
    else
        a_pos = getstructarray( "ruins_teleport_player", "targetname" );

    s_pos = get_free_teleport_pos( player, a_pos );
    player unlink();
    player.teleport_origin delete();
    player.teleport_origin = undefined;
    player setorigin( s_pos.origin );
    player setplayerangles( s_pos.angles );
    player enableweapons();
    player enableoffhandweapons();
    player freezecontrols( 0 );
}

get_free_teleport_pos( player, a_structs )
{
    n_player_radius = 64;
    n_min_dist_sq = n_player_radius * n_player_radius;
    b_pos_free = 0;

    while ( !b_pos_free )
    {
        a_players = getplayers();

        for ( i = 0; i < a_players.size; i++ )
        {
            if ( is_player_valid( a_players[i] ) )
            {
                for ( j = 0; j < a_structs.size; j++ )
                {
                    n_dist_sq = distance2dsquared( a_players[i].origin, a_structs[j].origin );

                    if ( n_dist_sq > n_min_dist_sq )
                    {
                        return a_structs[j];
                        b_pos_free = 1;
                    }
                }
            }
        }

        wait 0.05;
    }
}

teleporter_active_fx( n_index )
{
    fx_glow = "elec_glow";

    switch ( n_index )
    {
        case 0:
            e_teleport_fx = getent( "teleporter_center", "targetname" );
            break;
        case 1:
            e_teleport_fx = getent( "teleporter_air_fx", "targetname" );
            fx_glow = "air_glow";
            break;
        case 2:
            e_teleport_fx = getent( "teleporter_fire_fx", "targetname" );
            fx_glow = "fire_glow";
            break;
        case 3:
            e_teleport_fx = getent( "teleporter_ice_fx", "targetname" );
            fx_glow = "ice_glow";
            break;
        case 4:
            e_teleport_fx = getent( "teleporter_bolt_fx", "targetname" );
            break;
        case 5:
            e_teleport_fx = getent( "teleporter_crypt_fx", "targetname" );
            break;
    }

    playfxontag( level._effect[fx_glow], e_teleport_fx, "tag_origin" );
}
