// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zm_tomb_quest_air;
#include maps\mp\zm_tomb_quest_fire;
#include maps\mp\zm_tomb_quest_ice;
#include maps\mp\zm_tomb_quest_elec;
#include maps\mp\zm_tomb_quest_crypt;
#include maps\mp\zm_tomb_craftables;
#include maps\mp\zombies\_zm_unitrigger;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\zombies\_zm_weap_claymore;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zm_tomb_teleporter;

main_quest_init()
{
    flag_init( "air_reveal" );
    flag_init( "dug" );
    flag_init( "air_open" );
    flag_init( "fire_open" );
    flag_init( "lightning_open" );
    flag_init( "ice_open" );
    flag_init( "panels_solved" );
    flag_init( "fire_solved" );
    flag_init( "ice_solved" );
    flag_init( "air_done" );
    flag_init( "fire_done" );
    flag_init( "water_done" );
    flag_init( "lightning_done" );
    flag_init( "chamber_puzzle_cheat" );
    flag_init( "activate_zone_crypt" );
    level.callbackvehicledamage = ::aircrystalbiplanecallback_vehicledamage;
    level.onplayerdisconnect = ::player_disconnect_callback;
    onplayerconnect_callback( ::onplayerconnect );
    staff_air = getent( "prop_staff_air", "targetname" );
    staff_fire = getent( "prop_staff_fire", "targetname" );
    staff_lightning = getent( "prop_staff_lightning", "targetname" );
    staff_water = getent( "prop_staff_water", "targetname" );
    staff_air.weapname = "staff_air_zm";
    staff_fire.weapname = "staff_fire_zm";
    staff_lightning.weapname = "staff_lightning_zm";
    staff_water.weapname = "staff_water_zm";
    staff_air.element = "air";
    staff_fire.element = "fire";
    staff_lightning.element = "lightning";
    staff_water.element = "water";
    staff_air.craftable_name = "elemental_staff_air";
    staff_fire.craftable_name = "elemental_staff_fire";
    staff_lightning.craftable_name = "elemental_staff_lightning";
    staff_water.craftable_name = "elemental_staff_water";
    staff_air.charger = getstruct( "staff_air_charger", "script_noteworthy" );
    staff_fire.charger = getstruct( "staff_fire_charger", "script_noteworthy" );
    staff_lightning.charger = getstruct( "zone_bolt_chamber", "script_noteworthy" );
    staff_water.charger = getstruct( "staff_ice_charger", "script_noteworthy" );
    staff_fire.quest_clientfield = "quest_state1";
    staff_air.quest_clientfield = "quest_state2";
    staff_lightning.quest_clientfield = "quest_state3";
    staff_water.quest_clientfield = "quest_state4";
    staff_fire.enum = 1;
    staff_air.enum = 2;
    staff_lightning.enum = 3;
    staff_water.enum = 4;
    staff_air.vol_chamber = getent( staff_air.charger.target, "targetname" );
    staff_fire.vol_chamber = getent( staff_fire.charger.target, "targetname" );
    staff_lightning.vol_chamber = getent( staff_lightning.charger.target, "targetname" );
    staff_water.vol_chamber = getent( staff_water.charger.target, "targetname" );
    level.a_elemental_staffs = [];
    level.a_elemental_staffs[level.a_elemental_staffs.size] = staff_air;
    level.a_elemental_staffs[level.a_elemental_staffs.size] = staff_fire;
    level.a_elemental_staffs[level.a_elemental_staffs.size] = staff_lightning;
    level.a_elemental_staffs[level.a_elemental_staffs.size] = staff_water;

    foreach ( staff in level.a_elemental_staffs )
    {
        staff.charger.charges_received = 0;
        staff.charger.is_inserted = 0;
        staff.ammo = 50;
        staff thread place_staffs_encasement();
        staff thread staff_charger_check();
        staff ghost();
    }

    staff_air_upgraded = getent( "prop_staff_air_upgraded", "targetname" );
    staff_fire_upgraded = getent( "prop_staff_fire_upgraded", "targetname" );
    staff_lightning_upgraded = getent( "prop_staff_lightning_upgraded", "targetname" );
    staff_water_upgraded = getent( "prop_staff_water_upgraded", "targetname" );
    staff_air_upgraded.weapname = "staff_air_upgraded_zm";
    staff_fire_upgraded.weapname = "staff_fire_upgraded_zm";
    staff_lightning_upgraded.weapname = "staff_lightning_upgraded_zm";
    staff_water_upgraded.weapname = "staff_water_upgraded_zm";
    staff_air_upgraded.base_weapname = "staff_air_zm";
    staff_fire_upgraded.base_weapname = "staff_fire_zm";
    staff_lightning_upgraded.base_weapname = "staff_lightning_zm";
    staff_water_upgraded.base_weapname = "staff_water_zm";
    staff_air_upgraded.element = "air";
    staff_fire_upgraded.element = "fire";
    staff_lightning_upgraded.element = "lightning";
    staff_water_upgraded.element = "water";
    staff_air_upgraded.charger = staff_air.charger;
    staff_fire_upgraded.charger = staff_fire.charger;
    staff_lightning_upgraded.charger = staff_lightning.charger;
    staff_water_upgraded.charger = staff_water.charger;
    staff_air_upgraded.vol_chamber = staff_air.vol_chamber;
    staff_fire_upgraded.vol_chamber = staff_fire.vol_chamber;
    staff_lightning_upgraded.vol_chamber = staff_lightning.vol_chamber;
    staff_water_upgraded.vol_chamber = staff_water.vol_chamber;
    staff_air.upgrade = staff_air_upgraded;
    staff_fire.upgrade = staff_fire_upgraded;
    staff_water.upgrade = staff_water_upgraded;
    staff_lightning.upgrade = staff_lightning_upgraded;
    level.a_elemental_staffs_upgraded = [];
    level.a_elemental_staffs_upgraded[level.a_elemental_staffs_upgraded.size] = staff_air_upgraded;
    level.a_elemental_staffs_upgraded[level.a_elemental_staffs_upgraded.size] = staff_fire_upgraded;
    level.a_elemental_staffs_upgraded[level.a_elemental_staffs_upgraded.size] = staff_lightning_upgraded;
    level.a_elemental_staffs_upgraded[level.a_elemental_staffs_upgraded.size] = staff_water_upgraded;

    foreach ( staff_upgraded in level.a_elemental_staffs_upgraded )
    {
        staff_upgraded.charger.charges_received = 0;
        staff_upgraded.charger.is_inserted = 0;
        staff_upgraded.charger.is_charged = 0;
        staff_upgraded.ammo = 100;
        staff_upgraded thread place_staffs_encasement();
        staff_upgraded ghost();
    }

    level.staffs_charged = 0;
    array_thread( level.zombie_spawners, ::add_spawn_function, ::zombie_spawn_func );
    level thread staff_encasement_fx();
    level thread watch_for_staff_upgrades();
    level thread dig_spots_init();
    level thread chambers_init();
    level thread maps\mp\zm_tomb_quest_air::main();
    level thread maps\mp\zm_tomb_quest_fire::main();
    level thread maps\mp\zm_tomb_quest_ice::main();
    level thread maps\mp\zm_tomb_quest_elec::main();
    level thread maps\mp\zm_tomb_quest_crypt::main();
    level.dig_spawners = [];
    level.dig_spawners[0] = getent( "zombie_german_spawner", "script_noteworthy" );
    level.dig_spawners[1] = getent( "zombie_crusader_spawner", "script_noteworthy" );
    array_thread( level.dig_spawners, ::add_spawn_function, ::dug_zombie_spawn_init );
}

onplayerconnect()
{

}

player_disconnect_callback()
{

}

place_staffs_encasement()
{
    s_pos = getstruct( "staff_pos_" + self.element, "targetname" );
    self.origin = s_pos.origin;
    self.angles = s_pos.angles;
}

chambers_init()
{
    flag_init( "gramophone_placed" );
    array_thread( getentarray( "trigger_death_floor", "targetname" ), ::monitor_chamber_death_trigs );
    a_door_fire = getentarray( "door_fire", "targetname" );
    a_door_ice = getentarray( "door_ice", "targetname" );
    a_door_air = getentarray( "door_air", "targetname" );
    a_door_electric = getentarray( "door_electric", "targetname" );
    a_door_main = getentarray( "chamber_entrance", "targetname" );
    array_thread( a_door_fire, ::run_gramophone_door, "vinyl_fire", ::door_removal_fire_chamber );
    array_thread( a_door_ice, ::run_gramophone_door, "vinyl_ice", ::door_removal_ice_chamber );
    array_thread( a_door_air, ::run_gramophone_door, "vinyl_air", ::door_removal_air_chamber );
    array_thread( a_door_electric, ::run_gramophone_door, "vinyl_elec", ::door_removal_electric_chamber );
    array_thread( a_door_main, ::run_gramophone_door, "vinyl_master", ::door_removal_main_chamber );
}

monitor_chamber_death_trigs()
{
    while ( true )
    {
        self waittill( "trigger", ent );

        if ( isplayer( ent ) )
            ent.bleedout_time = 0;

        ent dodamage( ent.health + 666, ent.origin );
        wait 0.05;
    }
}

door_removal_main_chamber()
{
    struct = getstruct( self.targetname + "_position", "targetname" );
    origin = struct.origin;
    playsoundatposition( "zmb_gramophone_main", origin );
    wait 3.0;
    playfx( level._effect["lightning_reveal"], self.origin );
}

door_removal_fire_chamber()
{
    struct = getstruct( self.targetname + "_position", "targetname" );
    origin = struct.origin;
    playsoundatposition( "zmb_gramophone_fire", origin );
    wait 3.0;
}

door_removal_ice_chamber()
{
    struct = getstruct( self.targetname + "_position", "targetname" );
    origin = struct.origin;
    playsoundatposition( "zmb_gramophone_ice", origin );
    wait 3.0;
}

door_removal_electric_chamber()
{
    struct = getstruct( self.targetname + "_position", "targetname" );
    origin = struct.origin;
    playsoundatposition( "zmb_gramophone_electric", origin );
    wait 3.0;
}

door_removal_air_chamber()
{
    struct = getstruct( self.targetname + "_position", "targetname" );
    origin = struct.origin;
    playsoundatposition( "zmb_gramophone_air", origin );
    wait 3.0;
}

watch_gramophone_vinyl_pickup( trig_position, str_vinyl_record )
{
    level waittill( "gramophone_" + str_vinyl_record + "_picked_up" );
    trig_position.has_vinyl = 1;

    if ( isdefined( trig_position.gramophone_model ) && isdefined( trig_position.trigger ) )
        trig_position.trigger sethintstring( &"ZM_TOMB_PLAY_RECORD" );
}

run_gramophone_door_debug( trig_position, func_door_removal )
{
/#
    while ( getdvar( #"_id_63436BFB" ) != "on" )
        wait 0.1;

    level notify( "open_all_gramophone_doors" );

    if ( isdefined( self ) )
    {
        flag_set( self.targetname + "_opened" );
        self [[ func_door_removal ]]();
        self connectpaths();
        self delete();
    }

    if ( isdefined( trig_position.script_flag ) )
        flag_set( trig_position.script_flag );

    if ( isdefined( trig_position.trigger ) )
    {
        trig_position.trigger delete();
        trig_position.trigger = undefined;
    }

    wait 1.0;
    setdvar( "open_chambers", "off" );
#/
}

run_gramophone_door( str_vinyl_record, func_door_removal )
{
/#
    level endon( "open_all_gramophone_doors" );
#/
    flag_init( self.targetname + "_opened" );
    trig_position = getstruct( self.targetname + "_position", "targetname" );
    trig_position.has_vinyl = 0;
    trig_position.gramophone_model = undefined;
    level thread watch_gramophone_vinyl_pickup( trig_position, str_vinyl_record );
/#
    self thread run_gramophone_door_debug( trig_position, func_door_removal );
#/
    level waittill( "gramophone_vinyl_player_picked_up" );
    str_craftablename = "gramophone";
    t_door = spawn( "trigger_radius_use", trig_position.origin, 0, 100, 150 );
    t_door triggerignoreteam();
    t_door sethintstring( &"ZM_TOMB_PLACE_GRAMOPHONE" );
    t_door setcursorhint( "HINT_NOICON" );
    trig_position.trigger = t_door;
    self.t_door = t_door;
    error_shown = 0;
    door_open = 0;

    while ( true )
    {
        t_door waittill( "trigger", player );

        if ( !isdefined( trig_position.gramophone_model ) )
        {
            if ( !flag( "gramophone_placed" ) )
            {
                trig_position.gramophone_model = spawn( "script_model", trig_position.origin );
                trig_position.gramophone_model.angles = trig_position.angles;
                trig_position.gramophone_model setmodel( "p6_zm_tm_gramophone" );
                t_door sethintstring( &"ZM_TOMB_PLAY_RECORD" );
                flag_set( "gramophone_placed" );
                level setclientfield( "piece_record_zm_player", 0 );
            }
            else
                player door_gramophone_elsewhere_hint();
        }
        else if ( door_open )
        {
            trig_position.gramophone_model delete();
            trig_position.gramophone_model = undefined;
            flag_clear( "gramophone_placed" );
            player playsound( "zmb_craftable_pickup" );
            level setclientfield( "piece_record_zm_player", 1 );
            break;
        }
        else if ( trig_position.has_vinyl )
        {
            flag_set( self.targetname + "_opened" );
            t_door disable_trigger();
            t_door sethintstring( &"ZM_TOMB_PICKUP_GRAMOPHONE" );
            self [[ func_door_removal ]]();
            self connectpaths();
            self delete();

            if ( isdefined( trig_position.script_flag ) )
                flag_set( trig_position.script_flag );

            t_door enable_trigger();
            door_open = 1;
        }
        else if ( error_shown )
        {
            t_door sethintstring( &"ZM_TOMB_PLACE_GRAMOPHONE" );
            trig_position.gramophone_model delete();
            trig_position.gramophone_model = undefined;
            flag_clear( "gramophone_placed" );
            level setclientfield( "piece_record_zm_player", 1 );
            player playsound( "zmb_craftable_pickup" );
            error_shown = 0;
        }
        else
        {
            player thread door_record_hint();
            t_door sethintstring( &"ZM_TOMB_PICKUP_GRAMOPHONE" );
            error_shown = 1;
        }
    }

    trig_position.trigger = undefined;
    t_door delete();
}

watch_for_staff_upgrades()
{
    foreach ( staff in level.a_elemental_staffs )
        staff thread staff_upgrade_watch();
}

staff_upgrade_watch()
{
    flag_wait( self.weapname + "_upgrade_unlocked" );
    self thread place_staff_in_charger();
}

staff_encasement_fx()
{
    t_craft = getent( "staff_craftable_trigger", "targetname" );
    e_fx = spawn( "script_model", t_craft.origin );
    e_fx setmodel( "tag_origin" );
    playfxontag( level._effect["crystal_insert"], e_fx, "tag_origin" );
    waittill_crafted( "elemental_staff" );
    e_fx delete();
}

staff_get_pickup_message()
{
    if ( self.element == "air" )
        return &"ZM_TOMB_AIR_STAFF_PICKUP";
    else if ( self.element == "fire" )
        return &"ZM_TOMB_FIRE_STAFF_PICKUP";
    else if ( self.element == "lightning" )
        return &"ZM_TOMB_LIGHTNING_STAFF_PICKUP";
    else
        return &"ZM_TOMB_ICE_STAFF_PICKUP";
}

staff_get_insert_message()
{
    if ( self.element == "air" )
        return &"ZM_TOMB_ZOMBIE_AIR_STAFF_INSERT";
    else if ( self.element == "fire" )
        return &"ZM_TOMB_ZOMBIE_FIRE_STAFF_INSERT";
    else if ( self.element == "lightning" )
        return &"ZM_TOMB_ZOMBIE_LIGHTNING_STAFF_INSERT";
    else
        return &"ZM_TOMB_ZOMBIE_WATER_STAFF_INSERT";
}

spawn_staff_encasement_trigger()
{
    self.trigger = spawn( "trigger_radius_use", self.origin, 0, 100, 100 );
    self.trigger usetriggerrequirelookat();
    self.trigger triggerignoreteam();
    self.trigger setcursorhint( "HINT_NOICON" );
    self thread watch_for_player_pickup_staff();
}

player_has_staff()
{
    a_weapons = self getweaponslistprimaries();

    foreach ( weapon in a_weapons )
    {
        if ( issubstr( weapon, "staff" ) )
            return true;
    }

    return false;
}

can_pickup_staff()
{
    b_has_staff = self player_has_staff();
    b_staff_equipped = issubstr( self getcurrentweapon(), "staff" );

    if ( b_has_staff && !b_staff_equipped )
        self thread swap_staff_hint();

    return !b_has_staff || b_staff_equipped;
}

watch_for_player_pickup_staff()
{
    staff_picked_up = 0;
    pickup_message = self staff_get_pickup_message();
    self.trigger sethintstring( pickup_message );
    self show();
    self.trigger setvisibletoall();

    while ( !staff_picked_up )
    {
        self.trigger waittill( "trigger", player );
        self notify( "retrieved", player );

        if ( player can_pickup_staff() )
        {
            weapon_drop = player getcurrentweapon();
            a_weapons = player getweaponslistprimaries();

            if ( a_weapons.size > 1 )
            {
                n_ammo = player getweaponammoclip( weapon_drop );
                player takeweapon( weapon_drop );
            }

            player thread watch_staff_ammo_reload();
            self ghost();
            self setinvisibletoall();
            player giveweapon( self.weapname );
            player switchtoweapon( self.weapname );
            player setweaponammoclip( self.weapname, 100 );

            if ( issubstr( self.weapname, "upgraded" ) )
            {
                player setactionslot( 3, "weapon", "staff_revive_zm" );
                player giveweapon( "staff_revive_zm" );
            }

            self.owner = player;
            level notify( "stop_staff_sound" );
            self notify( "staff_equip" );
            staff_picked_up = 1;
            self.charger.is_inserted = 0;
            maps\mp\zm_tomb_craftables::set_player_staff( self.weapname, player );
        }
    }
}

watch_staff_ammo_reload()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "zmb_max_ammo" );
        a_weapons = self getweaponslistprimaries();

        foreach ( weapon in a_weapons )
        {
            if ( issubstr( weapon, "staff" ) )
            {
                if ( issubstr( weapon, "upgraded" ) )
                {
                    self setweaponammoclip( weapon, 100 );
                    continue;
                }

                self setweaponammoclip( weapon, 50 );
            }
        }
    }
}

staff_mechz_drop_pieces( a_staff_pieces )
{
    flag_wait( "start_zombie_round_logic" );

    foreach ( s_piece in a_staff_pieces )
        s_piece.piecespawn.model ghost();

    foreach ( s_piece in a_staff_pieces )
    {
        level waittill( "mechz_exploded", origin );
        s_piece.piecespawn.canmove = 1;
        maps\mp\zombies\_zm_unitrigger::reregister_unitrigger_as_dynamic( s_piece.piecespawn.unitrigger );
        vert_offset = 4 + s_piece.piecespawn.height * 0.5;
        s_piece.piecespawn.model moveto( origin + ( 0, 0, vert_offset ), 0.05 );
        s_piece.piecespawn.model waittill( "movedone" );

        if ( isdefined( s_piece.piecespawn.model ) )
            s_piece.piecespawn.model show();
    }
}

staff_biplane_drop_pieces( a_staff_pieces )
{
    flag_wait( "start_zombie_round_logic" );

    foreach ( staff_piece in a_staff_pieces )
    {
        staff_piece.origin = staff_piece.piecespawn.model.origin;
        staff_piece.piecespawn.model ghost();
        staff_piece.piecespawn.model movez( -500, 0.05 );
    }

    flag_wait( "activate_zone_village_0" );
    s_biplane_pos = getstruct( "air_crystal_biplane_pos", "targetname" );
    vh_biplane = spawnvehicle( "veh_t6_dlc_zm_biplane", "air_crystal_biplane", "biplane_zm", s_biplane_pos.origin, s_biplane_pos.angles );
    vh_biplane ent_flag_init( "biplane_down", 0 );
    e_fx_tag = getent( "air_crystal_biplane_tag", "targetname" );
    e_fx_tag moveto( vh_biplane.origin, 0.05 );
    e_fx_tag waittill( "movedone" );
    e_fx_tag linkto( vh_biplane, "tag_origin" );
    vh_biplane.health = 10000;
    vh_biplane setcandamage( 1 );
    vh_biplane setforcenocull();
    vh_biplane attachpath( getvehiclenode( "biplane_start", "targetname" ) );
    vh_biplane startpath();
    s_biplane_pos structdelete();
    playfxontag( level._effect["air_glow"], e_fx_tag, "tag_origin" );
    vh_biplane ent_flag_wait( "biplane_down" );

    foreach ( staff_piece in a_staff_pieces )
    {
        staff_piece.e_fx = spawn( "script_model", e_fx_tag.origin );
        staff_piece.e_fx setmodel( "tag_origin" );
        playfxontag( level._effect["air_glow"], staff_piece.e_fx, "tag_origin" );
        staff_piece.e_fx moveto( staff_piece.origin, 5.0 );
    }

    playfx( level._effect["mechz_death"], vh_biplane.origin );
    vh_biplane delete();
    e_fx_tag delete();
    a_staff_pieces[0].e_fx waittill( "movedone" );

    foreach ( staff_piece in a_staff_pieces )
    {
        staff_piece.e_fx delete();
        staff_piece.piecespawn.model show();
        staff_piece.piecespawn.model movez( 500, 0.05 );
        staff_piece.piecespawn.model waittill( "movedone" );
    }
}

aircrystalbiplanecallback_vehicledamage( e_inflictor, e_attacker, n_damage, n_dflags, str_means_of_death, str_weapon, v_point, v_dir, str_hit_loc, psoffsettime, b_damage_from_underneath, n_model_index, str_part_name )
{
    if ( self.vehicletype == "biplane_zm" && !self ent_flag( "biplane_down" ) )
    {
        playfxontag( level._effect["air_reveal"], self, "tag_origin" );
        self ent_flag_set( "biplane_down" );
    }

    return n_damage;
}

dig_spots_init()
{
    flag_wait( "start_zombie_round_logic" );
    t_dig = [];
    a_dig_spots = getstructarray( "dig_spot", "targetname" );
    a_trench_digs = getstructarray( "ice_staff_spot_trenches", "script_noteworthy" );
    a_nml_digs = getstructarray( "ice_staff_spot_nml", "script_noteworthy" );
    a_village_digs = getstructarray( "ice_staff_spot_village", "script_noteworthy" );
    a_possible_staff_spots = array( random( a_trench_digs ), random( a_nml_digs ), random( a_village_digs ) );

    foreach ( s_spot in a_possible_staff_spots )
        s_spot.contains_staff_piece = 1;

    for ( i = 0; i < a_dig_spots.size; i++ )
    {
        t_dig[i] = spawn( "trigger_radius_use", a_dig_spots[i].origin, 0, 100, 150 );
        t_dig[i] usetriggerrequirelookat();
        t_dig[i] triggerignoreteam();
        t_dig[i] sethintstring( &"ZM_TOMB_PRESS_X_TO_DIG" );
        t_dig[i] setcursorhint( "HINT_NOICON" );
        t_dig[i] thread waittill_dug( a_dig_spots[i] );
        wait 0.05;
        a_dig_spots[i] structdelete();
    }
}

waittill_dug( s_dig_spot )
{
    str_craftablename = "shovel";
    level.powerup_item = "";
/#
    if ( isdefined( s_dig_spot.contains_staff_piece ) && s_dig_spot.contains_staff_piece )
        s_dig_spot thread puzzle_debug_position( "+", vectorscale( ( 0, 0, 1 ), 255.0 ), s_dig_spot.origin );
#/

    while ( true )
    {
        self waittill( "trigger", player );

        if ( isdefined( player.has_shovel ) && player.has_shovel )
        {
            player playsound( "evt_dig" );
            m_dig = getent( s_dig_spot.target, "targetname" );
            playfx( level._effect["digging"], self.origin );
            m_dig delete();

            if ( isdefined( s_dig_spot.contains_staff_piece ) && s_dig_spot.contains_staff_piece )
                level notify( "dug_up_staff_piece", self.origin );
            else
            {
                n_prize = randomintrange( 0, 4 );

                switch ( n_prize )
                {
                    case 0:
                        self thread dig_up_powerup( player );
                        break;
                    case 1:
                        self thread dig_up_zombie( player, s_dig_spot );
                        break;
                    case 2:
                        self thread dig_up_grenade( player );
                        break;
                    case 3:
                        self thread dig_up_weapon( player );
                        break;
                }
            }

            self delete();
/#
            s_dig_spot notify( "stop_debug_position" );
#/
            s_dig_spot structdelete();
            break;
        }
        else
            player thread shovel_tutorial_hint();
    }
}

dig_up_zombie( player, s_dig_spot )
{
    ai_zombie = spawn_zombie( level.dig_spawners[0] );
    ai_zombie endon( "death" );
    ai_zombie ghost();
    e_linker = spawn( "script_origin", ( 0, 0, 0 ) );
    e_linker.origin = ai_zombie.origin;
    e_linker.angles = ai_zombie.angles;
    ai_zombie linkto( e_linker );
    e_linker moveto( player.origin + vectorscale( ( 1, 1, 0 ), 100.0 ), 0.1 );
    e_linker waittill( "movedone" );
    ai_zombie unlink();
    e_linker delete();
    ai_zombie show();
    ai_zombie dug_zombie_rise( s_dig_spot );
    find_flesh_struct_string = "find_flesh";
    ai_zombie notify( "zombie_custom_think_done", find_flesh_struct_string );
}

dig_up_powerup( player )
{
    v_spawn_pos = anglestoforward( player.angles ) * 60 + self.origin + vectorscale( ( 0, 0, 1 ), 24.0 );
    powerup = spawn( "script_model", v_spawn_pos );
    powerup endon( "powerup_grabbed" );
    powerup endon( "powerup_timedout" );
    a_powerups = array( "insta_kill", "nuke", "double_points", "full_ammo", "zombie_blood", "fire_sale" );
    powerup_item = a_powerups[randomint( a_powerups.size )];

    if ( powerup_item == level.powerup_item )
    {
        arrayremovevalue( a_powerups, powerup_item );
        powerup_item = a_powerups[randomint( a_powerups.size )];
        level.powerup_item = powerup_item;
        a_powerups[a_powerups.size] = powerup_item;
    }
    else
        level.powerup_item = powerup_item;

    if ( isdefined( powerup ) )
    {
        powerup maps\mp\zombies\_zm_powerups::powerup_setup( powerup_item );
        powerup thread maps\mp\zombies\_zm_powerups::powerup_timeout();
        powerup thread maps\mp\zombies\_zm_powerups::powerup_wobble();
        powerup thread maps\mp\zombies\_zm_powerups::powerup_grab();
    }
}

dig_up_grenade( player )
{
    player endon( "disconnect" );
    v_spawnpt = self.origin;
    grenade = "frag_grenade_zm";
    n_rand = randomintrange( 0, 4 );
    player magicgrenadetype( grenade, v_spawnpt, vectorscale( ( 0, 0, 1 ), 300.0 ), 3.0 );

    if ( n_rand )
    {
        wait 0.3;

        if ( cointoss() )
            player magicgrenadetype( grenade, v_spawnpt, ( 50, 50, 300 ), 3.0 );
    }
}

dig_up_weapon( digger )
{
    v_spawnpt = self.origin;
    v_spawnang = self.angles;
    a_weapons = array( "m14_zm", "srm1216_zm", "uzi_zm", "dsr50_zm", "c96_zm" );
    a_weapons = array_randomize( a_weapons );
    weapon = a_weapons[0];
    v_float = anglestoup( v_spawnang ) * 40;

    if ( weapon == "claymore_zm" )
        v_spawnang = v_spawnang + vectorscale( ( 1, 0, 0 ), 90.0 );

    weapon_model = spawn_weapon_model( weapon, undefined, v_spawnpt + v_float, v_spawnang + vectorscale( ( 0, 1, 0 ), 180.0 ) );
    weapon_model.trigger = spawn( "trigger_radius_use", v_spawnpt, 0, 100, 150 );
    weapon_model.trigger usetriggerrequirelookat();
    weapon_model.trigger triggerignoreteam();

    if ( weapon == "claymore_zm" )
        weapon_model.trigger sethintstring( &"MP_CLAYMORE_PICKUP" );
    else
        weapon_model.trigger sethintstring( &"ZM_TOMB_HOLD_X_TO_PICKUP" );

    weapon_model.trigger setcursorhint( "HINT_NOICON" );
    weapon_model thread timer_til_despawn( v_float );
    weapon_model.trigger waittill( "trigger", player );

    if ( weapon == "claymore_zm" )
    {
        if ( !player hasweapon( weapon ) )
            player thread maps\mp\zombies\_zm_weap_claymore::show_claymore_hint( "claymore_purchased" );

        player thread maps\mp\zombies\_zm_weap_claymore::claymore_setup();
        player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "weapon_pickup", "grenade" );
    }

    if ( player hasweapon( weapon ) )
        player givemaxammo( weapon );

    weapon_model.trigger notify( "weapon_grabbed" );
    weapon_model.trigger thread swap_weapon( weapon, player );

    if ( isdefined( weapon_model.trigger ) )
        weapon_model.trigger delete();

    if ( isdefined( weapon_model ) )
        weapon_model delete();
}

swap_weapon( weapon, player )
{
    current_weapon = player getcurrentweapon();

    if ( is_player_valid( player ) && !player.is_drinking && !is_placeable_mine( current_weapon ) && !is_equipment( current_weapon ) && level.revive_tool != current_weapon && "none" != current_weapon && !player hacker_active() )
    {
        if ( !player hasweapon( weapon ) )
            player take_old_weapon_and_give_new( current_weapon, weapon );
    }
}

take_old_weapon_and_give_new( current_weapon, weapon )
{
    a_weapons = self getweaponslistprimaries();

    if ( isdefined( a_weapons ) && a_weapons.size >= 2 )
        self takeweapon( current_weapon );

    self giveweapon( weapon );
    self switchtoweapon( weapon );
}

timer_til_despawn( v_float )
{
    self endon( "weapon_grabbed" );
    putbacktime = 12;
    self moveto( self.origin - v_float * 0.85, putbacktime, putbacktime * 0.5 );
    wait( putbacktime );

    if ( isdefined( self.trigger ) )
        self.trigger delete();

    if ( isdefined( self ) )
        self delete();
}

staff_unlock_with_zone_capture( s_staff_piece, str_zone_name )
{
    flag_wait( "start_zombie_round_logic" );
    s_staff_piece.piecespawn endon( "pickup" );
    zone = level.zones[str_zone_name];

    while ( true )
    {
        s_staff_piece.piecespawn.model ghost();
        s_staff_piece.piecespawn.model movez( -500, 0.05 );

        while ( !zone ent_flag_exist( "player_controlled" ) )
            wait_network_frame();

        zone ent_flag_wait( "player_controlled" );
        s_staff_piece.piecespawn.model show();
        s_staff_piece.piecespawn.model movez( 500, 0.05 );
        s_staff_piece.piecespawn.model waittill( "movedone" );
        zone ent_flag_waitopen( "player_controlled" );
    }
}

staff_ice_dig_pieces( a_staff_pieces )
{
    flag_wait( "start_zombie_round_logic" );

    foreach ( s_piece in a_staff_pieces )
        s_piece.piecespawn.model ghost();

    foreach ( s_piece in a_staff_pieces )
    {
        level waittill( "dug_up_staff_piece", origin );
        wait 0.5;
        s_piece.piecespawn.canmove = 1;
        maps\mp\zombies\_zm_unitrigger::reregister_unitrigger_as_dynamic( s_piece.piecespawn.unitrigger );
        vert_offset = 4 + s_piece.piecespawn.height * 0.5;
        s_piece.piecespawn.model moveto( origin + ( 0, 0, vert_offset ), 0.05 );
        s_piece.piecespawn.model waittill( "movedone" );
        s_piece.piecespawn.model show();
    }
}

crystal_play_glow_fx( s_crystal )
{
    flag_wait( "start_zombie_round_logic" );
    e_fx = spawn( "script_model", s_crystal.piecespawn.model.origin );
    e_fx setmodel( "tag_origin" );

    switch ( s_crystal.modelname )
    {
        case "t6_wpn_zmb_staff_crystal_air_world":
            e_fx.angles = vectorscale( ( 1, 0, 0 ), 90.0 );
            e_fx thread watch_for_crystal_pickup( s_crystal, "crystal_air_fx" );
            break;
        case "t6_wpn_zmb_staff_crystal_fire_world":
            e_fx thread watch_for_crystal_pickup( s_crystal, "crystal_fire_fx" );
            break;
        case "t6_wpn_zmb_staff_crystal_bolt_world":
            e_fx thread watch_for_crystal_pickup( s_crystal, "crystal_lightning_fx" );
            break;
        case "t6_wpn_zmb_staff_crystal_water_world":
            e_fx.angles = vectorscale( ( 0, 0, -1 ), 90.0 );
            e_fx thread watch_for_crystal_pickup( s_crystal, "crystal_water_fx" );
            break;
    }
}

watch_for_crystal_pickup( s_crystal, str_fx )
{
    self setclientfield( str_fx, 1 );
    s_crystal.piecespawn waittill( "pickup" );
    self playsound( "evt_crystal" );
    level.n_crystals_pickedup++;
    self setclientfield( str_fx, 0 );
    self delete();
}

crystal_dropped( s_crystal )
{
    flag_wait( "start_zombie_round_logic" );
    s_crystal.piecespawn waittill( "piece_released" );
    level.n_crystals_pickedup--;
    level thread crystal_play_glow_fx( s_crystal );
}

place_staff_in_charger()
{
    self.charge_trigger = spawn( "trigger_radius_use", self.charger.origin, 0, 100, 100 );
    self.charge_trigger usetriggerrequirelookat();
    self.charge_trigger triggerignoreteam();
    self.charge_trigger setcursorhint( "HINT_NOICON" );
    dropoff_message = self staff_get_insert_message();
    self.charge_trigger sethintstring( dropoff_message );
    waittill_staff_inserted();
}

waittill_staff_inserted()
{
    while ( true )
    {
        self.charge_trigger waittill( "trigger", player );
        weapon_available = 1;

        if ( isdefined( player ) )
        {
            weapon_available = player hasweapon( self.weapname );

            if ( weapon_available )
                player takeweapon( self.weapname );

            self.n_ammo = player getweaponammoclip( self.weapname );
        }
        else
            self.n_ammo = 50;

        if ( weapon_available )
        {
            self.charger.is_inserted = 1;
            maps\mp\zm_tomb_craftables::clear_player_staff( self.weapname );
            self.charge_trigger setinvisibletoall();
            self moveto( self.charger.origin + vectorscale( ( 0, 0, 1 ), 19.0 ), 0.05 );
            self waittill( "movedone" );
            self show();
            return;
        }
    }
}

zombie_spawn_func()
{
    self.actor_killed_override = ::zombie_killed_override;
}

zombie_killed_override( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime )
{
    if ( isplayer( attacker ) || sweapon == "one_inch_punch_zm" )
    {
        if ( !flag( "fire_puzzle_1_complete" ) )
            maps\mp\zm_tomb_quest_fire::sacrifice_puzzle_zombie_killed( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime );

        foreach ( staff in level.a_elemental_staffs )
        {
            if ( !staff.charger.is_charged && staff.charger.is_inserted )
            {
                if ( self istouching( staff.vol_chamber ) )
                {
                    staff.charger.charges_received++;
                    staff.charger thread zombie_staff_charger_death( self );
                }
            }
        }

        foreach ( staff_upgraded in level.a_elemental_staffs_upgraded )
        {
            if ( self istouching( staff_upgraded.vol_chamber ) && staff_upgraded.charger.is_inserted )
                staff_upgraded.charger thread zombie_staff_charger_death( self );
        }
    }
}

zombie_staff_charger_death( ai_zombie )
{
    target_tag = "J_SpineUpper";
    e_fx = spawn( "script_model", ai_zombie gettagorigin( target_tag ) );
    e_fx setmodel( "tag_origin" );
    wait 1;
    e_fx playsoundontag( "evt_soul_release", "tag_origin" );
    playfxontag( level._effect["staff_soul"], e_fx, "tag_origin" );
    e_fx moveto( self.origin + vectorscale( ( 0, 0, 1 ), 16.0 ), 0.5 );
    e_fx waittill( "movedone" );
    self notify( "soul_received" );
    e_fx playsoundontag( "evt_soul_impact", "tag_origin" );
    playfxontag( level._effect["staff_charge"], e_fx, "tag_origin" );
    wait 0.3;
    e_fx delete();
}

staff_charger_check()
{
    self.charger.is_charged = 0;
    flag_wait( self.weapname + "_upgrade_unlocked" );

    while ( true )
    {
        if ( self.charger.charges_received >= 20 || getdvarint( #"_id_FA81816F" ) >= 2 && self.charger.is_inserted )
        {
            wait 0.5;
            self.charger.is_charged = 1;
            level setclientfield( self.quest_clientfield, 4 );
            self thread staff_charger_done( self.element );
            self thread staff_sound();
            level.staffs_charged++;
            break;
        }

        wait 1;
    }
}

staff_sound()
{
    self playsound( "evt_souls_full" );
    self playloopsound( "evt_souls_full_loop", 0.1 );
    level waittill( "stop_staff_sound" );
    self stoploopsound( 0.1 );
}

staff_charger_done( str_element )
{
    switch ( str_element )
    {
        case "air":
            level thread spawn_upgraded_staff_triggers( 0 );
            level thread maps\mp\zm_tomb_teleporter::stargate_teleport_think( 1 );
            level thread maps\mp\zm_tomb_teleporter::teleporter_active_fx( 1 );
            flag_set( "air_done" );
            break;
        case "fire":
            level thread spawn_upgraded_staff_triggers( 1 );
            level thread maps\mp\zm_tomb_teleporter::stargate_teleport_think( 2 );
            level thread maps\mp\zm_tomb_teleporter::teleporter_active_fx( 2 );
            flag_set( "fire_done" );
            break;
        case "lightning":
            level thread spawn_upgraded_staff_triggers( 2 );
            level thread maps\mp\zm_tomb_teleporter::stargate_teleport_think( 4 );
            level thread maps\mp\zm_tomb_teleporter::teleporter_active_fx( 4 );
            flag_set( "lightning_done" );
            break;
        case "water":
            level thread spawn_upgraded_staff_triggers( 3 );
            level thread maps\mp\zm_tomb_teleporter::stargate_teleport_think( 3 );
            level thread maps\mp\zm_tomb_teleporter::teleporter_active_fx( 3 );
            flag_set( "water_done" );
            break;
    }
}

spawn_upgraded_staff_triggers( n_index )
{
    e_staff_standard = level.a_elemental_staffs[n_index];
    e_staff_standard_upgraded = level.a_elemental_staffs_upgraded[n_index];
    e_staff_standard.charge_trigger setvisibletoall();
    e_staff_standard.charge_trigger usetriggerrequirelookat();
    e_staff_standard.charge_trigger triggerignoreteam();
    e_staff_standard.charge_trigger setcursorhint( "HINT_NOICON" );
    pickup_message = e_staff_standard staff_get_pickup_message();
    e_staff_standard.charge_trigger sethintstring( pickup_message );
    e_staff_standard ghost();
    e_staff_standard_upgraded.trigger = e_staff_standard.charge_trigger;
    e_staff_standard_upgraded moveto( e_staff_standard.origin, 0.05 );
    e_staff_standard_upgraded waittill( "movedone" );
    e_staff_standard_upgraded.angles = e_staff_standard.angles;
    e_staff_standard_upgraded show();
    e_fx = spawn( "script_model", e_staff_standard_upgraded.origin );
    e_fx setmodel( "tag_origin" );
    wait 0.6;
    playfxontag( level._effect["air_glow"], e_fx, "tag_origin" );
    e_staff_standard_upgraded watch_for_player_pickup_staff();
    e_staff_standard_upgraded.trigger setinvisibletoall();
    player = e_staff_standard_upgraded.owner;
    e_fx delete();

    while ( true )
    {
        if ( e_staff_standard.charger.is_charged )
        {
            e_staff_standard_upgraded thread staff_upgraded_reload_monitor( player );
            break;
        }

        wait_network_frame();
    }
}

staff_upgraded_reload_monitor( player )
{
    player endon( "disconnect" );

    while ( true )
    {
        place_staff_in_charger();
        self thread staff_upgraded_reload( player );
        self watch_for_player_pickup_staff();
        self.trigger setinvisibletoall();
        self.charger.is_inserted = 0;

        if ( self.n_ammo )
        {
            self.n_ammo = int( min( 100, self.n_ammo ) );
            player setweaponammoclip( self.weapname, self.n_ammo );
        }
    }
}

staff_upgraded_reload( player )
{
    player endon( "disconnect" );
    self endon( "staff_equip" );
    n_count = int( 5.0 );
    b_reloaded = 0;

    while ( true )
    {
        self.charger waittill( "soul_received" );
        self.n_ammo = self.n_ammo + n_count;

        if ( self.n_ammo > 100 )
            self.n_ammo = 100;

        if ( !b_reloaded )
        {
            self.trigger setvisibletoall();
            b_reloaded = 1;
        }
    }
}

giant_robot_head_teleport_timeout()
{
    self endon( "teleport" );
    self endon( "disconnect" );
    a_weapons = self getweaponslistprimaries();
    n_weapons = a_weapons.size;
    wait 30;
    a_weapons = self getweaponslistprimaries();

    while ( n_weapons != a_weapons.size )
    {
        a_weapons = self getweaponslistprimaries();
        wait 0.05;
    }

    self.teleport_origin = spawn( "script_origin", self.origin );
    self.teleport_origin.angles = self.angles;
    self linkto( self.teleport_origin );
    self freezecontrols( 1 );
    wait_network_frame();
    self unlink();
    self.teleport_origin delete();
    self.teleport_origin = undefined;
    self setorigin( self.teleport_initial_origin );
    self setplayerangles( self.angles );
    self enableweapons();
    self enableoffhandweapons();
    self freezecontrols( 0 );
}
