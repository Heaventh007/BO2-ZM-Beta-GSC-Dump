// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\zombies\_zm_spawner;

tank_precache()
{

}

init()
{
    registerclientfield( "vehicle", "mortar_firing", 14000, 2, "int" );
    registerclientfield( "scriptmover", "mortar_landing", 14000, 2, "int" );
    registerclientfield( "vehicle", "tank_tread_fx", 14000, 1, "int" );
    tank_precache();
    level.enemy_location_override_func = ::enemy_location_override;
    level.adjust_enemyoverride_func = ::adjust_enemyoverride;
    level.zm_mantle_over_40_move_speed_override = ::zm_mantle_over_40_move_speed_override;
    level.vh_tank = getent( "tank", "targetname" );
    level.vh_tank tank_setup();
    level.vh_tank thread tankuseanimtree();
}

zm_mantle_over_40_move_speed_override()
{
    traversealias = "barrier_walk";

    switch ( self.zombie_move_speed )
    {
        case "chase_bus":
            traversealias = "barrier_sprint";
            break;
        default:
/#
            assertmsg( "Zombie move speed of '" + self.zombie_move_speed + "' is not supported for mantle_over_40." );
#/
    }

    return traversealias;
}

#using_animtree("zm_tomb_tank");

init_animtree()
{
    scriptmodelsuseanimtree( #animtree );
}

tankuseanimtree()
{
    self useanimtree( #animtree );
}

tank_setup()
{
    self ent_flag_init( "tank_moving" );
    self ent_flag_init( "tank_activated" );
    self.tag_occupied = [];
    self.health = 1000;
    self.n_players_on = 0;
    self.chase_pos_time = 0;
    self hidepart( "tag_flamethrower" );
    self setmovingplatformenabled( 1 );
    self.e_roof = getent( "vol_on_tank_watch", "targetname" );
    self.e_roof enablelinkto();
    self.e_roof linkto( self );
    self.t_use = getent( "trig_use_tank", "targetname" );
    self.t_use enablelinkto();
    self.t_use linkto( self );
    self.t_use sethintstring( &"ZM_TOMB_Press_X_to_activate_tank" );
    m_zombie_fence = getent( "tank_zombie_fence", "targetname" );
    m_zombie_fence enablelinkto();
    m_zombie_fence linkto( self );
    self.m_tank_path_blocker = getent( "tank_path_blocker", "targetname" );
    self.m_tank_path_blocker enablelinkto();
    self.m_tank_path_blocker linkto( self );
    a_tank_jump_down_spots = getentarray( "tank_jump_down_spots", "script_noteworthy" );

    foreach ( e_jump_down_spot in a_tank_jump_down_spots )
        e_jump_down_spot linkto( self );

    self thread players_on_tank_update();
    self thread tank_tag_pulse();
    self thread tank_station();
    self thread tank_turrets();
    self thread tank_main_turret();
    self thread do_mortar();
    self thread do_treadfx();
    self playloopsound( "zmb_tomb_tank_loop", 2 );
}

do_treadfx()
{
    self endon( "death" );

    while ( true )
    {
        self ent_flag_wait( "tank_moving" );
        self setclientfield( "tank_tread_fx", 1 );
        self ent_flag_waitopen( "tank_moving" );
        self setclientfield( "tank_tread_fx", 0 );
    }
}

do_mortar()
{
    tank_target_origin = spawn( "script_model", ( 0, 0, 0 ) );
    tank_target_origin setmodel( "tag_origin" );

    while ( true )
    {
        self ent_flag_wait( "tank_moving" );
        zombies = getaiarray( "axis" );
        target = self pick_optimal_targets( zombies );

        if ( isdefined( target ) )
        {
            tank_target_origin.origin = target.origin;
            firing_wait = randomfloatrange( 0.5, 1 );
            self setclientfield( "mortar_firing", 1 );
            wait 3;

            if ( isdefined( target ) && distancesquared( target.origin, self.origin ) > 90000 )
            {
                tank_target_origin.origin = target.origin;
                tank_target_origin setclientfield( "mortar_landing", 1 );
                radiusdamage( target.origin, 300, 2000, 1000, undefined, "MOD_EXPLOSIVE", "zombie_markiv_turret" );
            }
            else if ( distancesquared( tank_target_origin.origin, self.origin ) > 90000 )
            {
                tank_target_origin setclientfield( "mortar_landing", 1 );
                radiusdamage( tank_target_origin.origin, 300, 2000, 1000, undefined, "MOD_EXPLOSIVE", "zombie_markiv_turret" );
            }

            wait 2;
            tank_target_origin setclientfield( "mortar_landing", 0 );
            self setclientfield( "mortar_firing", 0 );
            wait( randomfloatrange( 7.0, 10.0 ) );
        }

        wait 2;
    }
}

disconnect_reconnect_paths( vh_tank )
{
    self endon( "death" );

    while ( true )
    {
        self disconnectpaths();
        wait 1;

        while ( vh_tank getspeedmph() < 1 )
            wait 0.05;

        self connectpaths();
        wait 0.5;
    }
}

players_on_tank_update()
{
    flag_wait( "start_zombie_round_logic" );
    self.m_tank_path_blocker thread tank_disconnect_paths( self );
    a_players = getplayers();

    foreach ( e_player in a_players )
        e_player.b_already_on_tank = 0;

    while ( true )
    {
        a_players = getplayers();

        foreach ( e_player in a_players )
        {
            if ( is_player_valid( e_player ) )
            {
                if ( isdefined( e_player.b_already_on_tank ) && !e_player.b_already_on_tank && e_player entity_on_tank() )
                {
                    e_player.b_already_on_tank = 1;
                    self.n_players_on++;
                    continue;
                }

                if ( isdefined( e_player.b_already_on_tank ) && e_player.b_already_on_tank && !e_player entity_on_tank() )
                {
                    e_player.b_already_on_tank = 0;
                    self.n_players_on--;
                }
            }
        }

        wait 0.05;
    }
}

entity_on_tank()
{
    if ( self istouching( level.vh_tank.e_roof ) )
        return true;

    return false;
}

tank_station()
{
    self thread tank_cost( 500 );
    self thread tank_movement();
    t_call_box_bunkers = getent( "call_box_bunkers", "script_noteworthy" );
    t_call_box_bunkers setinvisibletoall();
    self.t_use waittill( "trigger" );
    t_call_box_bunkers setvisibletoall();
    self.b_call_box_used = 0;
    a_call_boxes = getentarray( "trig_tank_station_call", "targetname" );

    foreach ( t_call_box in a_call_boxes )
    {
        t_call_box thread tank_call_box();
        t_call_box sethintstring( &"ZM_TOMB_Press_X_to_call_tank_to_position_Cost_500", 500 );
    }
}

tank_cost( n_tank_cost )
{
    while ( true )
    {
        self.t_use waittill( "trigger", e_player );

        if ( is_player_valid( e_player ) && e_player.score >= n_tank_cost )
        {
            self ent_flag_set( "tank_activated" );
            self ent_flag_set( "tank_moving" );
            e_player.score = e_player.score - n_tank_cost;
            self waittill( "tank_stop" );

            if ( isdefined( self.b_call_box_used ) && self.b_call_box_used )
            {
                self.b_call_box_used = 0;
                self activate_tank_wait_with_no_cost();
            }
        }
    }
}

activate_tank_wait_with_no_cost()
{
    self endon( "call_box_used" );
    self.t_use waittill( "trigger", e_player );
    self ent_flag_set( "tank_activated" );
    self ent_flag_set( "tank_moving" );
}

tank_call_box()
{
    while ( true )
    {
        self waittill( "trigger", e_player );

        if ( !level.vh_tank ent_flag( "tank_activated" ) )
        {
            level.vh_tank notify( "call_box_used" );
            level.vh_tank.b_call_box_used = 1;
            wait 0.05;
            level.vh_tank.t_use useby( e_player );
            level.vh_tank waittill( "tank_stop" );
        }
    }
}

tank_movement()
{
    n_path_start = getvehiclenode( "tank_start", "targetname" );
    self attachpath( n_path_start );
    self startpath();
    self thread follow_path( n_path_start );
    self setspeedimmediate( 0 );
    self.a_locations = array( "village", "bunkers" );
    n_location_index = 0;
    self.str_location_current = self.a_locations[n_location_index];
    t_call_box = getent( "call_box_" + self.str_location_current, "script_noteworthy" );
    t_call_box setinvisibletoall();

    while ( true )
    {
        self ent_flag_wait( "tank_activated" );
        iprintln( "The tank is moving." );
        self.m_tank_path_blocker thread tank_connect_paths( self );
        self playsound( "evt_tank_call" );
        self setspeedimmediate( 6 );
        self.t_use setinvisibletoall();
        t_call_box setvisibletoall();
        self thread tank_cooldown_timer();
        self waittill( "tank_stop" );
        self ent_flag_clear( "tank_moving" );
        self.m_tank_path_blocker thread tank_disconnect_paths( self );
        self setspeedimmediate( 0 );
        n_location_index++;

        if ( n_location_index == self.a_locations.size )
            n_location_index = 0;

        self.str_location_current = self.a_locations[n_location_index];
        t_call_box = getent( "call_box_" + self.str_location_current, "script_noteworthy" );
        t_call_box setinvisibletoall();
        self wait_for_tank_cooldown();
        self.t_use setvisibletoall();
        self ent_flag_clear( "tank_activated" );
    }
}

tank_disconnect_paths( vh_tank )
{
    self endon( "death" );

    while ( vh_tank getspeedmph() > 0 )
        wait 0.05;

    self disconnectpaths();
}

tank_connect_paths( vh_tank )
{
    self endon( "death" );
    self connectpaths();
}

tank_cooldown_timer()
{
    self.n_cooldown_timer = 0;
    str_location_original = self.str_location_current;

    while ( str_location_original == self.str_location_current )
    {
        self.n_cooldown_timer = self.n_cooldown_timer + self.n_players_on * 0.05;
        wait 0.05;
    }
}

wait_for_tank_cooldown()
{
    n_height = 200;

    if ( self.n_cooldown_timer < 2 )
        self.n_cooldown_timer = 2;
    else if ( self.n_cooldown_timer > 120 )
        self.n_cooldown_timer = 120;

    wait( self.n_cooldown_timer );
}

follow_path( n_path_start )
{
    self endon( "death" );
    assert( isdefined( n_path_start ), "vehicle_path() called without a path" );
    self notify( "newpath" );
    self endon( "newpath" );
    n_next_point = n_path_start;

    while ( isdefined( n_next_point ) )
    {
        self waittill( "reached_node", n_next_point );
        self.n_current = n_next_point;
        n_next_point notify( "trigger", self );

        if ( isdefined( n_next_point.script_noteworthy ) )
        {
            self notify( n_next_point.script_noteworthy );
            self notify( "noteworthy", n_next_point.script_noteworthy, n_next_point );
        }

        waittillframeend;
    }
}

tank_tag_array_setup()
{
    a_tank_tags = [];
    a_tank_tags[0] = spawnstruct();
    a_tank_tags[0].str_tag = "window_left_1_jmp_jnt";
    a_tank_tags[1] = spawnstruct();
    a_tank_tags[1].str_tag = "window_left_2_jmp_jnt";
    a_tank_tags[2] = spawnstruct();
    a_tank_tags[2].str_tag = "window_left_3_jmp_jnt";
    a_tank_tags[3] = spawnstruct();
    a_tank_tags[3].str_tag = "window_left_rear_jmp_jnt";
    a_tank_tags[4] = spawnstruct();
    a_tank_tags[4].str_tag = "window_right_1_jmp_jnt";
    a_tank_tags[5] = spawnstruct();
    a_tank_tags[5].str_tag = "window_right_2_jmp_jnt";
    a_tank_tags[6] = spawnstruct();
    a_tank_tags[6].str_tag = "window_right_3_jmp_jnt";
    a_tank_tags[7] = spawnstruct();
    a_tank_tags[7].str_tag = "window_right_front_jmp_jnt";
    return a_tank_tags;
}

get_players_on_tank()
{
    a_players_on_tank = [];
    a_players = getplayers();

    foreach ( e_player in a_players )
    {
        if ( is_player_valid( e_player ) && ( isdefined( e_player.b_already_on_tank ) && e_player.b_already_on_tank ) )
            a_players_on_tank[a_players_on_tank.size] = e_player;
    }

    return a_players_on_tank;
}

get_closest_tank_tag( target_org )
{
    best_dist = -1;
    best_tag = undefined;

    for ( i = 0; i < self.a_tank_tags.size; i++ )
    {
        tag_org = self gettagorigin( self.a_tank_tags[i].str_tag );
        dist = distancesquared( tag_org, target_org );

        if ( dist < best_dist || best_dist < 0 )
        {
            best_dist = dist;
            best_tag = tag_org;
        }
    }

    return best_tag;
}

tank_tag_pulse()
{
    a_tank_tags = tank_tag_array_setup();
    self.a_tank_tags = a_tank_tags;

    while ( true )
    {
        if ( self.n_players_on > 0 )
        {
            a_players_on_tank = get_players_on_tank();

            if ( a_players_on_tank.size == 0 )
            {
                wait 0.5;
                continue;
            }

            any_player_a_target = 0;

            foreach ( e_player in a_players_on_tank )
            {
                if ( !( isdefined( e_player.ignoreme ) && e_player.ignoreme ) )
                    any_player_a_target = 1;
            }

            if ( !any_player_a_target )
            {
                wait 0.5;
                continue;
            }

            a_zombies = get_round_enemy_array();
            num_zombies_on_tank = 0;

            foreach ( ai_zombie in a_zombies )
            {
                if ( isdefined( ai_zombie.b_on_tank ) && ai_zombie.b_on_tank )
                    num_zombies_on_tank++;
            }

            if ( num_zombies_on_tank >= 8 )
            {
                wait 0.5;
                continue;
            }

            a_zombie_jumpers = [];

            foreach ( ai_zombie in a_zombies )
            {
                foreach ( e_player in a_players_on_tank )
                {
                    if ( is_player_valid( ai_zombie.favoriteenemy ) && ai_zombie.favoriteenemy == e_player )
                    {
                        n_dist_from_tank = distancesquared( ai_zombie.origin, self.origin );

                        if ( n_dist_from_tank < 65536 )
                            a_zombie_jumpers[a_zombie_jumpers.size] = ai_zombie;

                        if ( !( isdefined( ai_zombie.b_get_to_tank ) && ai_zombie.b_get_to_tank ) )
                        {
                            s_tag_info = random( a_tank_tags );
                            ai_zombie.goalradius = 32;
                            ai_zombie.b_get_to_tank = 1;

                            if ( ai_zombie.has_legs )
                            {
                                if ( self ent_flag( "tank_moving" ) )
                                    ai_zombie set_zombie_run_cycle( "super_sprint" );

                                ai_zombie thread zombie_chasing_tank_turn_crawler();
                                ai_zombie thread update_zombie_goal_pos( s_tag_info.str_tag );
                                ai_zombie thread zombie_reset_after_player_off_tank( a_tank_tags );
                                wait 0.1;
                                ai_zombie notify( "stop_find_flesh" );
                            }
                        }
                    }
                }
            }

            a_closest_zombies = get_array_of_closest( self.origin, a_zombie_jumpers, undefined, 6 );
            a_zombie_jumpers = a_closest_zombies;

            if ( a_zombie_jumpers.size > 0 )
            {
                foreach ( ai_zombie in a_zombie_jumpers )
                {
                    a_dist_possible = [];

                    foreach ( s_tank_tag in a_tank_tags )
                    {
                        v_tag_origin = self gettagorigin( s_tank_tag.str_tag );
                        n_dist = distance2dsquared( v_tag_origin, ai_zombie.origin );
                        s_dist_from_tag = spawnstruct();
                        s_dist_from_tag.str_tag = s_tank_tag.str_tag;
                        s_dist_from_tag.n_dist = n_dist;
                        a_dist_possible[a_dist_possible.size] = s_dist_from_tag;
                    }

                    ai_zombie.a_dist = sort_dist_closest_to_farthest( a_dist_possible );
                }

                assign_zombies_to_tag( a_zombie_jumpers );
            }
        }

        wait 0.05;
    }
}

update_zombie_goal_pos( str_position )
{
    self notify( "change_goal" );
    self endon( "death" );
    self endon( "goal" );
    self endon( "near_goal" );
    self endon( "change_goal" );
    e_script_origin = getent( str_position, "targetname" );

    while ( true )
    {
        if ( isdefined( e_script_origin ) )
            v_origin = e_script_origin.origin;
        else
            v_origin = level.vh_tank gettagorigin( str_position );

        self setgoalpos( v_origin );
        wait 0.05;
    }
}

zombie_reset_after_player_off_tank( a_tank_tags )
{
    self endon( "death" );
    self thread zombie_changed_favorite_enemy( self.favoriteenemy );
    self.favoriteenemy waittill_player_off_tank( self );

    if ( isdefined( self.b_on_tank ) && self.b_on_tank )
        self tank_zombie_jump_down( a_tank_tags );

    self set_zombie_run_cycle( self.zombie_move_speed_original );
    self.b_get_to_tank = 0;
    self.b_on_tank = 0;
    self notify( "change_goal" );
    self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
}

zombie_chasing_tank_turn_crawler()
{
    self endon( "death" );

    while ( self.has_legs )
        wait 0.05;

    self set_zombie_run_cycle( self.zombie_move_speed_original );
}

zombie_changed_favorite_enemy( e_player_current )
{
    self endon( "death" );
    e_player_current endon( "disconnect" );
    e_player_current endon( "player_downed" );

    while ( is_player_valid( self.favoriteenemy ) && self.favoriteenemy == e_player_current )
        wait 0.05;

    self notify( "favorite_enemy_changed" );
}

waittill_player_off_tank( ai_zombie )
{
    self endon( "disconnect" );
    self endon( "player_downed" );
    ai_zombie endon( "death" );
    ai_zombie endon( "favorite_enemy_changed" );

    while ( isdefined( self.b_already_on_tank ) && self.b_already_on_tank )
        wait 0.05;
}

tank_mark_tag_occupied( str_tag, ai_occupier, set_occupied )
{
    current_occupier = self.tag_occupied[str_tag];

    if ( set_occupied )
    {
        if ( !isdefined( current_occupier ) )
        {
            self.tag_occupied[str_tag] = ai_occupier;
            return true;
        }
        else if ( ai_occupier == current_occupier || !isalive( current_occupier ) )
        {
            self.tag_occupied[str_tag] = ai_occupier;
            return true;
        }
        else
            return false;
    }
    else if ( !isdefined( current_occupier ) )
        return true;
    else if ( current_occupier != ai_occupier )
        return false;
    else
    {
        self.tag_occupied[str_tag] = undefined;
        return true;
    }
}

tank_zombie_jump_down( a_tank_tags )
{
    self endon( "death" );
    self.goalradius = 32;
    s_tag_info = random( a_tank_tags );
    str_tag = s_tag_info.str_tag;

    do
    {
        self update_zombie_goal_pos( str_tag + "_down_start" );
        tag_claimed = level.vh_tank tank_mark_tag_occupied( str_tag, self, 1 );
    }
    while (!tag_claimed );

    self linkto( level.vh_tank, str_tag );
    v_tag_origin = level.vh_tank gettagorigin( str_tag );
    v_tag_angles = level.vh_tank gettagangles( str_tag );
    self setgoalpos( v_tag_origin );
    str_anim_alias = str_tag;

    if ( !self.has_legs )
        str_anim_alias = str_anim_alias + "_crawler";

    n_anim_index = self getanimsubstatefromasd( "zm_tank_jump_down", str_anim_alias );
    self animscripted( v_tag_origin, v_tag_angles, "zm_tank_jump_down", n_anim_index );
    self zombieanimnotetrackthink( "tank_jump_down" );
    self unlink();
    level.vh_tank tank_mark_tag_occupied( str_tag, self, 0 );
}

sort_dist_closest_to_farthest( a_unsorted )
{
    a_sorted = [];
    n_array_size_final = a_unsorted.size;

    while ( a_sorted.size < n_array_size_final )
    {
        s_dist_lowest = a_unsorted[0];

        foreach ( s_dist_from_tag in a_unsorted )
        {
            if ( s_dist_from_tag.n_dist < s_dist_lowest.n_dist )
                s_dist_lowest = s_dist_from_tag;
        }

        a_sorted[a_sorted.size] = s_dist_lowest;
        arrayremovevalue( a_unsorted, s_dist_lowest );
    }

    return a_sorted;
}

assign_zombies_to_tag( a_zombies )
{
    for ( i = 0; i < 8; i++ )
    {
        if ( a_zombies.size > 0 )
        {
            ai_zombie_closest = a_zombies[0];

            foreach ( ai_zombie in a_zombies )
            {
                if ( ai_zombie.a_dist[0].n_dist < ai_zombie_closest.a_dist[0].n_dist )
                    ai_zombie_closest = ai_zombie;
            }

            ai_zombie_closest thread tank_zombie_jump_up();
            arrayremovevalue( a_zombies, ai_zombie_closest );

            foreach ( ai_zombie in a_zombies )
            {
                foreach ( s_dist_from_tag in ai_zombie.a_dist )
                {
                    if ( s_dist_from_tag.str_tag == ai_zombie_closest.a_dist[0].str_tag )
                    {
                        arrayremovevalue( ai_zombie.a_dist, s_dist_from_tag );
                        break;
                    }
                }
            }
        }
    }
}

tank_zombie_jump_up()
{
    self endon( "death" );

    if ( level.vh_tank ent_flag( "tank_moving" ) )
        self.goalradius = 64;
    else
        self.goalradius = 32;

    if ( !isdefined( self.b_on_tank ) || self.b_on_tank == 0 )
    {
        self.s_dist_from_tag = self.a_dist[0];
        str_tag = self.s_dist_from_tag.str_tag;
        self.b_on_tank = 1;

        do
        {
            self update_zombie_goal_pos( str_tag );
            tag_claimed = level.vh_tank tank_mark_tag_occupied( str_tag, self, 1 );
        }
        while (!tag_claimed );

        self linkto( level.vh_tank, str_tag );
        v_tag_origin = level.vh_tank gettagorigin( str_tag );
        v_tag_angles = level.vh_tank gettagangles( str_tag );
        str_anim_alias = str_tag;

        if ( !self.has_legs )
            str_anim_alias = str_anim_alias + "_crawler";

        n_anim_index = self getanimsubstatefromasd( "zm_tank_jump_up", str_anim_alias );
        self animscripted( v_tag_origin, v_tag_angles, "zm_tank_jump_up", n_anim_index );
        self zombieanimnotetrackthink( "tank_jump_up" );
        self unlink();
        level.vh_tank tank_mark_tag_occupied( str_tag, self, 0 );
        self setgoalpos( self.origin );
        self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
    }
}

zombieanimnotetrackthink( str_anim_notetrack_notify, chunk, node )
{
    self endon( "death" );

    while ( true )
    {
        self waittill( str_anim_notetrack_notify, str_notetrack );

        if ( str_notetrack == "end" )
            return;
    }
}

button_controls()
{
    e_player = undefined;

    while ( !isdefined( e_player ) )
    {
        e_player = get_players()[0];
        wait 1;
    }

    while ( true )
    {
        if ( e_player actionslotonebuttonpressed() )
        {
            level.vh_tank setspeedimmediate( 6 );

            while ( e_player actionslotonebuttonpressed() )
                wait 0.05;
        }

        if ( e_player actionslottwobuttonpressed() )
        {
            level.vh_tank setspeedimmediate( 0.0 );

            while ( e_player actionslottwobuttonpressed() )
                wait 0.05;
        }

        wait 0.05;
    }
}

tank_turrets()
{
    while ( true )
    {
        self ent_flag_wait( "tank_moving" );
        a_zombies = get_round_enemy_array();
        a_zombies = get_array_of_closest( self.origin, a_zombies );
        fired_at_zombie = 0;

        while ( a_zombies.size > 0 && !fired_at_zombie )
        {
            ai_zombie = random( a_zombies );
            arrayremovevalue( a_zombies, ai_zombie, 0 );

            if ( isalive( ai_zombie ) && isdefined( ai_zombie.ai_state ) && ai_zombie.ai_state == "find_flesh" )
                fired_at_zombie = self fire_side_turret_at_zombie( ai_zombie );

            wait_network_frame();
        }

        if ( fired_at_zombie )
            wait( randomfloatrange( 6.0, 8.0 ) );
        else
            wait( randomfloatrange( 2.5, 4.0 ) );
    }
}

tank_main_turret()
{
    while ( true )
    {
        self ent_flag_wait( "tank_moving" );
        a_zombies = get_round_enemy_array();
        a_zombies = get_array_of_closest( self.origin, a_zombies );

        if ( a_zombies.size > 0 )
        {
            for ( i = 0; i < a_zombies.size; i++ )
            {
                if ( isalive( a_zombies[i] ) )
                {
                    forward_dot = vectordot( anglestoforward( self.angles ), vectornormalize( a_zombies[i].origin - self.origin ) );

                    if ( forward_dot > 0.85 && distancesquared( self.origin, a_zombies[i].origin ) >= 150 * 150 )
                    {
                        self tank_fire_turret( 2, a_zombies[i] );
                        continue;
                    }
                }
            }
        }

        wait( randomfloatrange( 1.5, 2.0 ) );
    }
}

fire_side_turret_at_zombie( ai_zombie )
{
    n_min_dot = cos( 45 );
    n_min_dot_vert = cos( 15 );
    dist_sq = distancesquared( self.origin, ai_zombie.origin );

    if ( dist_sq >= 22500 )
    {
        v_to_zombie = ai_zombie.origin - self.origin;
        v_to_zombie_flat_horz = v_to_zombie;
        v_to_zombie_flat_horz = ( v_to_zombie_flat_horz[0], v_to_zombie_flat_horz[1], 0 );
        v_to_zombie_flat_horz = vectornormalize( v_to_zombie_flat_horz );
        v_to_zombie = vectornormalize( v_to_zombie );
        n_dot_off_vert = vectordot( v_to_zombie, v_to_zombie_flat_horz );

        if ( n_dot_off_vert >= n_min_dot_vert )
        {
            right_dot = vectordot( anglestoright( self.angles ), v_to_zombie );

            if ( right_dot > n_min_dot )
            {
                self tank_fire_turret( 0, ai_zombie );
                return true;
            }
            else if ( right_dot < -1 * n_min_dot )
            {
                self tank_fire_turret( 1, ai_zombie );
                return true;
            }
        }
    }

    return false;
}

tank_fire_turret( n_index, ai_zombie )
{
    self endon( "beyond_arc" );
    ai_zombie endon( "death" );

    if ( !self is_zombie_valid_target( n_index, ai_zombie ) )
        return;

    self setgunnerturretontargetrange( n_index, 15 );

    switch ( n_index )
    {
        case 0:
        case 1:
            self setgunnertargetent( ai_zombie, vectorscale( ( 0, 0, 1 ), 20.0 ), n_index );
            self waittill_any_or_timeout( 3.0, "gunner_turret_on_target" );

            if ( isalive( ai_zombie ) )
            {
                self notify( "fire_gun" );
                self firegunnerweapon( n_index );
            }

            break;
        default:
            self setturrettargetent( ai_zombie, vectorscale( ( 0, 0, 1 ), 20.0 ) );
            self waittill_any_or_timeout( 3.0, "turret_on_target" );

            if ( isalive( ai_zombie ) )
            {
                self notify( "fire_gun" );
                self fireweapon();
            }

            break;
    }

    wait 0.5;
    self clearturrettarget();
}

tank_turret_check_arc( n_index, ai_zombie )
{
    self endon( "fire_gun" );
    ai_zombie endon( "death" );

    while ( true )
    {
        right_dot = vectordot( anglestoright( self.angles ), vectornormalize( ai_zombie.origin - self.origin ) );

        if ( distancesquared( self.origin, ai_zombie.origin ) < 250 * 250 )
        {
            self notify( "beyond_arc" );
            break;
        }

        if ( n_index == 0 )
        {
            if ( right_dot <= 0.4 )
            {
                self notify( "beyond_arc" );
                break;
            }
        }
        else if ( n_index == 1 )
        {
            if ( right_dot >= -0.5 )
            {
                self notify( "beyond_arc" );
                break;
            }
        }
        else if ( right_dot >= 0.6 || right_dot <= -0.4 )
        {
            self notify( "beyond_arc" );
            break;
        }

        wait 0.1;
    }
}

is_zombie_valid_target( n_index, ai_zombie )
{
    if ( n_index > 1 )
        v_tag_origin = self gettagorigin( "tag_flash" );
    else
        v_tag_origin = self gettagorigin( "tag_flash_gunner" + ( n_index + 1 ) );

    if ( sighttracepassed( v_tag_origin, ai_zombie getcentroid(), 1, self ) )
        return true;

    return false;
}

enemy_location_override()
{
    self endon( "death" );
    enemy = self.favoriteenemy;
    location = enemy.origin;
    tank = level.vh_tank;

    if ( isdefined( self.item ) )
        return self.origin;

    if ( is_true( self.reroute ) )
    {
        if ( isdefined( self.reroute_origin ) )
            location = self.reroute_origin;
    }

    if ( isdefined( enemy.b_already_on_tank ) && enemy.b_already_on_tank && !( isdefined( self.solo_revive_exit ) && self.solo_revive_exit ) )
    {
        if ( !( isdefined( self.b_on_tank ) && self.b_on_tank ) )
        {
            if ( isdefined( tank.ismoving ) && tank.ismoving )
            {
                self.ignoreall = 1;

                if ( isdefined( self.close_to_tank ) && self.close_to_tank )
                {
                    self.goalradius = 2;
                    location = groundpos_ignore_water_new( location + vectorscale( ( 0, 0, 1 ), 60.0 ) );
                }
                else
                {
                    self.goalradius = 32;

                    if ( gettime() != tank.chase_pos_time )
                    {
                        tank.chase_pos_time = gettime();
                        tank.chase_pos_index = 0;
                        tank_forward = vectornormalize( anglestoforward( level.vh_tank.angles ) );
                        tank_right = vectornormalize( anglestoright( level.vh_tank.angles ) );
                        tank.chase_pos = [];
                        tank.chase_pos[0] = level.vh_tank.origin + vectorscale( tank_forward, -164 );
                        tank.chase_pos[1] = tank.chase_pos[0] + vectorscale( tank_right, 64 );
                        tank.chase_pos[2] = tank.chase_pos[0] + vectorscale( tank_right, -64 );

                        foreach ( pos in tank.chase_pos )
                            pos = groundpos_ignore_water_new( pos + vectorscale( ( 0, 0, 1 ), 60.0 ) );
                    }

                    location = tank.chase_pos[tank.chase_pos_index];
                    tank.chase_pos_index++;

                    if ( tank.chase_pos_index >= 3 )
                        tank.chase_pos_index = 0;

                    dist_sq = distancesquared( self.origin, location );

                    if ( dist_sq < 4096 )
                        self.close_to_tank = 1;
                }

                return location;
            }

            self.close_to_tank = 0;

            if ( isdefined( tank.doorsclosed ) && tank.doorsclosed )
            {
                self.ignoreall = 1;
                self.goalradius = 2;
            }
            else
            {
                front_dist = distance2dsquared( enemy.origin, level.vh_tank.origin );
                back_dist = distance2dsquared( enemy.origin, level.vh_tank.origin );

                if ( front_dist < back_dist )
                    location = level.vh_tank.origin;
                else
                    location = level.vh_tank.origin;

                self.ignoreall = 0;
                self.goalradius = 32;
            }
        }
    }

    return location;
}

adjust_enemyoverride()
{
    self endon( "death" );
    location = self.enemyoverride[0];
    tank = level.vh_tank;
    ent = self.enemyoverride[1];

    if ( isdefined( ent ) )
    {
        if ( isdefined( ent.b_already_on_tank ) && ent.b_already_on_tank )
        {
            if ( isdefined( self.b_on_tank ) && self.b_on_tank )
                self.goalradius = 32;
        }
    }

    return location;
}

closest_player_tank( origin, players )
{
    if ( isdefined( level.vh_tank ) && level.vh_tank.n_players_on > 0 || !( isdefined( level.calc_closest_player_using_paths ) && level.calc_closest_player_using_paths ) )
        player = getclosest( origin, players );
    else
        player = get_closest_player_using_paths( origin, players );

    if ( isdefined( player ) )
        return player;
}

pick_optimal_targets( zombie_array )
{
    optimal_target = [];
    n_max_dot = -1 * cos( 60 );

    foreach ( e_zombie in zombie_array )
    {
        distance = distancesquared( self.origin, e_zombie.origin );

        if ( distance > 2250000 || distance < 90000 )
            continue;

        v_to_target = vectornormalize( e_zombie.origin - self.origin );
        v_fwd = anglestoforward( self.angles );
        n_dot = vectordot( v_to_target, v_fwd );

        if ( n_dot > n_max_dot )
            continue;

        optimal_target[optimal_target.size] = e_zombie;
    }

    if ( optimal_target.size == 0 )
        return undefined;
    else if ( optimal_target.size == 1 )
        return optimal_target[0];

    return random( optimal_target );
}

zombie_on_tank_death_animscript_callback( inflictor, attacker, damage, flags, meansofdeath, weapon, vpoint, vdir, shitloc, psoffsettime, boneindex )
{
    if ( isdefined( self.exploding ) && self.exploding )
    {
        self notify( "killanimscript" );
        self maps\mp\zombies\_zm_spawner::reset_attack_spot();
        return true;
    }

    if ( isdefined( self ) )
    {
        level maps\mp\zombies\_zm_spawner::zombie_death_points( self.origin, meansofdeath, shitloc, attacker, self );
        launchvector = undefined;
        self thread maps\mp\zombies\_zm_spawner::zombie_ragdoll_then_explode( launchvector, attacker );
        self notify( "killanimscript" );
        self maps\mp\zombies\_zm_spawner::reset_attack_spot();
        return true;
    }

    return false;
}
