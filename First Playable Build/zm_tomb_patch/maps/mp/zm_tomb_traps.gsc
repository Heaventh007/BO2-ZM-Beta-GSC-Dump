// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\animscripts\zm_death;
#include maps\mp\_visionset_mgr;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_mgturret;

flame_traps_precache()
{
    precacheshellshock( "lava" );
    precacheshellshock( "lava_small" );
    precachemodel( "zombie_zapper_cagelight_red" );
    precachemodel( "zombie_zapper_cagelight_green" );
    flag_init( "flame_trap_active" );
}

init_flame_trap_trigs()
{
    flame_traps_precache();
    level.zm_transit_burn_max_duration = 2;

    if ( !isdefined( level.vsmgr_prio_overlay_zm_transit_burn ) )
        level.vsmgr_prio_overlay_zm_transit_burn = 20;

    maps\mp\_visionset_mgr::vsmgr_register_info( "overlay", "zm_transit_burn", 14000, level.vsmgr_prio_overlay_zm_transit_burn, 15, 1, maps\mp\_visionset_mgr::vsmgr_duration_lerp_thread_per_player, 0 );
    a_flame_trap_mkiv = getentarray( "flame_trap_mkiv", "targetname" );
    array_thread( a_flame_trap_mkiv, ::hide_markiv_parts );
    a_flame_trap_trigs = getentarray( "trig_flame_trap", "targetname" );
    array_thread( a_flame_trap_trigs, ::flame_trap_think );
}

hide_markiv_parts()
{
    self hidepart( "tag_gunner_turret1_base" );
    self hidepart( "tag_gunner_turret1" );
    self hidepart( "tag_gunner_barrel1" );
    self hidepart( "tag_gunner_barrel3" );
    self hidepart( "tag_fiftycal_base" );
    self hidepart( "tag_gunner_turret3" );
}

flame_trap_hint_string( str_string )
{
    if ( str_string == &"ZOMBIE_BUTTON_BUY_TRAP" )
    {
        if ( !( isdefined( self.is_locked ) && self.is_locked ) && !flag( "flame_trap_active" ) )
        {
            self.zombie_cost = 1250;
            self.in_use = 0;
            self sethintstring( str_string );
        }
    }
    else
        self sethintstring( str_string );
}

flame_trap_think()
{
    self sethintstring( "" );
    self setcursorhint( "HINT_NOICON" );
    self.is_available = 1;
    self.zombie_cost = 1000;
    self.in_use = 0;
    zapper_light_red( "trap_light_tank" );
    a_triggers = getentarray( self.targetname, "targetname" );

    while ( true )
    {
        array_thread( a_triggers, ::flame_trap_hint_string, &"ZOMBIE_BUTTON_BUY_TRAP" );
        self waittill( "trigger", who );

        if ( isdefined( self.is_locked ) && self.is_locked )
            continue;

        if ( flag( "flame_trap_active" ) )
            continue;

        if ( who in_revive_trigger() )
            continue;

        if ( !isdefined( self.is_available ) )
            continue;

        if ( is_player_valid( who ) )
        {
            if ( who.score >= self.zombie_cost )
            {
                if ( !self.in_use )
                {
                    self.in_use = 1;
                    flag_set( "flame_trap_active" );
                    play_sound_at_pos( "purchase", who.origin );
                    self thread flame_trap_move_switch( self );
                    self waittill( "switch_activated" );
                    who minus_to_player_score( self.zombie_cost );
                    array_thread( a_triggers, ::flame_trap_hint_string, &"ZOMBIE_TRAP_ACTIVE" );
                    self.zombie_dmg_trig = getent( self.target, "targetname" );
                    self.zombie_dmg_trig trigger_on();
                    self thread activate_flame_trap();
                    self waittill( "elec_done" );
                    clientnotify( self.script_string + "off" );

                    if ( isdefined( self.fx_org ) )
                        self.fx_org delete();

                    if ( isdefined( self.zapper_fx_org ) )
                        self.zapper_fx_org delete();

                    if ( isdefined( self.zapper_fx_switch_org ) )
                        self.zapper_fx_switch_org delete();

                    self.zombie_dmg_trig trigger_off();
                    array_thread( a_triggers, ::flame_trap_hint_string, &"ZOMBIE_TRAP_COOLDOWN" );
                    wait 25;
                    self notify( "available" );
                    self.in_use = 0;
                    flag_clear( "flame_trap_active" );
                }
            }
        }
    }
}

flame_trap_move_switch( parent )
{
    m_switch = getent( "trap_handle_" + parent.script_linkto, "targetname" );
    zapper_light_red( "trap_light_tank" );
    m_switch rotatepitch( -180, 0.5 );
    m_switch waittill( "rotatedone" );
    playfxontag( level._effect["switch_sparks"], m_switch, "tag_origin" );
    self notify( "switch_activated" );
    self waittill( "available" );
    m_switch rotatepitch( 180, 0.5 );
    zapper_light_green( "trap_light_tank" );
}

zapper_light_red( str_light_name )
{
    a_zapper_lights = getentarray( str_light_name, "targetname" );

    for ( i = 0; i < a_zapper_lights.size; i++ )
    {
        a_zapper_lights[i] setmodel( "zombie_zapper_cagelight_red" );

        if ( isdefined( a_zapper_lights[i].fx ) )
            a_zapper_lights[i].fx delete();

        a_zapper_lights[i].fx = maps\mp\zombies\_zm_net::network_safe_spawn( "trap_light_red", 2, "script_model", a_zapper_lights[i].origin );
        a_zapper_lights[i].fx setmodel( "tag_origin" );
        a_zapper_lights[i].fx.angles = a_zapper_lights[i].angles + vectorscale( ( -1, 0, 0 ), 90.0 );
        playfxontag( level._effect["zapper_light_notready"], a_zapper_lights[i].fx, "tag_origin" );
    }
}

zapper_light_green( str_light_name )
{
    a_zapper_lights = getentarray( str_light_name, "targetname" );

    for ( i = 0; i < a_zapper_lights.size; i++ )
    {
        a_zapper_lights[i] setmodel( "zombie_zapper_cagelight_green" );

        if ( isdefined( a_zapper_lights[i].fx ) )
            a_zapper_lights[i].fx delete();

        a_zapper_lights[i].fx = maps\mp\zombies\_zm_net::network_safe_spawn( "trap_light_green", 2, "script_model", a_zapper_lights[i].origin );
        a_zapper_lights[i].fx setmodel( "tag_origin" );
        a_zapper_lights[i].fx.angles = a_zapper_lights[i].angles + vectorscale( ( -1, 0, 0 ), 90.0 );
        playfxontag( level._effect["zapper_light_ready"], a_zapper_lights[i].fx, "tag_origin" );
    }
}

activate_flame_trap()
{
    clientnotify( self.target );
    a_fire_points = getstructarray( self.target, "targetname" );

    for ( i = 0; i < a_fire_points.size; i++ )
    {
        wait_network_frame();
        a_fire_points[i] thread flame_trap_fx( self );
    }

    self.zombie_dmg_trig thread flame_barrier_damage();
    level waittill( "arc_done" );
    self.zombie_dmg_trig thread flame_barrier_damage();
}

flame_trap_fx( notify_ent )
{
    self.vec_tag_origin = spawn( "script_model", self.origin );

    if ( isdefined( self.script_sound ) )
        self.vec_tag_origin playsound( "wpn_zmb_tank_trap_flame_start" );

    wait 1;

    if ( isdefined( self.script_sound ) )
        self.vec_tag_origin playloopsound( "wpn_zmb_tank_trap_flame_loop", 0.2 );

    wait 25;

    if ( isdefined( self.script_sound ) )
    {
        self.vec_tag_origin playsound( "wpn_zmb_tank_trap_flame_stop" );
        self.vec_tag_origin stoploopsound( 0.7 );
        wait 1;
        self.vec_tag_origin playsound( "wpn_zmb_tank_trap_flame_last" );
    }

    self.vec_tag_origin delete();
    notify_ent notify( "elec_done" );
    level notify( "arc_done" );
}

flame_barrier_damage()
{
    while ( true )
    {
        self waittill( "trigger", ent );

        if ( isplayer( ent ) )
            ent thread player_flame_damage( self );
        else
        {
            if ( isdefined( ent.is_mechz ) && ent.is_mechz )
                continue;

            if ( !isdefined( ent.b_marked_for_death ) )
            {
                ent.b_marked_for_death = 1;
                ent thread zombie_flame_death( randomint( 100 ) );
            }
        }
    }
}

zombie_flame_death( n_flame_chance )
{
    self endon( "death" );
    level.burning_zombies[level.burning_zombies.size] = self;
    self thread zombie_flame_watch();
    self playsound( "zmb_ignite" );
    self thread flame_death_fx();
    wait( randomfloat( 2.5 ) );
    self dodamage( self.health + 666, self.origin );
}

zombie_flame_watch()
{
    self waittill( "death" );
    self stoploopsound();
    arrayremovevalue( level.burning_zombies, self );
}

player_flame_damage( trig_damage )
{
    self endon( "zombified" );
    self endon( "death" );
    self endon( "disconnect" );
    n_player_dmg = 45;
    n_jugga_dmg = 45;
    n_burn_time = 1.5;

    if ( isdefined( self.is_zombie ) && self.is_zombie )
        return;

    self thread player_stop_burning();

    if ( !isdefined( self.is_burning ) && is_player_valid( self ) )
    {
        self.is_burning = 1;
        maps\mp\_visionset_mgr::vsmgr_activate( "overlay", "zm_transit_burn", self, n_burn_time, level.zm_transit_burn_max_duration );
        self notify( "burned" );

        if ( !self hasperk( "specialty_armorvest" ) )
        {
            radiusdamage( self.origin, 10, n_player_dmg, n_player_dmg );
            wait 0.5;
            self.is_burning = undefined;
        }
        else
        {
            if ( self hasperk( "specialty_armorvest" ) )
                self dodamage( n_jugga_dmg, self.origin );
            else
                self dodamage( 1, self.origin );

            wait 0.5;
            self.is_burning = undefined;
        }
    }
}

player_stop_burning()
{
    self notify( "player_stop_burning" );
    self endon( "player_stop_burning" );
    self endon( "death_or_disconnect" );
    self waittill( "zombified" );
    self notify( "stop_flame_damage" );
    maps\mp\_visionset_mgr::vsmgr_deactivate( "overlay", "zm_transit_burn", self );
}

player_burning_fx()
{
    self endon( "death" );

    if ( isdefined( self.is_on_fire ) && self.is_on_fire )
        return;

    if ( !( isdefined( self.no_burning_sfx ) && self.no_burning_sfx ) )
        self thread player_burning_audio();

    self.is_on_fire = 1;
    self thread maps\mp\animscripts\zm_death::on_fire_timeout();

    if ( isdefined( level._effect ) && isdefined( level._effect["character_fire_death_sm"] ) )
        playfxontag( level._effect["character_fire_death_sm"], self, "J_SpineLower" );
}

player_burning_audio()
{
    e_fire_ent = spawn( "script_model", self.origin );
    wait_network_frame();
    e_fire_ent linkto( self );
    e_fire_ent playloopsound( "evt_plr_fire_loop" );
    self waittill_any( "stop_flame_damage", "stop_flame_sounds", "death", "discoonect" );
    e_fire_ent delete();
}

#using_animtree("fxanim_props_dlc4");

pillbox_precache()
{
    flag_init( "turret_active" );
    root = %root;
    i = %fxanim_zom_tomb_turret_activate_anim;
    i = %fxanim_zom_tomb_turret_deactivate_anim;
}

pillbox_turret_init()
{
    pillbox_precache();
    level.auto_turret_array = getentarray( "pillbox_turret_trigger", "targetname" );
    e_turret = getent( "pillbox_turret", "script_noteworthy" );
    e_turret ent_flag_init( "turret_is_active" );
    e_turret ghost();

    if ( !isdefined( level.auto_turret_array ) )
        return;

    level.curr_auto_turrets_active = 0;

    if ( !isdefined( level.max_auto_turrets_active ) )
        level.max_auto_turrets_active = 2;

    if ( !isdefined( level.auto_turret_cost ) )
        level.auto_turret_cost = 1500;

    if ( !isdefined( level.auto_turret_timeout ) )
        level.auto_turret_timeout = 30;

    for ( i = 0; i < level.auto_turret_array.size; i++ )
    {
        level.auto_turret_array[i] setcursorhint( "HINT_NOICON" );
        level.auto_turret_array[i] usetriggerrequirelookat();
        level.auto_turret_array[i].curr_time = -1;
        level.auto_turret_array[i].turret_active = 0;
        level.auto_turret_array[i].e_turret = e_turret;
        level.auto_turret_array[i] thread auto_turret_think();
    }
}

turret_hint_string( string )
{
    if ( !( isdefined( self.is_locked ) && self.is_locked ) )
    {
        if ( string == &"ZOMBIE_BUTTON_BUY_TRAP" )
        {
            if ( !self.e_turret ent_flag( "turret_is_active" ) )
            {
                self.zombie_cost = level.auto_turret_cost;
                self sethintstring( string, self.zombie_cost );
            }
        }
        else
            self sethintstring( string );
    }
}

set_state_hint_string()
{
    if ( !self.e_turret ent_flag( "turret_is_active" ) )
        self sethintstring( &"ZOMBIE_AUTO_TURRET", level.auto_turret_cost );
    else if ( self.e_turret.b_cooldown )
        self sethintstring( &"ZOMBIE_TRAP_COOLDOWN" );
    else
        self sethintstring( &"ZOMBIE_TRAP_ACTIVE" );
}

auto_turret_think()
{
    flag_wait( "capture_zones_init_done" );
    turret_array = getentarray( self.target, "targetname" );

    switch ( self.script_noteworthy )
    {
        case "mid_trench_turret_trigger":
            self.handle = getent( "mid_trench_turret_handle", "script_noteworthy" );
            break;
        case "tank_platform_turret_trigger":
            self.handle = getent( "tank_platform_turret_handle", "script_noteworthy" );
            break;
    }

    self.turret = getent( "pillbox_turret", "script_noteworthy" );
    self.e_turret.b_cooldown = 0;
    self.turret setdefaultdroppitch( -35 );

    if ( !isdefined( self.turret ) )
        return;

    self.turret setconvergencetime( 0.3 );
    self.turret setturretteam( "allies" );
    self.turret maketurretunusable();
    self.b_is_active = 0;
    self.audio_origin = self.origin;
    triggers = getentarray( "pillbox_turret_trigger", "targetname" );

    while ( true )
    {
        cost = level.auto_turret_cost;
        array_thread( triggers, ::turret_hint_string, &"ZOMBIE_BUTTON_BUY_TRAP" );
        self waittill( "trigger", player );

        if ( isdefined( self.is_locked ) && self.is_locked )
            continue;

        if ( self.e_turret ent_flag( "turret_is_active" ) )
            continue;

        index = maps\mp\zombies\_zm_weapons::get_player_index( player );

        if ( player maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
            continue;

        if ( player in_revive_trigger() )
            continue;

        if ( player.score < cost )
        {
            self playsound( "deny" );
            player thread play_no_money_turret_dialog();
            continue;
        }

        player maps\mp\zombies\_zm_score::minus_to_player_score( cost );
        self.e_turret ent_flag_set( "turret_is_active" );
        flag_set( "turret_active" );
        self.b_is_active = 1;
        array_thread( triggers, ::turret_hint_string, &"ZOMBIE_TRAP_ACTIVE" );
        self thread auto_turret_activate();
        self playsound( "zmb_turret_startup" );
        self waittill( "turret_deactivated" );
        self.e_turret ent_flag_clear( "turret_is_active" );
        flag_clear( "turret_active" );
        self.b_is_active = 0;
        playsoundatposition( "zmb_turret_down", self.audio_origin );
        self.turret ghost();
        level setclientfield( "pillbox_turret_anim", 0 );
        n_anim_length = getanimlength( %fxanim_zom_tomb_turret_deactivate_anim );
        wait( n_anim_length );
        self.e_turret.b_cooldown = 1;
        array_thread( triggers, ::turret_hint_string, &"ZOMBIE_TRAP_COOLDOWN" );
        wait 30;
        self.e_turret.b_cooldown = 0;
    }
}

auto_turret_activate()
{
    self endon( "turret_deactivated" );
    self thread activate_move_handle();
    self waittill( "switch_activated" );

    if ( level.max_auto_turrets_active <= 0 )
        return;

    level setclientfield( "pillbox_turret_anim", 1 );
    n_anim_length = getanimlength( %fxanim_zom_tomb_turret_activate_anim );
    wait( n_anim_length );
    self.turret show();

    while ( level.curr_auto_turrets_active >= level.max_auto_turrets_active )
    {
        worst_turret = undefined;
        worst_turret_time = -1;

        for ( i = 0; i < level.auto_turret_array.size; i++ )
        {
            if ( level.auto_turret_array[i] == self )
                continue;

            if ( !level.auto_turret_array[i].turret_active )
                continue;

            if ( worst_turret_time < 0 || level.auto_turret_array[i].curr_time < worst_turret_time )
            {
                worst_turret = level.auto_turret_array[i];
                worst_turret_time = level.auto_turret_array[i].curr_time;
            }
        }

        if ( isdefined( worst_turret ) )
            worst_turret auto_turret_deactivate();
        else
            assert( 0, "Couldn't free an auto turret to activate another, this should never be the case" );
    }

    self.turret setturrettype( "sentry" );
    self.turret setmode( "auto_nonai" );
    self.turret thread maps\mp\zombies\_zm_mgturret::burst_fire_unmanned();
    self.turret_active = 1;
    self.curr_time = level.auto_turret_timeout;
    self thread auto_turret_update_timeout();
    wait( level.auto_turret_timeout );
    self auto_turret_deactivate();
}

auto_turret_deactivate()
{
    self.turret_active = 0;
    self.curr_time = -1;
    self.turret setmode( "auto_ai" );
    self.turret notify( "stop_burst_fire_unmanned" );
    self notify( "turret_deactivated" );
}

auto_turret_update_timeout()
{
    self endon( "turret_deactivated" );

    while ( self.curr_time > 0 )
    {
        wait 1;
        self.curr_time--;
    }
}

activate_move_handle()
{
    if ( isdefined( self.handle ) )
    {
        self.handle rotatepitch( 160, 0.5 );
        self.handle playsound( "amb_sparks_l_b" );
        self.handle waittill( "rotatedone" );
        self notify( "switch_activated" );
        self waittill( "turret_deactivated" );
        self.handle rotatepitch( -160, 0.5 );
    }
}

play_no_money_turret_dialog()
{

}
