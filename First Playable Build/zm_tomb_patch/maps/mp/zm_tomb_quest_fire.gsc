// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_net;

main()
{
    flag_init( "fire_puzzle_1_complete" );
    flag_init( "fire_puzzle_2_complete" );
    flag_init( "fire_upgrade_available" );
    onplayerconnect_callback( ::onplayerconnect );
    fire_puzzle_1_init();
    fire_puzzle_2_init();
    level thread moving_platform_fire_init();
    level thread moving_column_fire_init();
    level thread moving_block_fire_init();
    flag_wait( "door_fire_opened" );
    level thread fire_puzzle_1_run();
    flag_wait( "fire_puzzle_1_complete" );
    level thread fire_puzzle_1_cleanup();
    level thread fire_puzzle_2_run();
    flag_wait( "fire_puzzle_2_complete" );
    level thread fire_puzzle_2_cleanup();
    flag_wait( "staff_fire_zm_upgrade_unlocked" );
}

onplayerconnect()
{
    self thread fire_puzzle_watch_staff();
}

#using_animtree("zm_tomb_basic");

init_animtree()
{
    scriptmodelsuseanimtree( #animtree );
}

moving_platform_fire_init()
{
    m_platform = getent( "fire_chamber_platform", "targetname" );
    m_platform setmovingplatformenabled( 1 );
    m_platform.leftfrontnode = getnode( "node_fire_platform_leftfront", "targetname" );
    m_platform.leftmidnode = getnode( "node_fire_platform_leftmid", "targetname" );
    m_platform.leftbacknode = getnode( "node_fire_platform_leftback", "targetname" );
    m_platform.rightfrontnode = getnode( "node_fire_platform_rightfront", "targetname" );
    m_platform.rightmidnode = getnode( "node_fire_platform_rightmid", "targetname" );
    m_platform.rightbacknode = getnode( "node_fire_platform_rightback", "targetname" );
    m_platform.leftfrontlowernode = getnode( "node_fire_platform_leftfrontlower", "targetname" );
    m_platform.leftmidlowernode = getnode( "node_fire_platform_leftmidlower", "targetname" );
    m_platform.leftbacklowernode = getnode( "node_fire_platform_leftbacklower", "targetname" );
    m_platform.rightfrontlowernode = getnode( "node_fire_platform_rightfrontlower", "targetname" );
    m_platform.rightmidlowernode = getnode( "node_fire_platform_rightmidlower", "targetname" );
    m_platform.rightbacklowernode = getnode( "node_fire_platform_rightbacklower", "targetname" );
    m_platform.leftfrontuppernode = getnode( "node_fire_platform_leftfrontupper", "targetname" );
    m_platform.leftmiduppernode = getnode( "node_fire_platform_leftmidupper", "targetname" );
    m_platform.leftbackuppernode = getnode( "node_fire_platform_leftbackupper", "targetname" );
    m_platform.rightfrontuppernode = getnode( "node_fire_platform_rightfrontupper", "targetname" );
    m_platform.rightmiduppernode = getnode( "node_fire_platform_rightmidupper", "targetname" );
    m_platform.rightbackuppernode = getnode( "node_fire_platform_rightbackupper", "targetname" );
    m_platform.leftbackstairsnode = getnode( "node_fire_platform_leftbackstairs", "targetname" );
    m_platform.rightbackstairsnode = getnode( "node_fire_platform_rightbackstairs", "targetname" );
    m_platform thread moving_platform_fire_link_top_nodes();
    m_platform thread moving_platform_fire_link_top_nodes( 1 );
    trigger_wait( "trigger_fire_chamber" );
    m_platform thread moving_platform_fire_enable();
}

moving_platform_fire_enable()
{
    n_drop_stairs = 88;
    n_drop_floor = 96;
    flag_wait( "staff_fire_zm_upgrade_unlocked" );

    while ( true )
    {
        self thread moving_platform_fire_link_top_nodes( 0 );
        self movez( n_drop_stairs * -1, 8.0 );
        self waittill( "movedone" );
        self thread moving_platform_fire_link_stairs_nodes( 1 );
        wait( randomintrange( 15, 21 ) );
        self thread moving_platform_fire_link_stairs_nodes( 0 );
        self movez( n_drop_floor * -1, 10.0 );
        self waittill( "movedone" );
        self thread moving_platform_fire_link_floor_nodes( 1 );
        wait( randomintrange( 15, 21 ) );
        self thread moving_platform_fire_link_floor_nodes( 0 );
        self movez( n_drop_floor, 10.0 );
        self waittill( "movedone" );
        self thread moving_platform_fire_link_stairs_nodes( 1 );
        wait( randomintrange( 15, 21 ) );
        self thread moving_platform_fire_link_stairs_nodes( 0 );
        self movez( n_drop_stairs, 8.0 );
        self waittill( "movedone" );
        self thread moving_platform_fire_link_top_nodes( 1 );
        wait( randomintrange( 15, 21 ) );
    }
}

moving_platform_fire_link_top_nodes( b_link )
{
    if ( isdefined( b_link ) && b_link )
    {
        link_platform_nodes( self.leftfrontnode, self.leftfrontuppernode );
        link_platform_nodes( self.leftbacknode, self.leftbackuppernode );
        link_platform_nodes( self.rightfrontnode, self.rightfrontuppernode );
        link_platform_nodes( self.rightbacknode, self.rightbackuppernode );
    }
    else
    {
        unlink_platform_nodes( self.leftfrontnode, self.leftfrontuppernode );
        unlink_platform_nodes( self.leftbacknode, self.leftbackuppernode );
        unlink_platform_nodes( self.rightfrontnode, self.rightfrontuppernode );
        unlink_platform_nodes( self.rightbacknode, self.rightbackuppernode );
    }
}

moving_platform_fire_link_stairs_nodes( b_link )
{
    if ( isdefined( b_link ) && b_link )
    {
        link_platform_nodes( self.leftbacknode, self.leftbackstairsnode );
        link_platform_nodes( self.rightbacknode, self.rightbackstairsnode );
    }
    else
    {
        unlink_platform_nodes( self.leftbacknode, self.leftbackstairsnode );
        unlink_platform_nodes( self.rightbacknode, self.rightbackstairsnode );
    }
}

moving_platform_fire_link_floor_nodes( b_link )
{
    if ( isdefined( b_link ) && b_link )
    {
        link_platform_nodes( self.leftfrontnode, self.leftfrontlowernode );
        link_platform_nodes( self.leftmidnode, self.leftmidlowernode );
        link_platform_nodes( self.leftbacknode, self.leftbacklowernode );
        link_platform_nodes( self.rightfrontnode, self.rightfrontlowernode );
        link_platform_nodes( self.rightmidnode, self.rightmidlowernode );
        link_platform_nodes( self.rightbacknode, self.rightbacklowernode );
    }
    else
    {
        unlink_platform_nodes( self.leftfrontnode, self.leftfrontlowernode );
        unlink_platform_nodes( self.leftmidnode, self.leftmidlowernode );
        unlink_platform_nodes( self.leftbacknode, self.leftbacklowernode );
        unlink_platform_nodes( self.rightfrontnode, self.rightfrontlowernode );
        unlink_platform_nodes( self.rightmidnode, self.rightmidlowernode );
        unlink_platform_nodes( self.rightbacknode, self.rightbacklowernode );
    }
}

moving_column_fire_init()
{
    m_platform = getent( "fire_chamber_column", "targetname" );
    m_platform setmovingplatformenabled( 1 );
    m_platform.frontnode = getnode( "node_fire_column_front", "targetname" );
    m_platform.backnode = getnode( "node_fire_column_back", "targetname" );
    m_platform.frontlowernode = getnode( "node_fire_column_frontlower_link", "targetname" );
    m_platform.backlowernode = getnode( "node_fire_column_backlower_link", "targetname" );
    m_platform.frontuppernode = getnode( "node_fire_column_frontupper_link", "targetname" );
    m_platform.backuppernode = getnode( "node_fire_column_backupper_link", "targetname" );
    m_platform thread moving_column_fire_enable();
}

moving_column_fire_enable()
{
    n_dist_platform = 184;
    n_dist_floor = 352;
    self moving_column_fire_link_top_nodes( 1 );
    flag_wait( "staff_fire_zm_upgrade_unlocked" );
    trigger_wait( "trigger_fire_chamber" );
    wait( randomintrange( 15, 21 ) );

    while ( true )
    {
        self moving_column_fire_link_top_nodes( 0 );
        self movez( n_dist_platform * -1, 5.0 );
        self waittill( "movedone" );
        self thread moving_column_fire_link_floor_nodes( 1 );
        wait( randomintrange( 15, 21 ) );
        self thread moving_column_fire_link_floor_nodes( 0 );
        self movez( n_dist_platform, 5.0 );
        self waittill( "movedone" );
        self moving_column_fire_link_top_nodes( 1 );
        wait( randomintrange( 15, 21 ) );
    }
}

moving_column_fire_link_floor_nodes( b_link )
{
    if ( b_link )
    {
        link_platform_nodes( self.frontnode, self.frontlowernode );
        link_platform_nodes( self.backnode, self.backlowernode );
    }
    else
    {
        unlink_platform_nodes( self.frontnode, self.frontlowernode );
        unlink_platform_nodes( self.backnode, self.backlowernode );
    }
}

moving_column_fire_link_top_nodes( b_link )
{
    if ( b_link )
    {
        link_platform_nodes( self.frontnode, self.frontuppernode );
        link_platform_nodes( self.backnode, self.backuppernode );
    }
    else
    {
        unlink_platform_nodes( self.frontnode, self.frontuppernode );
        unlink_platform_nodes( self.backnode, self.backuppernode );
    }
}

moving_block_fire_init()
{
    m_platform = getent( "fire_chamber_block", "targetname" );
    m_platform setmovingplatformenabled( 1 );
    m_platform.frontnode = getnode( "node_fire_block_front", "targetname" );
    m_platform.backnode = getnode( "node_fire_block_back", "targetname" );
    m_platform.frontlowernode = getnode( "node_fire_block_frontlower_link", "targetname" );
    m_platform.backlowernode = getnode( "node_fire_block_backlower_link", "targetname" );
    m_platform.frontuppernode = getnode( "node_fire_block_frontupper_link", "targetname" );
    m_platform.backuppernode = getnode( "node_fire_block_backupper_link", "targetname" );
    m_platform thread moving_block_fire_enable();
}

moving_block_fire_enable()
{
    n_dist_floor = 352;
    n_dist_platform = 184;
    link_platform_nodes( self.frontnode, self.frontuppernode );
    link_platform_nodes( self.backnode, self.backuppernode );
    flag_wait( "staff_fire_zm_upgrade_unlocked" );
    trigger_wait( "trigger_fire_chamber" );
    wait( randomintrange( 15, 21 ) );

    while ( true )
    {
        unlink_platform_nodes( self.frontnode, self.frontuppernode );
        unlink_platform_nodes( self.backnode, self.backuppernode );
        self movez( n_dist_platform * -1, 10 );
        self waittill( "movedone" );
        self thread moving_block_fire_link_floor_nodes( 1 );
        wait( randomintrange( 15, 21 ) );
        self thread moving_block_fire_link_floor_nodes( 0 );
        self movez( n_dist_platform, 10 );
        self waittill( "movedone" );
        link_platform_nodes( self.frontnode, self.frontuppernode );
        link_platform_nodes( self.backnode, self.backuppernode );
        wait( randomintrange( 15, 21 ) );
    }
}

moving_block_fire_link_floor_nodes( b_link )
{
    if ( isdefined( b_link ) && b_link )
    {
        link_platform_nodes( self.frontnode, self.frontlowernode );
        link_platform_nodes( self.backnode, self.backlowernode );
    }
    else
    {
        unlink_platform_nodes( self.frontnode, self.frontlowernode );
        unlink_platform_nodes( self.backnode, self.backlowernode );
    }
}

fire_puzzle_1_init()
{

}

fire_puzzle_1_run()
{
    level.sacrifice_volumes = getentarray( "fire_sacrifice_volume", "targetname" );
    level.clone_list = [];
    level thread clone_cleanup_watch_player_presence();
    array_thread( level.sacrifice_volumes, ::init_sacrifice_volume );
    b_any_volumes_unfinished = 1;

    while ( b_any_volumes_unfinished )
    {
        level waittill( "fire_sacrifice_completed" );
        b_any_volumes_unfinished = 0;

        foreach ( e_volume in level.sacrifice_volumes )
        {
            if ( !e_volume.b_gods_pleased )
                b_any_volumes_unfinished = 1;
        }
    }

/#
    iprintlnbold( "Fire Chamber Puzzle Completed" );
#/
    flag_set( "fire_puzzle_1_complete" );
}

fire_puzzle_1_cleanup()
{
    array_delete( level.sacrifice_volumes );
    level.sacrifice_volumes = [];
    array_delete( level.clone_list );
    level.clone_list = [];
}

clone_cleanup_watch_player_presence()
{
    level endon( "fire_puzzle_1_complete" );

    while ( true )
    {
        wait 1.0;

        if ( level.clone_list.size > 0 )
        {
            if ( !is_fire_chamber_occupied() )
            {
                array_delete( level.clone_list );
                level.clone_list = [];
            }
        }
    }
}

init_sacrifice_volume()
{
    self.b_gods_pleased = 0;
    self.num_sacrifices_received = 0;
    self.e_ignition_point = getstruct( self.target, "targetname" );
    self.e_ignition_point thread run_sacrifice_ignition( self );
}

run_sacrifice_ignition( e_volume )
{
    e_volume ent_flag_init( "flame_on" );

    if ( flag( "fire_puzzle_1_complete" ) )
        return;

    level endon( "fire_puzzle_1_complete" );
    s_torch_pos = getstruct( self.target, "targetname" );

    if ( !isdefined( self.angles ) )
        self.angles = ( 0, 0, 0 );

    max_hit_distance_sq = 10000;

    while ( !e_volume.b_gods_pleased )
    {
        e_volume ent_flag_clear( "flame_on" );
        level waittill( "fire_staff_explosion", v_point );

        if ( !is_fire_chamber_occupied() )
            continue;

        dist_sq = distancesquared( v_point, self.origin );

        if ( dist_sq > max_hit_distance_sq )
            continue;

        self.e_fx = spawn( "script_model", self.origin );
        self.e_fx.angles = vectorscale( ( -1, 0, 0 ), 90.0 );
        self.e_fx setmodel( "tag_origin" );
        playfxontag( level._effect["fire_sacrifice_flame"], self.e_fx, "tag_origin" );
        e_volume ent_flag_set( "flame_on" );
        wait 3.0;
        self.e_fx delete();
    }

    s_torch_pos thread run_torch();
    level notify( "fire_sacrifice_completed" );
}

run_torch()
{
    e_fx = spawn( "script_model", self.origin );
    e_fx setmodel( "tag_origin" );
    playfxontag( level._effect["fire_torch"], e_fx, "tag_origin" );
    e_fx.angles = vectorscale( ( -1, 0, 0 ), 90.0 );
    flag_wait( "fire_puzzle_1_complete" );
    wait 30.0;
    e_fx delete();
}

is_fire_chamber_occupied()
{
    return level.zones["zone_fire_chamber"].is_occupied || level.zones["zone_fire_anteroom"].is_occupied;
}

is_church_occupied()
{
    return level.zones["zone_village_7"].is_occupied;
}

sacrifice_puzzle_zombie_killed( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime )
{
    if ( !( isdefined( level.craftables_crafted["elemental_staff_fire"] ) && level.craftables_crafted["elemental_staff_fire"] ) && getdvarint( #"_id_FA81816F" ) <= 0 )
        return;

    if ( isdefined( self.is_mechz ) && self.is_mechz )
        return;

    if ( !isdefined( level.sacrifice_volumes ) )
        return;

    if ( !is_fire_chamber_occupied() )
        return;

    foreach ( e_volume in level.sacrifice_volumes )
    {
        if ( e_volume.b_gods_pleased )
            continue;

        if ( self istouching( e_volume ) )
        {
            self thread fire_sacrifice_death_clone( e_volume );
            return;
        }
    }
}

delete_oldest_clone()
{
    if ( level.clone_list.size == 0 )
        return;

    clone = level.clone_list[0];
    arrayremoveindex( level.clone_list, 0, 0 );
    clone delete();
}

fire_sacrifice_death_clone( e_sacrifice_volume )
{
    if ( level.clone_list.size >= 15 )
        level delete_oldest_clone();

    self ghost();
    clone = self spawn_zombie_clone();
    clone setanim( %ch_dazed_a_death, 1.0, 0.0, 1.0 );
    n_anim_time = getanimlength( %ch_dazed_a_death );
    level.clone_list[level.clone_list.size] = clone;
    clone endon( "death" );
    wait( n_anim_time );
    e_sacrifice_volume ent_flag_wait( "flame_on" );
    playfx( level._effect["fire_ash_explosion"], clone.origin, anglestoforward( clone.angles ), anglestoup( clone.angles ) );
    e_sacrifice_volume.num_sacrifices_received++;

    if ( e_sacrifice_volume.num_sacrifices_received >= 6 )
        e_sacrifice_volume.b_gods_pleased = 1;

    arrayremovevalue( level.clone_list, clone );
    clone delete();
}

spawn_zombie_clone()
{
    clone = spawn( "script_model", self.origin );
    clone.angles = self.angles;
    clone setmodel( self.model );

    if ( isdefined( self.headmodel ) )
    {
        clone.headmodel = self.headmodel;
        clone attach( clone.headmodel, "", 1 );
    }

    clone useanimtree( #animtree );
    return clone;
}

fire_puzzle_2_init()
{
    for ( i = 1; i <= 4; i++ )
    {
        a_ternary = getentarray( "fire_torch_ternary_group_0" + i, "targetname" );

        if ( a_ternary.size > 1 )
        {
            index_to_save = randomintrange( 0, a_ternary.size - 1 );
            a_ternary[index_to_save] ghost();
            arrayremoveindex( a_ternary, index_to_save, 0 );
            array_delete( a_ternary );
            continue;
        }

        a_ternary[0] ghost();
    }

    a_torches = getstructarray( "church_torch_target", "script_noteworthy" );
    array_thread( a_torches, ::fire_puzzle_torch_run );
}

fire_puzzle_2_run()
{
    a_ternary = getentarray( "fire_torch_ternary", "script_noteworthy" );
    assert( a_ternary.size == 4 );

    foreach ( e_number in a_ternary )
    {
        e_number show();
        e_target_torch = getstruct( e_number.target, "targetname" );
        e_target_torch.b_correct_torch = 1;
        e_target_torch thread puzzle_debug_position();
    }
}

fire_puzzle_2_cleanup()
{
    a_torches = getstructarray( "church_torch_target", "script_noteworthy" );

    foreach ( s_torch in a_torches )
    {
        if ( !isdefined( s_torch.e_fx ) )
            s_torch thread fire_puzzle_2_torch_flame();
    }

    wait 30.0;

    foreach ( s_torch in a_torches )
    {
        if ( isdefined( s_torch.e_fx ) )
            s_torch.e_fx delete();
    }
}

fire_puzzle_2_is_complete()
{
    a_torches = getstructarray( "church_torch_target", "script_noteworthy" );

    foreach ( e_torch in a_torches )
    {
        if ( isdefined( e_torch.e_fx ) && !e_torch.b_correct_torch )
            return false;

        if ( !isdefined( e_torch.e_fx ) && e_torch.b_correct_torch )
            return false;
    }

    return true;
}

fire_puzzle_watch_staff()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "missile_fire", e_projectile, str_weapon );
        self waittill( "projectile_impact", e_ent, v_explode_point, n_radius, str_name, n_impact );

        if ( str_weapon == "staff_fire_zm" )
            level notify( "fire_staff_explosion", v_explode_point );
    }
}

fire_puzzle_2_torch_flame()
{
    if ( isdefined( self.e_fx ) )
        self.e_fx delete();

    self.e_fx = spawn( "script_model", self.origin );
    self.e_fx.angles = vectorscale( ( -1, 0, 0 ), 90.0 );
    self.e_fx setmodel( "tag_origin" );
    playfxontag( level._effect["fire_torch"], self.e_fx, "tag_origin" );
    self.e_fx endon( "death" );

    if ( fire_puzzle_2_is_complete() )
    {
        flag_set( "fire_puzzle_2_complete" );
        level thread play_puzzle_stinger_on_all_players();
    }

    wait 15.0;

    if ( !flag( "fire_puzzle_2_complete" ) )
        self.e_fx delete();
}

fire_puzzle_torch_run()
{
    level endon( "fire_puzzle_2_complete" );
    self.b_correct_torch = 0;
    max_hit_distance_sq = 4096;

    while ( true )
    {
        level waittill( "fire_staff_explosion", v_point );

        if ( !is_church_occupied() )
            continue;

        dist_sq = distancesquared( v_point, self.origin );

        if ( dist_sq > max_hit_distance_sq )
            continue;

        self thread fire_puzzle_2_torch_flame();
        wait 2.0;
    }
}
