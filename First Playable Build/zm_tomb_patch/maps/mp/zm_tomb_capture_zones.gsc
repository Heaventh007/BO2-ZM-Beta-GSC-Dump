// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\animscripts\zm_death;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_magicbox;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\zm_tomb_traps;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_unitrigger;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\zombies\_zm_challenges;

#using_animtree("fxanim_props_dlc4");

init_capture_zones()
{
    precachemodel( "p6_zm_screecher_hole" );
    precachemodel( "p6_zm_tm_packapunch" );
    flag_init( "zone_capture_in_progress" );
    flag_init( "recapture_round" );
    flag_init( "player_has_captured_a_zone" );
    flag_init( "capture_zones_init_done" );
    root = %root;
    i = %fxanim_zom_tomb_generator_start_anim;
    i = %fxanim_zom_tomb_generator_up_idle_anim;
    i = %fxanim_zom_tomb_generator_down_idle_anim;
    i = %fxanim_zom_tomb_generator_end_anim;
    i = %fxanim_zom_tomb_generator_fluid_down_anim;
    i = %fxanim_zom_tomb_generator_fluid_up_anim;
    i = %fxanim_zom_tomb_packapunch_pc1_anim;
    i = %fxanim_zom_tomb_packapunch_pc2_anim;
    i = %fxanim_zom_tomb_packapunch_pc3_anim;
    i = %fxanim_zom_tomb_packapunch_pc4_anim;
    i = %fxanim_zom_tomb_packapunch_pc5_anim;
    i = %fxanim_zom_tomb_packapunch_pc6_anim;
    i = %fxanim_zom_tomb_packapunch_pc7_anim;
    i = %fxanim_zom_tomb_pack_return_pc1_anim;
    i = %fxanim_zom_tomb_pack_return_pc2_anim;
    i = %fxanim_zom_tomb_pack_return_pc3_anim;
    i = %fxanim_zom_tomb_pack_return_pc4_anim;
    i = %fxanim_zom_tomb_pack_return_pc5_anim;
    i = %fxanim_zom_tomb_pack_return_pc6_anim;
    i = %fxanim_zom_tomb_pack_return_pc7_anim;
    level thread setup_capture_zones();
}

init_pap_animtree()
{
    scriptmodelsuseanimtree( #animtree );
}

setup_capture_zones()
{
    precachestring( &"ZM_TOMB_OBJ_CAPTURE" );
    precachestring( &"ZM_TOMB_OBJ_RECAPTURE" );
    objective_add( 0, "invisible", ( 0, 0, 0 ), &"ZM_TOMB_OBJ_CAPTURE" );
    objective_add( 1, "invisible", ( 0, 0, 0 ), &"ZM_TOMB_OBJ_RECAPTURE" );
    spawner_capture_zombie = getent( "capture_zombie_spawner", "targetname" );
    spawner_capture_zombie add_spawn_function( ::capture_zombie_spawn_init );
    a_s_generator = getstructarray( "s_generator", "targetname" );

    foreach ( struct in a_s_generator )
        registerclientfield( "world", struct.script_noteworthy, 14000, 4, "int" );

    flag_wait( "start_zombie_round_logic" );
    level.magic_box_zbarrier_state_func = ::set_magic_box_zbarrier_state;
    level.custom_perk_validation = ::check_perk_machine_valid;
    level.last_zone_captured = undefined;
    level.test_origin = getent( "test_origin", "targetname" );
    level thread track_max_player_zombie_points();
    level thread init_capture_zone_info();

    foreach ( s_generator in a_s_generator )
        s_generator thread init_capture_zone();

    level thread pack_a_punch_init();
    level thread enable_recapture_rounds();
/#
    level thread watch_for_open_sesame();
#/
    flag_set( "capture_zones_init_done" );
}

track_max_player_zombie_points()
{
    while ( true )
    {
        a_players = get_players();

        foreach ( player in a_players )
            player.n_capture_zombie_points = 0;

        level waittill( "between_round_over" );
    }
}

pack_a_punch_dummy_init()
{

}

pack_a_punch_init()
{
    level.total_zone_captures = 0;
    vending_weapon_upgrade_trigger = getentarray( "specialty_weapupgrade", "script_noteworthy" );
    level.pap_triggers = vending_weapon_upgrade_trigger;
    t_pap = getent( "specialty_weapupgrade", "script_noteworthy" );
    t_pap.machine ghost();
    t_pap.bump enablelinkto();
    t_pap.bump linkto( t_pap );
}

init_capture_zone_info()
{
    level.a_s_capture_zones = [];

    foreach ( str_zone_name, zone in level.zones )
    {
        if ( isdefined( zone.volumes[0].script_string ) )
        {
            a_str_tokens = strtok( zone.volumes[0].script_string, "," );

            if ( a_str_tokens[0] == "capture_zone" )
            {
                get_zone_info( zone, str_zone_name );
                level.a_s_capture_zones[str_zone_name] = zone;
                zone.child_capture_zones = [];

                for ( i = 1; i < a_str_tokens.size; i++ )
                {
                    str_child_zone = a_str_tokens[i];
                    s_child_zone = level.zones[a_str_tokens[i]];
                    assert( isdefined( s_child_zone ), "Attempting to process child zone, " + str_child_zone + ", but it does not exist" );
                    zone.child_capture_zones[str_child_zone] = s_child_zone;
                    get_zone_info( s_child_zone, str_child_zone );
                }
            }
        }
    }
}

get_zone_info( zone, str_zone_name )
{
    zone ent_flag_init( "player_controlled" );
    level thread get_perk_machines( zone, str_zone_name );
    level thread get_mystery_boxes( zone, str_zone_name );
    level thread get_random_perk_machines( zone, str_zone_name );
    level thread get_flogger_trap( zone, str_zone_name );
    level thread get_pillbox_turrets( zone, str_zone_name );
    level thread get_flame_traps( zone, str_zone_name );
}

get_perk_machines( zone, str_zone_name )
{
    zone.perk_machines_triggers = [];
    zone.perk_machines_models = [];

    if ( isdefined( level.zombie_mode_using_oneinch_punch_perk ) && level.zombie_mode_using_oneinch_punch_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_one_inch_punch" );

    if ( isdefined( level.zombiemode_using_doubletap_perk ) && level.zombiemode_using_doubletap_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_doubletap" );

    if ( isdefined( level.zombiemode_using_revive_perk ) && level.zombiemode_using_revive_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_revive" );

    if ( isdefined( level.zombiemode_using_juggernaut_perk ) && level.zombiemode_using_juggernaut_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_jugg" );

    if ( isdefined( level.zombiemode_using_sleightofhand_perk ) && level.zombiemode_using_sleightofhand_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_sleight" );

    if ( isdefined( level.zombiemode_using_deadshot_perk ) && level.zombiemode_using_deadshot_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_deadshot_model" );

    if ( isdefined( level.zombiemode_using_electric_cherry_perk ) && level.zombiemode_using_electric_cherry_perk )
        add_machines_in_zone( zone, str_zone_name, "vendingelectric_cherry" );

    if ( isdefined( level.zombiemode_using_additionalprimaryweapon_perk ) && level.zombiemode_using_additionalprimaryweapon_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_additionalprimaryweapon" );

    if ( isdefined( level.zombiemode_using_marathon_perk ) && level.zombiemode_using_marathon_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_marathon" );

    if ( isdefined( level.zombiemode_using_divetonuke_perk ) && level.zombiemode_using_divetonuke_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_divetonuke" );

    if ( isdefined( level.zombiemode_using_chugabud_perk ) && level.zombiemode_using_chugabud_perk )
        add_machines_in_zone( zone, str_zone_name, "vending_chugabud" );
}

check_perk_machine_valid( player )
{
    if ( isdefined( self.str_zone_name ) )
    {
        if ( level.zones[self.str_zone_name] ent_flag_exist( "player_controlled" ) )
        {
            if ( !level.zones[self.str_zone_name] ent_flag( "player_controlled" ) )
                return false;
        }
    }

    return true;
}

add_machines_in_zone( zone, str_zone_name, match_string )
{
    a_machine_array = getentarray( match_string, "targetname" );

    for ( i = 0; i < a_machine_array.size; i++ )
    {
        if ( a_machine_array[i] entity_in_zone( str_zone_name, 1 ) )
        {
            trigger = a_machine_array[i] get_perk_machine_trigger();
            trigger.str_zone_name = str_zone_name;
            zone.perk_machines_triggers[zone.perk_machines_triggers.size] = trigger;
            perk_machine_model = getent( trigger.target, "targetname" );
            zone.perk_machines_models[zone.perk_machines_models.size] = perk_machine_model;
        }
    }
}

get_perk_machine_trigger()
{
    if ( self.targetname == "vendingelectric_cherry" )
        perk_machine = getent( "vending_electriccherry", "target" );
    else if ( self.targetname == "vending_deadshot_model" )
        perk_machine = getent( "vending_deadshot", "target" );
    else if ( self.targetname == "random_perk_machine" )
        perk_machine = getent( self.target, "targetnam" );
    else
        perk_machine = getent( self.targetname, "target" );

    return perk_machine;
}

init_capture_zone()
{
    self.b_enemy_flag = 1;
    self ent_flag_init( "zone_active" );
    self.n_current_progress = 0;
    self.n_next_progress = 0;
    self.n_change_in_progress = 0;
    self.n_movement_rate = 0;
    self.e_zone_volume = getent( self.target, "targetname" );
    self.trig_activate = getent( self.e_zone_volume.target, "targetname" );
    self.str_zone = get_zone_from_position( self.trig_activate.origin, 1 );
    self.sndent = spawn( "script_origin", self.trig_activate.origin );
    s_zone = level.zones[self.str_zone];
    s_zone.s_zone_capture = self;
    set_zombie_controlled_area( s_zone );
    self thread wait_for_capture_trigger();
}

wait_for_capture_trigger()
{
    self.trig_activate setcursorhint( "HINT_NOICON" );
    self.trig_activate sethintstring( &"ZM_TOMB_CAPTURE_TRIG" );
    zone = level.zones[self.str_zone];

    while ( true )
    {
        self.trig_activate setvisibletoall();
        self.trig_activate waittill( "trigger", e_player );

        if ( !is_player_valid( e_player ) )
            continue;

        if ( !flag( "zone_capture_in_progress" ) )
        {
            a_s_generator = getstructarray( "s_generator", "targetname" );

            foreach ( generator in a_s_generator )
                generator.trig_activate sethintstring( &"ZM_TOMB_ZONE_CAPTURE_IN_PROGRESS" );

            self.trig_activate setinvisibletoall();
            self activate_capture_zone();
        }

        flag_waitopen( "zone_capture_in_progress" );
        a_s_generator = getstructarray( "s_generator", "targetname" );

        foreach ( generator in a_s_generator )
            generator.trig_activate sethintstring( &"ZM_TOMB_CAPTURE_TRIG" );

        if ( zone ent_flag( "player_controlled" ) )
            zone ent_flag_waitopen( "player_controlled" );
    }
}

activate_capture_zone()
{
    self ent_flag_set( "zone_active" );
    flag_set( "zone_capture_in_progress" );

    if ( flag( "recapture_round" ) )
        level.zombie_ai_limit = level.zombie_ai_limit - 6;
    else
        level.zombie_ai_limit = level.zombie_ai_limit - 4;

    self.a_zone_spawners = getstructarray( self.trig_activate.target, "targetname" );
    self.a_spawner_holes = [];

    foreach ( spawner in self.a_zone_spawners )
    {
        s_hole = getstruct( spawner.target, "targetname" );
        self.a_spawner_holes[self.a_spawner_holes.size] = s_hole;
    }

    array_thread( self.a_spawner_holes, ::emergence_hole_fx, self, "zone_active" );
    self thread monitor_capture_zone( "zone_active" );
    self thread monitor_capture_zombies( "zone_active" );
    self thread monitor_capture_flag( "zone_active" );
    flag_waitopen( "zone_capture_in_progress" );

    if ( level.zombie_ai_limit != 24 )
        level.zombie_ai_limit = level.zombie_ai_limit + 4;
}

monitor_capture_zombies( str_zone_flag )
{
    level.a_capture_zombies = [];
    e_spawner_capture_zombie = getent( "capture_zombie_spawner", "targetname" );
    n_capture_zombie_spawns = 0;

    if ( flag( "recapture_round" ) )
        n_capture_round_zombies = 6;
    else
        n_capture_round_zombies = 4;

    while ( self ent_flag( str_zone_flag ) )
    {
        level.a_capture_zombies = array_removedead( level.a_capture_zombies );

        if ( level.a_capture_zombies.size < n_capture_round_zombies )
        {
            ai = spawn_zombie( e_spawner_capture_zombie );
            n_capture_zombie_spawns++;
            s_spawn_point = get_spawn_point( self );
            ai thread init_capture_zombie( self, s_spawn_point );
            level.a_capture_zombies[level.a_capture_zombies.size] = ai;
        }

        if ( flag( "recapture_round" ) && n_capture_zombie_spawns >= n_capture_round_zombies )
        {
            while ( flag( "zone_capture_in_progress" ) && level.a_capture_zombies.size > 0 )
            {
                wait 1;
                level.a_capture_zombies = array_removedead( level.a_capture_zombies );
            }

            while ( flag( "zone_capture_in_progress" ) && self.n_current_progress != 100 )
                wait 0.1;

            flag_clear( "recapture_round" );
        }

        wait 0.5;
    }
}

get_spawn_point( s_zone )
{
    while ( true )
    {
        if ( isdefined( s_zone.a_zone_spawners ) && s_zone.a_zone_spawners.size > 0 )
        {
            s_spawn_point = random( s_zone.a_zone_spawners );
            s_zone.a_zone_spawners = array_remove( s_zone.a_zone_spawners, s_spawn_point );
            return s_spawn_point;
        }
        else
            self.a_zone_spawners = getstructarray( self.trig_activate.target, "targetname" );

        wait 0.05;
    }
}

array_remove( array, object )
{
    if ( !isdefined( array ) && !isdefined( object ) )
        return;

    new_array = [];

    foreach ( item in array )
    {
        if ( item != object )
            new_array[new_array.size] = item;
    }

    return new_array;
}

emergence_hole_fx( zone_struct, str_zone_flag )
{
    e_spawn_hole_fx = spawn( "script_model", self.origin );
    e_spawn_hole_fx setmodel( "tag_origin" );
    e_spawn_hole_fx.angles = self.angles;
    playfxontag( level._effect["tesla_elec_kill"], e_spawn_hole_fx, "tag_origin" );
    e_spawn_hole = spawn( "script_model", self.origin );
    e_spawn_hole setmodel( "p6_zm_screecher_hole" );
    e_spawn_hole.angles = self.angles;
    playfxontag( level._effect["screecher_hole"], e_spawn_hole_fx, "tag_origin" );
    zone_struct ent_flag_waitopen( str_zone_flag );
    playfxontag( level._effect["tesla_elec_kill"], e_spawn_hole_fx, "tag_origin" );
    e_spawn_hole_fx delete();
    e_spawn_hole delete();
}

capture_zombie_elec_glow_eyes()
{
    self endon( "death" );

    while ( true )
    {
        if ( !( isdefined( self.head_gibbed ) && self.head_gibbed ) )
            playfxontag( level._effect["tesla_shock_eyes"], self, "J_Eyeball_LE" );
        else
            return;

        wait 1.5;
    }
}

capture_zombie_elec_body()
{
    self endon( "death" );

    while ( true )
    {
        if ( isdefined( self gettagorigin( "J_spine4" ) ) )
            playfxontag( level._effect["lightning_impact"], self, "J_spine4" );
        else
            return;

        wait 5.5;
    }
}

init_capture_zombie( zone_struct, s_spawn_point )
{
    self endon( "death" );
    self dug_zombie_rise( s_spawn_point );
    self thread capture_zombie_elec_glow_eyes();
    self thread capture_zombie_elec_body();

    if ( level.round_number <= 2 )
        self.zombie_move_speed = "walk";
    else if ( level.round_number <= 5 )
    {
        if ( cointoss() )
            self.zombie_move_speed = "walk";
        else
            self.zombie_move_speed = "run";
    }
    else if ( level.round_number > 5 )
    {
        if ( cointoss() )
            self.zombie_move_speed = "sprint";
        else
            self.zombie_move_speed = "run";
    }

    if ( flag( "zone_capture_in_progress" ) && !flag( "recapture_round" ) )
    {
        self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
        find_flesh_struct_string = "find_flesh";
        self notify( "zombie_custom_think_done", find_flesh_struct_string );
    }
    else if ( flag( "recapture_round" ) )
    {
        self.goalradius = 64;
        self setgoalpos( zone_struct.trig_activate.origin );
        self waittill( "goal" );

        while ( flag( "zone_capture_in_progress" ) )
        {
            self.is_attacking_zone = 1;
            self animscripted( self.origin, self.angles, "zm_generator_melee" );
            self melee_wait();
        }

        flag_waitopen( "zone_capture_in_progress" );
        self.is_attacking_zone = 0;
    }
}

melee_wait()
{
    self endon( "death" );

    while ( true )
    {
        self waittill( "static_melee_anim", note );

        if ( note == "end" )
            break;
    }
}

monitor_capture_flag( str_zone_flag )
{
    zone = level.zones[self.str_zone];
    n_cooldown_timeout = undefined;

    if ( flag( "recapture_round" ) )
    {
        n_objective = 1;
        objective_position( n_objective, self.origin );
    }
    else
        n_objective = 0;

    objective_state( n_objective, "active" );

    while ( self ent_flag( str_zone_flag ) )
    {
        self.n_next_progress = self.n_next_progress + self.n_movement_rate * 0.05;

        if ( self.n_next_progress < 0 )
            self.n_next_progress = 0;

        if ( self.n_next_progress > 0 && isdefined( n_cooldown_timeout ) )
            n_cooldown_timeout = undefined;

        if ( self.n_next_progress >= 100 )
            self.n_next_progress = 100;

        if ( self.n_current_progress == 0 )
        {
            if ( !isdefined( n_cooldown_timeout ) )
                n_cooldown_timeout = gettime() + 5000;
            else if ( gettime() >= n_cooldown_timeout )
            {
                if ( zone ent_flag( "player_controlled" ) )
                    set_zombie_controlled_area( zone );

                if ( flag( "recapture_round" ) )
                    flag_clear( "recapture_round" );

                if ( self.n_next_progress == 0 )
                {
                    self ent_flag_clear( str_zone_flag );
                    flag_clear( "zone_capture_in_progress" );
                    self.sndent stoploopsound( 0.25 );
                }

                kill_all_capture_zombies();
            }
        }

        if ( !flag( "recapture_round" ) )
        {
            if ( self.n_current_progress == 100 )
            {
                self ent_flag_clear( str_zone_flag );
                flag_clear( "zone_capture_in_progress" );

                if ( level.zombie_total == 1 )
                    level.zombie_total = 0;

                self.sndent playsound( "zmb_flag_capture_success" );
                self.sndent stoploopsound( 0.25 );
                set_player_controlled_area( zone );
                kill_all_capture_zombies();
                playfx( level._effect["capture_complete"], self.origin );
                a_players = get_players();

                foreach ( player in a_players )
                    player maps\mp\zombies\_zm_score::player_add_points( "bonus_points_powerup", 100 );

                if ( isdefined( level._challenges.a_stats["zone_captures"] ) )
                    check_players_in_capture_area();
            }
        }

        if ( self.n_current_progress != self.n_next_progress )
            objective_setprogress( n_objective, self.n_next_progress / 100 );

        self.n_current_progress = self.n_next_progress;
        wait 0.05;
    }

    objective_state( n_objective, "invisible" );
}

kill_all_capture_zombies()
{
    foreach ( zombie in level.a_capture_zombies )
    {
        if ( isdefined( zombie ) && isalive( zombie ) )
        {
            playfx( level._effect["tesla_elec_kill"], zombie.origin );
            zombie dodamage( zombie.health + 100, zombie.origin );
        }

        wait_network_frame();
    }
}

is_capture_area_occupied( parent_zone )
{
    if ( parent_zone.is_occupied )
        return true;

    foreach ( s_child_zone in parent_zone.child_capture_zones )
    {
        if ( s_child_zone.is_occupied )
            return true;
    }

    return false;
}

set_player_controlled_area( s_zone )
{
    flag_set( "player_has_captured_a_zone" );
    level.last_zone_captured = s_zone;
    level.total_zone_captures++;

    if ( !( isdefined( level.b_open_sesame ) && level.b_open_sesame ) )
    {
        if ( isdefined( self.e_light.fx ) )
            self.e_light.fx delete();
    }

    if ( level.total_zone_captures == 7 )
    {
        t_pap = getent( "specialty_weapupgrade", "script_noteworthy" );
        t_pap trigger_on();
        flag_set( "power_on" );
    }

    s_zone thread play_pap_anim( 1 );
    set_player_controlled_zone( s_zone );

    foreach ( s_child_zone in s_zone.child_capture_zones )
        set_player_controlled_zone( s_child_zone );
}

set_player_controlled_zone( s_zone )
{
    s_zone ent_flag_set( "player_controlled" );

    foreach ( perk_trig in s_zone.perk_machines_triggers )
    {
        perk_trig.is_locked = 0;
        perk_trig maps\mp\zombies\_zm_perks::reset_vending_hint_string();
    }

    switch ( self.str_zone )
    {
        case "zone_bunker_3a":
            level notify( "sleight_on" );
            break;
        case "zone_start_b":
            level notify( "revive_on" );
            break;
        case "zone_nml_4":
            level notify( "marathon_on" );
            break;
        case "zone_village_1":
            level notify( "juggernog_on" );
            break;
    }

    foreach ( mystery_box in s_zone.a_mystery_boxes )
    {
        mystery_box.is_locked = 0;
        mystery_box.zbarrier set_magic_box_zbarrier_state( "player_controlled" );
    }

    foreach ( random_perk_machine in s_zone.a_random_perk_machines )
        random_perk_machine.is_locked = 0;

    foreach ( trigger in s_zone.a_random_perk_machines_trigs )
    {
        trigger.is_locked = 0;
        trigger sethintstring( &"ZM_TOMB_RANDOM_PERK_BUY", level._random_zombie_perk_cost );
    }

    foreach ( trigger in s_zone.a_flogger_trap_trigs )
    {
        trigger.is_locked = 0;
        level thread zapper_light_green( "pendulum_light" );

        if ( !flag( "flogger_active" ) )
            trigger sethintstring( &"ZOMBIE_BUTTON_BUY_TRAP", trigger.zombie_cost );
    }

    foreach ( trigger in s_zone.a_turret_trigs )
    {
        trigger.is_locked = 0;
        trigger thread maps\mp\zm_tomb_traps::set_state_hint_string();
    }

    foreach ( trigger in s_zone.a_flame_trap_trigs )
    {
        trigger.is_locked = 0;
        level thread zapper_light_green( "trap_light_tank" );

        if ( !flag( "flame_trap_active" ) )
            trigger sethintstring( &"ZOMBIE_BUTTON_BUY_TRAP", trigger.zombie_cost );
    }
}

set_zombie_controlled_area( s_zone )
{
    if ( isdefined( level.total_zone_captures ) )
        level.total_zone_captures--;

    if ( !isdefined( self.e_light ) )
    {
        self.e_light = spawn( "script_model", self.origin + vectorscale( ( 0, 0, -1 ), 3.0 ) );
        self.e_light setmodel( "zombie_zapper_cagelight_red" );
        self.e_light.angles = vectorscale( ( 0, 0, 1 ), 180.0 );
    }

    self.e_light.fx = maps\mp\zombies\_zm_net::network_safe_spawn( "trap_light_red", 2, "script_model", self.e_light.origin + vectorscale( ( 0, 0, 1 ), 5.0 ) );
    self.e_light.fx setmodel( "tag_origin" );
    self.e_light.fx.angles = self.e_light.angles;
    playfxontag( level._effect["zapper_light_notready"], self.e_light.fx, "tag_origin" );
    t_pap = getent( "specialty_weapupgrade", "script_noteworthy" );
    t_pap trigger_off();
    flag_clear( "power_on" );

    if ( s_zone ent_flag( "player_controlled" ) )
        s_zone thread play_pap_anim( 0 );

    set_zombie_controlled_zone( s_zone );

    foreach ( s_child_zone in s_zone.child_capture_zones )
        set_zombie_controlled_zone( s_child_zone );
}

play_pap_anim( b_animate_forward )
{
    if ( b_animate_forward )
    {
        switch ( self.s_zone_capture.script_noteworthy )
        {
            case "generator_start_bunker":
                anim_pap = %fxanim_zom_tomb_packapunch_pc1_anim;
                n_pap_anim = 1;
                break;
            case "generator_tank_trench":
                anim_pap = %fxanim_zom_tomb_packapunch_pc2_anim;
                n_pap_anim = 2;
                break;
            case "generator_mid_trench":
                anim_pap = %fxanim_zom_tomb_packapunch_pc3_anim;
                n_pap_anim = 3;
                break;
            case "generator_nml_right":
                anim_pap = %fxanim_zom_tomb_packapunch_pc4_anim;
                n_pap_anim = 4;
                break;
            case "generator_nml_left":
                anim_pap = %fxanim_zom_tomb_packapunch_pc5_anim;
                n_pap_anim = 5;
                break;
            case "generator_courtyard":
                anim_pap = %fxanim_zom_tomb_packapunch_pc6_anim;
                n_pap_anim = 6;
                break;
            case "generator_church":
                anim_pap = %fxanim_zom_tomb_packapunch_pc7_anim;
                n_pap_anim = 7;
                break;
        }
    }
    else
    {
        switch ( self.s_zone_capture.script_noteworthy )
        {
            case "generator_start_bunker":
                anim_pap = %fxanim_zom_tomb_pack_return_pc1_anim;
                n_pap_anim = 8;
                break;
            case "generator_tank_trench":
                anim_pap = %fxanim_zom_tomb_pack_return_pc2_anim;
                n_pap_anim = 9;
                break;
            case "generator_mid_trench":
                anim_pap = %fxanim_zom_tomb_pack_return_pc3_anim;
                n_pap_anim = 10;
                break;
            case "generator_nml_right":
                anim_pap = %fxanim_zom_tomb_pack_return_pc4_anim;
                n_pap_anim = 11;
                break;
            case "generator_nml_left":
                anim_pap = %fxanim_zom_tomb_pack_return_pc5_anim;
                n_pap_anim = 12;
                break;
            case "generator_courtyard":
                anim_pap = %fxanim_zom_tomb_pack_return_pc6_anim;
                n_pap_anim = 13;
                break;
            case "generator_church":
                anim_pap = %fxanim_zom_tomb_pack_return_pc7_anim;
                n_pap_anim = 14;
                break;
        }
    }

    level setclientfield( "packapunch_anim", n_pap_anim );
}

set_zombie_controlled_zone( s_zone )
{
    s_zone ent_flag_clear( "player_controlled" );
    level.test_origin setclientfield( "generator_damage", 0 );

    foreach ( perk_trig in s_zone.perk_machines_triggers )
    {
        perk_trig.is_locked = 1;
        perk_trig sethintstring( &"ZM_TOMB_ZONE_CAPTURED" );
    }

    switch ( self.str_zone )
    {
        case "zone_bunker_3a":
            level notify( "sleight_off" );
            break;
        case "zone_start_b":
            level notify( "revive_off" );
            break;
        case "zone_nml_4":
            level notify( "marathon_off" );
            break;
        case "zone_village_1":
            level notify( "juggernog_off" );
            break;
    }

    foreach ( mystery_box in s_zone.a_mystery_boxes )
    {
        mystery_box.is_locked = 1;
        mystery_box.zbarrier set_magic_box_zbarrier_state( "zombie_controlled" );
    }

    foreach ( random_perk_machine in s_zone.a_random_perk_machines )
        random_perk_machine.is_locked = 1;

    foreach ( trigger in s_zone.a_random_perk_machines_trigs )
    {
        trigger.is_locked = 1;
        trigger sethintstring( &"ZM_TOMB_ZONE_CAPTURED" );
    }

    foreach ( trigger in s_zone.a_flogger_trap_trigs )
        trigger thread lock_trap_trigger( s_zone );

    foreach ( trigger in s_zone.a_turret_trigs )
        trigger thread lock_turret_trigger( s_zone );

    foreach ( trigger in s_zone.a_flame_trap_trigs )
        trigger thread lock_flame_trap_trig( s_zone );
}

lock_flame_trap_trig( s_zone )
{
    s_zone endon( "player_controlled" );
    self.is_locked = 1;
    flag_waitopen( "flame_trap_active" );
    self sethintstring( &"ZM_TOMB_ZONE_CAPTURED" );
}

lock_turret_trigger( s_zone )
{
    s_zone endon( "player_controlled" );
    self.is_locked = 1;
    flag_waitopen( "turret_active" );
    self sethintstring( &"ZM_TOMB_ZONE_CAPTURED" );
}

lock_trap_trigger( s_zone )
{
    s_zone endon( "player_controlled" );
    self.is_locked = 1;
    flag_waitopen( "flogger_active" );
    self sethintstring( &"ZM_TOMB_ZONE_CAPTURED" );
}

monitor_capture_zone( str_zone_flag )
{
    sndlaststate = 0;
    n_time_last_touched = gettime();

    while ( self ent_flag( str_zone_flag ) )
    {
        if ( flag( "recapture_round" ) )
        {
            n_zone_attackers = get_recapture_attackers();

            if ( n_zone_attackers > 0 )
            {
                self.n_movement_rate = -5;
                level.test_origin setclientfield( "generator_damage", 1 );
            }
            else
            {
                level.test_origin setclientfield( "generator_damage", 0 );
                self.n_movement_rate = 5;
            }
        }
        else
        {
            n_players_touching = 0;
            a_players = get_players();

            foreach ( player in a_players )
            {
                if ( !isdefined( player.b_is_in_zone ) )
                    player.b_is_in_zone = 0;

                if ( is_player_valid( player ) && distancesquared( player.origin, self.trig_activate.origin ) < 65536 )
                {
                    if ( player istouching( self.e_zone_volume ) )
                    {
                        n_players_touching++;

                        if ( isdefined( player.b_is_in_zone ) && !player.b_is_in_zone )
                        {
                            player.b_is_in_zone = 1;
                            player setclientfieldtoplayer( "player_rumble_and_shake", 4 );
                        }

                        continue;
                    }

                    if ( isdefined( player.b_is_in_zone ) && player.b_is_in_zone )
                    {
                        player.b_is_in_zone = 0;
                        player setclientfieldtoplayer( "player_rumble_and_shake", 0 );
                    }
                }
            }

            if ( n_players_touching > 0 )
                n_time_last_touched = gettime();

            switch ( n_players_touching )
            {
                case 0:
                    if ( gettime() > 2000 + n_time_last_touched )
                        self.n_movement_rate = -5;
                    else
                        self.n_movement_rate = 0;

                    if ( sndlaststate != 0 )
                    {
                        self.sndent playsound( "zmb_zone_machine_stop" );
                        self.sndent playloopsound( "zmb_zone_alarm_loop", 0.25 );
                        sndlaststate = 0;
                    }

                    break;
                case 1:
                    if ( a_players.size == 1 )
                        self.n_movement_rate = 10;
                    else
                        self.n_movement_rate = int( 8.3 * n_players_touching / a_players.size );

                    if ( sndlaststate != 1 )
                    {
                        self.sndent playsound( "zmb_zone_machine_start" );
                        self.sndent playloopsound( "zmb_zone_machine_loop", 1 );
                        sndlaststate = 1;
                    }

                    break;
                default:
                    self.n_movement_rate = int( 8.3 * n_players_touching / a_players.size );

                    if ( sndlaststate != 1 )
                    {
                        self.sndent playsound( "zmb_zone_machine_start" );
                        self.sndent playloopsound( "zmb_zone_machine_loop", 1 );
                        sndlaststate = 1;
                    }

                    break;
            }
        }

        if ( self.n_movement_rate < -5 )
            self.n_movement_rate = -5;
        else if ( self.n_movement_rate > 10 )
            self.n_movement_rate = 10;

        n_dataval = self.n_movement_rate + 5;
        level setclientfield( self.script_noteworthy, n_dataval );
        wait 0.05;
    }

    a_players = get_players();

    foreach ( player in a_players )
    {
        if ( isdefined( player.b_is_in_zone ) && player.b_is_in_zone )
        {
            player.b_is_in_zone = 0;
            player setclientfieldtoplayer( "player_rumble_and_shake", 0 );
        }
    }
}

get_recapture_attackers()
{
    n_zone_attacker_count = 0;

    foreach ( zombie in level.a_capture_zombies )
    {
        if ( isalive( zombie ) && ( isdefined( zombie.is_attacking_zone ) && zombie.is_attacking_zone ) )
            n_zone_attacker_count++;
    }

    return n_zone_attacker_count;
}

watch_for_open_sesame()
{
/#
    level waittill( "open_sesame" );
    level.b_open_sesame = 1;
    a_generators = getstructarray( "s_generator", "targetname" );

    foreach ( s_generator in a_generators )
    {
        s_zone = level.zones[s_generator.str_zone];
        s_generator thread set_player_controlled_area( s_zone );
    }
#/
}

set_magic_box_zbarrier_state( state )
{
    for ( i = 0; i < self getnumzbarrierpieces(); i++ )
        self hidezbarrierpiece( i );

    self notify( "zbarrier_state_change" );

    switch ( state )
    {
        case "away":
            self showzbarrierpiece( 0 );
            self.state = "away";
            self.owner.is_locked = 0;
            break;
        case "arriving":
            self showzbarrierpiece( 1 );
            self thread magic_box_arrives();
            self.state = "arriving";
            break;
        case "initial":
            self showzbarrierpiece( 1 );
            self thread magic_box_initial();
            thread maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( self.owner.unitrigger_stub, maps\mp\zombies\_zm_magicbox::magicbox_unitrigger_think );
            self.state = "close";
            break;
        case "open":
            self showzbarrierpiece( 2 );
            self thread magic_box_opens();
            self.state = "open";
            break;
        case "close":
            self showzbarrierpiece( 2 );
            self thread magic_box_closes();
            self.state = "close";
            break;
        case "leaving":
            self showzbarrierpiece( 1 );
            self thread magic_box_leaves();
            self.state = "leaving";
            self.owner.is_locked = 0;
            break;
        case "zombie_controlled":
            self.last_state = self.state;

            if ( self.last_state == "initial" || self.last_state == "close" )
                self showzbarrierpiece( 1 );
            else if ( self.last_state == "away" )
                self showzbarrierpiece( 0 );

            self.state = "zombie_controlled";
            break;
        case "player_controlled":
            if ( self.state == "arriving" || self.state == "zombie_controlled" && self.last_state == "initial" )
            {
                self showzbarrierpiece( 2 );
                break;
            }

            set_magic_box_zbarrier_state( self.last_state );
            break;
        default:
            if ( isdefined( level.custom_magicbox_state_handler ) )
                self [[ level.custom_magicbox_state_handler ]]( state );

            break;
    }
}

get_pillbox_turrets( zone, str_zone_name )
{
    zone.a_turret_trigs = [];
    a_pillbox_turret_trigs = getentarray( "pillbox_turret_trigger", "targetname" );

    for ( i = 0; i < a_pillbox_turret_trigs.size; i++ )
    {
        e_temp_ent = spawn( "script_model", a_pillbox_turret_trigs[i].origin );
        e_temp_ent.angles = a_pillbox_turret_trigs[i].angles;
        e_temp_ent setmodel( "tag_origin" );

        if ( e_temp_ent entity_in_zone( str_zone_name, 1 ) )
        {
            a_pillbox_turret_trigs[i].str_zone_name = str_zone_name;
            zone.a_turret_trigs[zone.a_turret_trigs.size] = a_pillbox_turret_trigs[i];
        }

        e_temp_ent delete();
    }
}

get_flogger_trap( zone, str_zone_name )
{
    zone.a_flogger_trap_trigs = [];
    penbuytrigger = getentarray( "pendulum_buy_trigger", "targetname" );

    for ( i = 0; i < penbuytrigger.size; i++ )
    {
        e_temp_ent = spawn( "script_model", penbuytrigger[i].origin );
        e_temp_ent.angles = penbuytrigger[i].angles;
        e_temp_ent setmodel( "tag_origin" );

        if ( e_temp_ent entity_in_zone( str_zone_name, 1 ) )
        {
            penbuytrigger[i].str_zone_name = str_zone_name;
            zone.a_flogger_trap_trigs[zone.a_flogger_trap_trigs.size] = penbuytrigger[i];
        }

        e_temp_ent delete();
    }
}

get_flame_traps( zone, str_zone_name )
{
    zone.a_flame_trap_trigs = [];
    a_flame_trap_trigs = getentarray( "trig_flame_trap", "targetname" );

    for ( i = 0; i < a_flame_trap_trigs.size; i++ )
    {
        e_temp_ent = spawn( "script_model", a_flame_trap_trigs[i].origin );
        e_temp_ent.angles = a_flame_trap_trigs[i].angles;
        e_temp_ent setmodel( "tag_origin" );

        if ( e_temp_ent entity_in_zone( str_zone_name, 1 ) )
        {
            a_flame_trap_trigs[i].str_zone_name = str_zone_name;
            zone.a_flame_trap_trigs[zone.a_flame_trap_trigs.size] = a_flame_trap_trigs[i];
        }

        e_temp_ent delete();
    }
}

get_random_perk_machines( zone, str_zone_name )
{
    zone.a_random_perk_machines = [];
    zone.a_random_perk_machines_trigs = [];
    e_machines = getentarray( "random_perk_machine", "targetname" );

    for ( i = 0; i < e_machines.size; i++ )
    {
        if ( e_machines[i] entity_in_zone( str_zone_name, 1 ) )
        {
            zone.a_random_perk_machines[zone.a_random_perk_machines.size] = e_machines[i];
            e_machines[i].use_trigger = getent( e_machines[i].target, "targetname" );
            zone.a_random_perk_machines_trigs[zone.a_random_perk_machines_trigs.size] = e_machines[i].use_trigger;
        }
    }
}

get_mystery_boxes( zone, str_zone_name )
{
    zone.a_mystery_boxes = [];
    a_mystery_boxes = getstructarray( "treasure_chest_use", "targetname" );

    for ( i = 0; i < a_mystery_boxes.size; i++ )
    {
        e_mystery_box_ent = spawn( "script_model", a_mystery_boxes[i].origin );
        e_mystery_box_ent.angles = a_mystery_boxes[i].angles;
        e_mystery_box_ent setmodel( "tag_origin" );

        if ( e_mystery_box_ent entity_in_zone( str_zone_name, 1 ) )
        {
            zone.a_mystery_boxes[zone.a_mystery_boxes.size] = a_mystery_boxes[i];
            a_mystery_boxes[i].unitrigger_stub.prompt_and_visibility_func = ::magic_box_trigger_update_prompt;
            a_mystery_boxes[i].unitrigger_stub.zone = zone;
        }

        e_mystery_box_ent delete();
    }
}

magic_box_trigger_update_prompt( player )
{
    can_use = self magic_box_stub_update_prompt( player );

    if ( isdefined( self.stub.hint_parm1 ) )
        self sethintstring( self.stub.hint_string, self.stub.hint_parm1 );
    else
        self sethintstring( self.stub.hint_string );

    return can_use;
}

magic_box_stub_update_prompt( player )
{
    self setcursorhint( "HINT_NOICON" );

    if ( !self trigger_visible_to_player( player ) )
        return false;

    self.stub.hint_parm1 = undefined;

    if ( isdefined( self.stub.trigger_target.grab_weapon_hint ) && self.stub.trigger_target.grab_weapon_hint )
        self.stub.hint_string = &"ZOMBIE_TRADE_WEAPONS";
    else if ( !self.stub.zone ent_flag( "player_controlled" ) )
    {
        self.stub.hint_string = &"ZM_TOMB_ZONE_CAPTURED";
        return false;
    }
    else
    {
        self.stub.hint_parm1 = self.stub.trigger_target.zombie_cost;
        self.stub.hint_string = get_hint_string( self, "default_treasure_chest" );
    }

    return true;
}

enable_recapture_rounds()
{
    flag_wait( "player_has_captured_a_zone" );
    level.recapture_rounds_enabled = 1;
    level thread recapture_round_tracker();
}

recapture_round_tracker()
{
    level endon( "kill_recapture_rounds" );
    level.recapture_round_count = 1;
    level.next_recapture_round = 7;
/#
    iprintln( "Next Recapture Round = " + level.next_recapture_round );
#/

    while ( true )
    {
        level waittill( "between_round_over" );

        if ( level.round_number >= level.next_recapture_round )
        {
            if ( flag( "zone_capture_in_progress" ) )
            {
                level.next_recapture_round = level.round_number + 1;
                continue;
            }

            if ( get_num_captured_zones() < 6 )
            {
                level.next_recapture_round = level.round_number + 1;
/#
                iprintln( "Next Recapture Round = " + level.next_recapture_round );
#/
                continue;
            }

            s_recapture_zone = get_recapture_zone();

            if ( isdefined( s_recapture_zone ) )
            {
                level thread recapture_round_start( s_recapture_zone );
                level.next_recapture_round = level.round_number + randomintrange( 5, 8 );
            }
            else
            {
                level.recapture_rounds_enabled = 0;
                level notify( "kill_recapture_rounds" );
            }
        }
    }
}

get_num_captured_zones()
{
/#
    if ( getdvarint( #"_id_FA81816F" ) > 0 )
        return 6;
#/
    n_captured = 0;

    foreach ( s_zone in level.a_s_capture_zones )
    {
        if ( s_zone ent_flag( "player_controlled" ) )
            n_captured++;
    }

    return n_captured;
}

get_recapture_zone()
{
    a_s_player_zones = [];

    foreach ( str_key, s_zone in level.a_s_capture_zones )
    {
        if ( isdefined( s_zone.s_zone_capture ) && s_zone ent_flag( "player_controlled" ) )
            a_s_player_zones[str_key] = s_zone;
    }

    if ( a_s_player_zones.size )
    {
        while ( true )
        {
            s_recapture_zone = random( a_s_player_zones );

            if ( s_recapture_zone != level.last_zone_captured )
                break;

            wait 0.05;
        }

        return s_recapture_zone;
    }

    return undefined;
}

recapture_round_start( s_recapture_zone )
{
    flag_waitopen( "zone_capture_in_progress" );
    flag_set( "recapture_round" );
    level.music_round_override = 1;
    level thread maps\mp\zombies\_zm_audio::change_zombie_music( "dog_start" );
    level notify( "recapture_round_starting" );
    level.music_round_override = 0;
    s_capture = s_recapture_zone.s_zone_capture;
    s_capture thread recapture_warning();
    s_recapture_zone.s_zone_capture thread activate_capture_zone();
    s_recapture_zone thread recapture_round_reward();
}

recapture_warning()
{
    e_alarm_sound = spawn( "script_origin", self.trig_activate.origin );
    e_alarm_sound playloopsound( "zmb_flag_capture_zombies_loop" );
    e_alarm_sound thread play_flare_effect();

    while ( true )
    {
        n_zone_attackers = get_recapture_attackers();

        if ( n_zone_attackers > 0 )
        {
            e_alarm_sound stoploopsound( 0.5 );
            break;
        }

        wait 0.1;
    }

    wait 1;
    e_alarm_sound playloopsound( "zmb_flag_capture_zombies_loop_shabs" );

    while ( flag( "recapture_round" ) )
    {
        n_zone_attackers = get_recapture_attackers();

        if ( n_zone_attackers > 0 )
        {
            e_alarm_sound playloopsound( "zmb_flag_capture_zombies_loop_shabs" );
            break;
        }

        wait 0.1;
    }

    flag_waitopen( "recapture_round" );
    e_alarm_sound stoploopsound( 1 );
    e_alarm_sound delete();
}

play_flare_effect()
{
    while ( flag( "recapture_round" ) )
    {
        playfx( level._effect["lght_marker_flare"], self.origin );
        wait 4;
    }
}

recapture_round_reward()
{
    flag_waitopen( "zone_capture_in_progress" );
    self ent_flag_wait( "player_controlled" );
    level.last_zone_captured = self;
    level thread maps\mp\zombies\_zm_audio::change_zombie_music( "dog_end" );
    wait 3;
    v_origin = self.s_zone_capture.trig_activate.origin + vectorscale( ( 0, 1, 0 ), 45.0 );
    a_trace = bullettrace( v_origin, v_origin + vectorscale( ( 0, 0, -1 ), 200.0 ), 0, undefined );
    level thread maps\mp\zombies\_zm_powerups::specific_powerup_drop( "full_ammo", a_trace["position"] );
}

custom_vending_power_on()
{

}

custom_vending_power_off()
{

}

check_players_in_capture_area()
{
    a_players = get_players();

    foreach ( player in a_players )
    {
        if ( is_player_valid( player ) && distancesquared( player.origin, self.trig_activate.origin ) < 65536 )
        {
            if ( player istouching( self.e_zone_volume ) )
                player maps\mp\zombies\_zm_challenges::player_increment_stat( "zone_captures" );
        }
    }
}
