// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\animscripts\zm_death;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\gametypes_zm\_hud_util;
#include maps\mp\gametypes_zm\_hud;
#include maps\mp\animscripts\zm_shared;
#include maps\mp\zombies\_zm_perk_oneinch_punch;
#include maps\mp\zm_tomb_teleporter;
#include maps\mp\zm_tomb_main_quest;
#include maps\mp\zombies\_zm_ai_mechz;

init_giant_robot_glows()
{
    flag_init( "foot_shot" );
    level.robot_foot_has_door = [];
    level.robot_foot_has_door[0] = 1;
    level.robot_foot_has_door[1] = 1;
    level.robot_foot_has_door[2] = 1;
    robot_head_exit_trigger_1 = getent( "head_1_exit_trigger", "targetname" );
    robot_head_exit_trigger_2 = getent( "head_2_exit_trigger", "targetname" );
    robot_head_exit_trigger_3 = getent( "head_3_exit_trigger", "targetname" );
    robot_head_exit_trigger_1 thread wait_for_player_teleport();
    robot_head_exit_trigger_2 thread wait_for_player_teleport();
    robot_head_exit_trigger_3 thread wait_for_player_teleport();
}

init_giant_robot()
{
    registerclientfield( "toplayer", "player_rumble_and_shake", 14000, 3, "int" );
    registerclientfield( "actor", "play_foot_stamp_fx", 14000, 2, "int" );
    flag_init( "kill_trigger_active" );
    level thread robot_cycling();
}

robot_cycling()
{
    flag_wait( "start_zombie_round_logic" );
    three_robot_round = 0;

    while ( true )
    {
        if ( !( level.round_number % 4 ) && three_robot_round != level.round_number )
        {
            level.zombie_ai_limit = 22;
            level thread giant_robot_spawning_logic( 3 );
            wait 5;
            level thread giant_robot_spawning_logic( 1 );
            wait 5;
            level thread giant_robot_spawning_logic( 2 );
            level waittill( "giant_robot_deleted" );
            level waittill( "giant_robot_deleted" );
            level waittill( "giant_robot_deleted" );
            wait 5;
            level.zombie_ai_limit = 24;
            three_robot_round = level.round_number;
        }
        else
        {
            random_number = randomint( 3 );
            level thread giant_robot_spawning_logic( random_number + 1 );
            level waittill( "giant_robot_deleted" );
            wait 5;
        }
    }
}

giant_robot_spawning_logic( number )
{
    trig_stomp_kill_right = getent( "trig_stomp_kill_right_" + number, "targetname" );
    trig_stomp_kill_left = getent( "trig_stomp_kill_left_" + number, "targetname" );
    trig_stomp_kill_right enablelinkto();
    trig_stomp_kill_left enablelinkto();
    clip_foot_right = getent( "clip_foot_right_" + number, "targetname" );
    clip_foot_left = getent( "clip_foot_left_" + number, "targetname" );
    m_sole = getent( "target_sole_" + number, "targetname" );

    if ( isdefined( m_sole ) )
    {
        m_sole hide();
        m_sole setcandamage( 1 );
        m_sole.health = 99999;
    }

    wait 10;
    sp_giant_robot = getent( "ai_giant_robot", "targetname" );
    ai = sp_giant_robot spawnactor();
    ai.is_giant_robot = 1;
    tag_right_foot = ai gettagorigin( "tag_foot_bottom_right" );
    tag_left_foot = ai gettagorigin( "tag_foot_bottom_left" );
    trig_stomp_kill_right.origin = tag_right_foot + vectorscale( ( 0, 0, 1 ), 120.0 );
    trig_stomp_kill_right.angles = ai gettagangles( "tag_foot_bottom_right" );
    trig_stomp_kill_left.origin = tag_left_foot + vectorscale( ( 0, 0, 1 ), 120.0 );
    trig_stomp_kill_left.angles = ai gettagangles( "tag_foot_bottom_left" );
    trig_stomp_kill_right linkto( ai, "tag_foot_bottom_right" );
    trig_stomp_kill_left linkto( ai, "tag_foot_bottom_left" );
    clip_foot_right.origin = tag_right_foot + vectorscale( ( 0, 0, 1 ), 680.0 );
    clip_foot_left.origin = tag_left_foot + vectorscale( ( 0, 0, 1 ), 680.0 );
    clip_foot_right.angles = ai gettagangles( "tag_foot_bottom_right" );
    clip_foot_left.angles = ai gettagangles( "tag_foot_bottom_left" );
    clip_foot_right linkto( ai, "tag_foot_bottom_right" );
    clip_foot_left linkto( ai, "tag_foot_bottom_left" );

    if ( isdefined( m_sole ) )
    {
        m_sole.origin = tag_left_foot;
        m_sole.angles = ai gettagangles( "tag_foot_bottom_left" );
        m_sole linkto( ai, "tag_foot_bottom_left" );
    }

    wait 0.05;
    ai thread giant_robot_spawn( trig_stomp_kill_right, trig_stomp_kill_left, clip_foot_right, clip_foot_left, m_sole, number );
}

robot_loop_counter()
{
    while ( true )
    {
        wait 5;
        level notify( "spawn_giant_robot" );
        level waittill( "giant_robot_deleted" );
    }
}

giant_robot_spawn( trig_stomp_kill_right, trig_stomp_kill_left, clip_foot_right, clip_foot_left, m_sole, num )
{
    self endon( "death" );
    self.targetname = "giant_robot_walker_" + num;
    self.animname = "giant_robot_walker";
    self.script_noteworthy = "giant_robot";
    self.audio_type = "giant_robot";
    self.ignoreall = 1;
    self.ignoreme = 1;
    self setcandamage( 0 );
    self magic_bullet_shield();
    self setplayercollision( 1 );
    robot_route = num - 1;
    self thread robot_walk_animation( robot_route );
    self.n_robot_path = robot_route;
    self thread monitor_footsteps( trig_stomp_kill_right, "right" );
    self thread monitor_footsteps( trig_stomp_kill_left, "left" );

    if ( isdefined( m_sole ) && level.robot_foot_has_door[robot_route] )
        self thread giant_robot_foot_targets( m_sole, robot_route );

    level waittill( "robot_walks_over" );
    level notify( "giant_robot_deleted" );
    trig_stomp_kill_left unlink();
    trig_stomp_kill_right unlink();
    clip_foot_right unlink();
    clip_foot_left unlink();

    if ( isdefined( m_sole ) )
        m_sole unlink();

    self delete();
}

robot_walk_animation( robot_route )
{
    if ( robot_route == 0 )
    {
        animationid = self getanimfromasd( "zm_robot_walk_nml", 0 );
        str_anim_scripted_name = "zm_robot_walk_nml";
        s_robot_path = getstruct( "anim_align_robot_nml", "targetname" );
        s_robot_path.angles = ( 0, 0, 0 );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 0 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self waittillmatch( "scripted_walk", "end" );
        animationid = self getanimfromasd( "zm_robot_walk_nml", 1 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 1 );
        self waittillmatch( "scripted_walk", "end" );
        animationid = self getanimfromasd( "zm_robot_walk_nml", 2 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 2 );
        self waittillmatch( "scripted_walk", "end" );
        level notify( "robot_walks_over" );
    }
    else if ( robot_route == 1 )
    {
        animationid = self getanimfromasd( "zm_robot_walk_trenches", 0 );
        str_anim_scripted_name = "zm_robot_walk_trenches";
        s_robot_path = getstruct( "anim_align_robot_trenches", "targetname" );
        s_robot_path.angles = ( 0, 0, 0 );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 0 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self waittillmatch( "scripted_walk", "end" );
        animationid = self getanimfromasd( "zm_robot_walk_trenches", 1 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 1 );
        self waittillmatch( "scripted_walk", "end" );
        animationid = self getanimfromasd( "zm_robot_walk_trenches", 2 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 2 );
        self waittillmatch( "scripted_walk", "end" );
        level notify( "robot_walks_over" );
    }
    else if ( robot_route == 2 )
    {
        animationid = self getanimfromasd( "zm_robot_walk_village", 0 );
        str_anim_scripted_name = "zm_robot_walk_village";
        s_robot_path = getstruct( "anim_align_robot_village", "targetname" );
        s_robot_path.angles = ( 0, 0, 0 );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 0 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self waittillmatch( "scripted_walk", "end" );
        animationid = self getanimfromasd( "zm_robot_walk_village", 1 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 1 );
        self waittillmatch( "scripted_walk", "end" );
        animationid = self getanimfromasd( "zm_robot_walk_village", 2 );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "scripted_walk" );
        self animscripted( s_robot_path.origin, s_robot_path.angles, str_anim_scripted_name, 2 );
        self waittillmatch( "scripted_walk", "end" );
        level notify( "robot_walks_over" );
    }
}

monitor_footsteps( trig_stomp_kill, foot_side )
{
    self endon( "death" );
    str_start_stomp = "kill_zombies_" + foot_side + "foot_1";
    str_end_stomp = "footstep_" + foot_side + "_large";

    while ( true )
    {
        self waittillmatch( "scripted_walk", str_start_stomp );
        self setclientfield( "play_foot_stamp_fx", 0 );
        self waittillmatch( "scripted_walk", str_end_stomp );

        if ( foot_side == "right" )
            self setclientfield( "play_foot_stamp_fx", 1 );
        else
            self setclientfield( "play_foot_stamp_fx", 2 );

        trig_stomp_kill playsound( "zmb_robot_foot_impact" );
        trig_stomp_kill thread rumble_and_shake();
        self thread toggle_kill_trigger_flag( trig_stomp_kill, 1 );
        wait 0.5;
        self thread toggle_kill_trigger_flag( trig_stomp_kill, 0 );
    }
}

rumble_and_shake()
{
    a_players = get_players();
    wait 0.2;

    foreach ( player in a_players )
    {
        if ( is_player_valid( player ) )
        {
            dist = distance( player.origin, self.origin );

            if ( dist < 1500 )
                player setclientfieldtoplayer( "player_rumble_and_shake", 3 );
            else if ( dist < 3000 )
                player setclientfieldtoplayer( "player_rumble_and_shake", 2 );
            else if ( dist < 6000 )
                player setclientfieldtoplayer( "player_rumble_and_shake", 1 );
            else
                continue;

            wait_network_frame();
            player setclientfieldtoplayer( "player_rumble_and_shake", 0 );
        }
    }
}

toggle_kill_trigger_flag( trig_stomp, b_flag )
{
    if ( b_flag )
    {
        flag_set( "kill_trigger_active" );
        trig_stomp thread activate_kill_trigger( self );
    }
    else
    {
        flag_clear( "kill_trigger_active" );
        level notify( "stop_kill_trig_think" );
    }
}

activate_kill_trigger( robot )
{
    level endon( "stop_kill_trig_think" );
    vol_footprint = getent( "vol_footprint", "targetname" );

    while ( flag( "kill_trigger_active" ) )
    {
        a_zombies = getaispeciesarray( level.zombie_team, "all" );

        foreach ( zombie in a_zombies )
        {
            if ( distancesquared( zombie.origin, self.origin ) < 360000 )
            {
                if ( zombie istouching( self ) )
                {
                    zombie thread zombie_stomp_death();
                    continue;
                }

                if ( !( isdefined( zombie.is_mechz ) && zombie.is_mechz ) && ( isdefined( zombie.has_legs ) && zombie.has_legs ) )
                {
                    zombie.v_punched_from = self.origin;
                    zombie animcustom( maps\mp\zombies\_zm_perk_oneinch_punch::knockdown_zombie_animate );
                }
            }
        }

        players = get_players();

        for ( i = 0; i < players.size; i++ )
        {
            if ( is_player_valid( players[i] ) )
            {
                if ( !players[i] istouching( self ) )
                    continue;

                if ( !level.robot_foot_has_door[robot.n_robot_path] )
                {
                    players[i].teleport_initial_origin = self.origin;

                    if ( robot.n_robot_path == 2 )
                        level thread maps\mp\zm_tomb_teleporter::stargate_teleport_player( 6, players[i] );
                    else if ( robot.n_robot_path == 1 )
                        level thread maps\mp\zm_tomb_teleporter::stargate_teleport_player( 7, players[i] );
                    else
                        level thread maps\mp\zm_tomb_teleporter::stargate_teleport_player( 8, players[i] );

                    players[i] thread maps\mp\zm_tomb_main_quest::giant_robot_head_teleport_timeout();
                    continue;
                }
                else
                    players[i] thread player_stomp_death();
            }
        }

        wait 0.05;
    }
}

player_stomp_death()
{
    self endon( "death" );
    self endon( "disconnect" );
    self.is_stomped = 1;
    self playsound( "zmb_zombie_arc" );
    playfx( level._effect["zombie_guts_explosion"], self.origin + vectorscale( ( 0, 0, 1 ), 32.0 ) );
    self dodamage( self.health + 666, self.origin );
}

zombie_stomp_death()
{
    self endon( "death" );

    if ( isdefined( self.is_mechz ) && self.is_mechz )
        self thread maps\mp\zombies\_zm_ai_mechz::mechz_robot_stomp_callback();
    else
    {
        playsoundatposition( "zmb_zombie_arc", self.origin );
        playfx( level._effect["zombie_guts_explosion"], self.origin + vectorscale( ( 0, 0, 1 ), 32.0 ) );
        self playsound( "zmb_zombie_arc" );
        self dodamage( self.health + 666, self.origin );
    }
}

giant_robot_foot_targets( m_sole, n_path_num )
{
    self endon( "death" );
    self waittillmatch( "scripted_walk", "kill_zombies_leftfoot_1" );
    wait 1;
    giant_robot_foot_waittill_sole_shot( m_sole );
    level.robot_foot_has_door[n_path_num] = 0;
}

giant_robot_foot_waittill_sole_shot( m_sole )
{
    self endon( "death" );
    self thread giant_robot_foot_attach_sole( m_sole, "air_glow" );
    m_sole waittill( "damage", amount, inflictor, direction, point, type, tagname, modelname, partname, weaponname, idflags );
    m_sole.health = 99999;
    playfx( level._effect["mechz_death"], m_sole.origin );
    m_sole.e_fx delete();
    m_sole delete();
}

giant_robot_foot_attach_sole( m_sole, fx_glow )
{
    v_fx_pos = self gettagorigin( "tag_foot_hatch_left" );
    m_sole.e_fx = spawn( "script_model", v_fx_pos );
    m_sole.e_fx setmodel( "tag_origin" );
    m_sole.e_fx linkto( self, "tag_foot_hatch_left" );
    m_sole show();
    playfxontag( level._effect[fx_glow], m_sole.e_fx, "tag_origin" );
    level waittill( "giant_robot_deleted" );

    if ( isdefined( m_sole.e_fx ) )
    {
        m_sole.e_fx unlink();
        m_sole.e_fx delete();
    }

    if ( isdefined( m_sole ) )
        m_sole ghost();
}

wait_for_player_teleport()
{
    self sethintstring( &"ZM_TOMB_EXIT_HEAD_TELEPORT" );

    while ( true )
    {
        self waittill( "trigger", player );
        player.teleport_origin = spawn( "script_origin", player.origin );
        old_angles = player.angles;
        player.teleport_origin.angles = player.angles;
        player linkto( player.teleport_origin );
        player freezecontrols( 1 );
        player disableweapons();
        player notify( "teleport" );
        wait_network_frame();
        player thread fadetoblackforxsec( 0, 1, 0, 0.5, "white" );
        player.teleport_origin moveto( player.teleport_initial_origin + vectorscale( ( 0, 0, 1 ), 5000.0 ), 0.05 );
        player.teleport_origin.angles = vectorscale( ( 1, 0, 0 ), 90.0 );
        player.teleport_origin waittill( "movedone" );
        drop_spot = bullettrace( player.teleport_origin.origin, player.teleport_origin.origin + vectorscale( ( 0, 0, -1 ), 10000.0 ), 0, player );
        player.teleport_origin moveto( drop_spot["position"], 4, 2 );
        wait 3;
        player thread fadetoblackforxsec( 0, 1.5, 0.5, 0.5, "black" );
        wait 1;
        player unlink();
        player.teleport_origin delete();
        player.teleport_origin = undefined;
        player setorigin( drop_spot["position"] );
        player setplayerangles( old_angles );
        player enableweapons();
        player enableoffhandweapons();
        player freezecontrols( 0 );
    }
}
