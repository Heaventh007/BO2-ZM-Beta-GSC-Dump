// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zm_tomb_traps;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_laststand;

initpendulumtrap()
{
    flag_init( "flogger_active" );
    penbuytrigger = getentarray( "pendulum_buy_trigger", "targetname" );

    foreach ( t_buy_trig in penbuytrigger )
        t_buy_trig setcursorhint( "HINT_NOICON" );

    for ( i = 0; i < penbuytrigger.size; i++ )
    {
        penbuytrigger[i].lever = getent( penbuytrigger[i].target, "targetname" );
        penbuytrigger[i].pendamagetrig = getent( penbuytrigger[i].lever.target, "targetname" );
        penbuytrigger[i].pen = getent( penbuytrigger[i].pendamagetrig.target, "targetname" );
        penbuytrigger[i].pulley = getent( penbuytrigger[i].pen.target, "targetname" );
    }

    penbuytrigger[0].pendamagetrig enablelinkto();
    penbuytrigger[0].pendamagetrig linkto( penbuytrigger[0].pen );
    level thread maps\mp\zm_tomb_traps::zapper_light_red( "pendulum_light" );
    array_thread( penbuytrigger, ::penthink );
}

moveleverdown()
{
    self.lever rotatepitch( 180, 0.5 );
    self.lever waittill( "rotatedone" );
    self notify( "leverDown" );
}

moveleverup()
{
    self.lever rotatepitch( -180, 0.5 );
    self.lever waittill( "rotatedone" );
    self notify( "leverUp" );
}

flogger_hint_string( str_string )
{
    if ( str_string == &"ZOMBIE_BUTTON_BUY_TRAP" )
    {
        if ( !is_true( self.is_locked ) && !flag( "flogger_active" ) )
        {
            self.is_available = 1;
            self.zombie_cost = 1250;
            self.in_use = 0;
            self sethintstring( str_string, self.zombie_cost );
        }
    }
    else
        self sethintstring( str_string );
}

penthink()
{
    self sethintstring( "" );
    self.is_available = 1;
    self.zombie_cost = 1250;
    self.in_use = 0;
    triggers = getentarray( "pendulum_buy_trigger", "targetname" );

    while ( true )
    {
        array_thread( triggers, ::flogger_hint_string, &"ZOMBIE_BUTTON_BUY_TRAP" );
        self waittill( "trigger", who );

        if ( is_true( self.is_locked ) )
            continue;

        if ( flag( "flogger_active" ) )
            continue;

        self.used_by = who;

        if ( who in_revive_trigger() )
            continue;

        if ( is_player_valid( who ) )
        {
            if ( who.score >= self.zombie_cost )
            {
                if ( !self.in_use )
                {
                    self.in_use = 1;
                    flag_set( "flogger_active" );
                    level thread maps\mp\zm_tomb_traps::zapper_light_red( "pendulum_light" );
                    array_thread( triggers, ::flogger_hint_string, &"ZOMBIE_TRAP_ACTIVE" );
                    play_sound_at_pos( "purchase", who.origin );
                    who thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "level", "trap_log" );
                    who maps\mp\zombies\_zm_score::minus_to_player_score( self.zombie_cost );
                    self thread moveleverdown();
                    self waittill( "leverDown" );
                    wait 0.5;
                    self thread activatepen();
                    self waittill( "penDown" );
                    array_thread( triggers, ::flogger_hint_string, &"ZOMBIE_TRAP_COOLDOWN" );
                    self thread moveleverup();
                    self waittill( "leverUp" );
                    wait 45.0;
                    level thread maps\mp\zm_tomb_traps::zapper_light_green( "pendulum_light" );
                    self.in_use = 0;
                    flag_clear( "flogger_active" );
                }
            }
        }
    }
}

activatepen( motor_left, motor_right, who )
{
    wait_network_frame();
    wait_network_frame();
    self.pen notify( "stopmonitorsolid" );
    self.pen notsolid();
    self.pendamagetrig trigger_on();
    self.pendamagetrig thread pendamage( self, who );
    self.penactive = 1;

    if ( self.script_noteworthy == "1" )
    {
        self.pulley rotateroll( -14040, 30, 6, 6 );
        self.pen rotateroll( -14040, 30, 6, 6 );
    }
    else
    {
        self.pulley rotateroll( 14040, 30, 6, 6 );
        self.pen rotateroll( 14040, 30, 6, 6 );
    }

    self.pen waittill( "rotatedone" );
    self.pendamagetrig trigger_off();
    self.penactive = 0;
    self.pen thread objectsolid();
    self notify( "penDown" );
    level notify( "stop_blade_sounds" );
    wait 3;
}

blade_sounds()
{
    self endon( "rotatedone" );
    blade_left = getent( "blade_left", "targetname" );
    blade_right = getent( "blade_right", "targetname" );
    lastangle = self.angles[0];

    for (;;)
    {
        wooshangle = 90;
        wait 0.01;
        angle = self.angles[0];
        speed = int( abs( angle - lastangle ) ) % 360;
        relpos = int( abs( angle ) ) % 360;
        lastrelpos = int( abs( lastangle ) ) % 360;

        if ( relpos == lastrelpos || speed < 7 )
        {
            lastangle = angle;
            continue;
        }

        if ( relpos > wooshangle && lastrelpos <= wooshangle )
        {
            blade_left playsound( "blade_right" );
            blade_right playsound( "blade_right" );
        }

        if ( ( relpos + 180 ) % 360 > wooshangle && ( lastrelpos + 180 ) % 360 <= wooshangle )
        {
            blade_left playsound( "blade_right" );
            blade_right playsound( "blade_right" );
        }

        lastangle = angle;
    }
}

trap_sounds( motor_left, motor_right, wheel_left, wheel_right )
{
    wait 13;
    motor_left stoploopsound( 2 );
    motor_left playsound( "motor_stop_left" );
    motor_right stoploopsound( 2 );
    motor_right playsound( "motor_stop_right" );
    wait 8;
    wheel_left stoploopsound( 8 );
    wheel_right stoploopsound( 8 );
}

pendamage( parent, who )
{
    level thread customtimer();

    while ( true )
    {
        self waittill( "trigger", ent );

        if ( parent.penactive == 1 )
        {
            if ( isplayer( ent ) && ent getstance() != "prone" )
                ent thread playerpendamage();
            else
                ent thread zombiependamage( parent );
        }
    }
}

customtimer()
{
    level.my_time = 0;

    while ( level.my_time <= 20 )
    {
        wait 0.1;
        level.my_time = level.my_time + 0.1;
    }
}

playerpendamage()
{
    self endon( "death" );
    self endon( "disconnect" );
    a_players = get_players();

    if ( a_players.size == 1 )
    {
        self dodamage( 80, self.origin + vectorscale( ( 0, 0, 1 ), 20.0 ) );
        self setstance( "crouch" );
    }
    else if ( !self maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
        radiusdamage( self.origin, 10, self.health + 100, self.health + 100 );
}

zombiependamage( parent, time )
{
    self endon( "death" );

    if ( flag( "dog_round" ) )
        self.a.nodeath = 1;
    else
    {
        if ( !isdefined( level.numlaunched ) )
            level thread launch_monitor();

        if ( !isdefined( self.flung ) )
        {
            if ( parent.script_noteworthy == "1" )
            {
                x = randomintrange( -50, -35 );
                y = randomintrange( -105, -75 );
                z = randomintrange( 95, 120 );
            }
            else
            {
                x = randomintrange( 30, 50 );
                y = randomintrange( 75, 105 );
                z = randomintrange( 95, 120 );
            }

            if ( level.my_time < 6 )
                adjustment = level.my_time / 6;
            else if ( level.my_time > 24 )
                adjustment = ( 30 - level.my_time ) / 6;
            else
                adjustment = 1;

            x = x * adjustment;
            y = y * adjustment;
            z = z * adjustment;
            self thread do_launch( x, y, z );
        }
    }
}

launch_monitor()
{
    level.numlaunched = 0;

    while ( true )
    {
        wait_network_frame();
        wait_network_frame();
        level.numlaunched = 0;
    }
}

do_launch( x, y, z )
{
    self endon( "death" );
    self.flung = 1;

    while ( level.numlaunched > 4 )
        wait_network_frame();

    self thread play_imp_sound();
    self startragdoll();
    self launchragdoll( ( x, y, z ) );
    level.numlaunched++;
}

play_imp_sound()
{
    self endon( "death" );

    if ( !isdefined( level.numfloggervox ) )
        level thread flogger_vocal_monitor();

    self playsound( "zmb_death_gibs" );
    wait 0.75;
    self dodamage( self.health + 600, self.origin );
}

flogger_vocal_monitor()
{
    while ( true )
    {
        level.numfloggervox = 0;
        wait_network_frame();
        wait_network_frame();
    }
}

objectsolid()
{
    self endon( "stopmonitorsolid" );

    while ( true )
    {
        a_players = get_players();
        b_player_touching = 0;

        for ( i = 0; i < a_players.size; i++ )
        {
            if ( a_players[i] istouching( self ) )
            {
                b_player_touching = 1;
                break;
            }
        }

        if ( !b_player_touching )
        {
            self solid();
            return;
        }

        wait 0.5;
    }
}
