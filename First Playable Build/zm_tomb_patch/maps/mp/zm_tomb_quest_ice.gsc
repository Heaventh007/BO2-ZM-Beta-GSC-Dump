// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_net;

main()
{
    precachemodel( "p6_zm_tm_note_rock_01" );
    precachemodel( "p6_zm_tm_note_rock_02" );
    flag_init( "ice_puzzle_1_complete" );
    flag_init( "ice_puzzle_2_complete" );
    flag_init( "ice_upgrade_available" );
    flag_init( "ice_tile_flipping" );
    ice_puzzle_1_init();
    level thread ice_puzzle_2_init();
    flag_wait( "door_ice_opened" );
    level thread ice_puzzle_1_run();
    flag_wait( "ice_puzzle_1_complete" );
    ice_puzzle_1_cleanup();
    level thread ice_puzzle_2_run();
    flag_wait( "ice_puzzle_2_complete" );
    flag_wait( "staff_water_zm_upgrade_unlocked" );
    level thread ice_chamber_init();
}

ice_chamber_init()
{
    ice_blocker_nodes( 0 );
    ice_blocker_nodes( 1 );
    level thread start_ice_blockers();
}

ice_slider_fx_on()
{
    if ( !isdefined( self.e_fx ) )
    {
        self.e_fx = spawnfx( level._effect["ice_glow"], self.origin );
        triggerfx( self.e_fx );
    }

    flag_wait( "ice_solved" );
    self thread ice_slider_fx_off();
}

ice_slider_fx_off()
{
    if ( isdefined( self.e_fx ) )
        self.e_fx delete();
}

start_ice_blockers()
{
    a_blockers = [];

    for ( i = 0; i < 2; i++ )
    {
        a_blockers[i] = getent( "ice_blocker_" + i, "targetname" );
        a_blockers[i] setmovingplatformenabled( 1 );
        a_blockers[i] thread ice_blockers( i );
        wait 8;
    }
}

ice_blocker_nodes( n_blocker_index )
{
    m_blocker = getent( "ice_blocker_" + n_blocker_index, "targetname" );
    m_blocker.a_nodes_top_a = [];

    for ( i = 0; i < 4; i++ )
        m_blocker.a_nodes_top_a[i] = getnode( "blocker" + n_blocker_index + "_top_" + i + "a", "targetname" );

    m_blocker.a_nodes_top_b = [];

    for ( i = 0; i < 3; i++ )
        m_blocker.a_nodes_top_b[i] = getnode( "blocker" + n_blocker_index + "_top_" + i + "b", "targetname" );

    m_blocker.a_nodes_bottom_a = [];

    for ( i = 0; i < 2; i++ )
        m_blocker.a_nodes_bottom_a[i] = getnode( "blocker" + n_blocker_index + "_bottom_" + i + "a", "targetname" );

    m_blocker.a_nodes_bottom_b = [];

    for ( i = 0; i < 2; i++ )
        m_blocker.a_nodes_bottom_b[i] = getnode( "blocker" + n_blocker_index + "_bottom_" + i + "b", "targetname" );
}

link_ice_blocker_nodes_top( b_link )
{
    if ( b_link )
    {
        for ( i = 0; i < 3; i++ )
        {
            nd_top_a = self.a_nodes_top_a[i];
            nd_top_b = self.a_nodes_top_b[i];
            link_platform_nodes( nd_top_a, nd_top_b );
            n_index_i_next = i + 1;

            if ( n_index_i_next != 3 )
            {
                nd_top_b_next = self.a_nodes_top_b[n_index_i_next];
                link_platform_nodes( nd_top_a, nd_top_b_next );
                nd_top_a_next = self.a_nodes_top_a[n_index_i_next];
                link_platform_nodes( nd_top_a_next, nd_top_b );
            }
        }

        nd_top_a = self.a_nodes_top_a[i];
        nd_top_b = self.a_nodes_top_b[i - 1];
        link_platform_nodes( nd_top_a, nd_top_b );
        self disconnectpaths();
    }
    else
    {
        for ( i = 0; i < 3; i++ )
        {
            nd_top_a = self.a_nodes_top_a[i];
            nd_top_b = self.a_nodes_top_b[i];
            unlink_platform_nodes( nd_top_a, nd_top_b );
            n_index_i_next = i + 1;

            if ( n_index_i_next != 3 )
            {
                nd_top_b_next = self.a_nodes_top_b[n_index_i_next];
                unlink_platform_nodes( nd_top_a, nd_top_b_next );
                nd_top_a_next = self.a_nodes_top_a[n_index_i_next];
                unlink_platform_nodes( nd_top_a_next, nd_top_b );
            }
        }

        nd_top_a = self.a_nodes_top_a[i];
        nd_top_b = self.a_nodes_top_b[i - 1];
        unlink_platform_nodes( nd_top_a, nd_top_b );
        self connectpaths();
    }
}

link_ice_blocker_nodes_bottom( b_link )
{
    if ( b_link )
    {
        for ( i = 0; i < 2; i++ )
        {
            nd_bottom_a = self.a_nodes_bottom_a[i];
            nd_bottom_b = self.a_nodes_bottom_b[i];
            link_platform_nodes( nd_bottom_a, nd_bottom_b );
            n_index_i_next = i + 1;

            if ( n_index_i_next != 2 )
            {
                nd_bottom_a_next = self.a_nodes_bottom_a[n_index_i_next];
                link_platform_nodes( nd_bottom_a_next, nd_bottom_b );
            }
        }

        self disconnectpaths();
    }
    else
    {
        for ( i = 0; i < 2; i++ )
        {
            nd_bottom_a = self.a_nodes_bottom_a[i];
            nd_bottom_b = self.a_nodes_bottom_b[i];
            unlink_platform_nodes( nd_bottom_a, nd_bottom_b );
            n_index_i_next = i + 1;

            if ( n_index_i_next != 2 )
            {
                nd_bottom_a_next = self.a_nodes_bottom_a[n_index_i_next];
                unlink_platform_nodes( nd_bottom_a_next, nd_bottom_b );
            }
        }
    }
}

ice_blockers( n_blocker_index )
{
    self.start_pos = self.origin;

    while ( true )
    {
        self movez( -464, 5 );
        self waittill( "movedone" );
        self disconnectpaths();
        wait 10;
        self movez( -280, 1 );
        self waittill( "movedone" );
        self thread link_ice_blocker_nodes_top( 1 );
        wait 10;
        self drop_warning();
        self thread link_ice_blocker_nodes_top( 0 );
        self movez( -136, 0.5 );
        self waittill( "movedone" );
        self thread link_ice_blocker_nodes_bottom( 1 );
        level thread ice_chamber_rumble();
        wait 10;
        self drop_warning();
        self thread link_ice_blocker_nodes_bottom( 0 );
        self movez( -568, 1 );
        self waittill( "movedone" );
        level thread ice_chamber_rumble();
        self ghost();
        self moveto( self.start_pos, 0.1 );
        self waittill( "movedone" );
        self show();
        level thread ice_chamber_rumble();
        wait 10;
    }
}

ice_blocker_connect_paths()
{
    self movez( -48, 0.1 );
    self waittill( "movedone" );
    self connectpaths();
    self.is_up = 0;
}

ice_blocker_disconnect_paths()
{
    self movez( 48, 0.1 );
    self waittill( "movedone" );
    self disconnectpaths();
    self.is_up = 1;
}

drop_warning()
{
    self movez( -4, 0.1 );
    self waittill( "movedone" );
    wait 1;
    self movez( -4, 0.1 );
    self waittill( "movedone" );
    wait 1;
}

break_thru_floor( n_floor_dist, n_bottom_dist, n_floor_time, n_bottom_time )
{
    self movez( n_floor_dist, n_floor_time );
    self waittill( "movedone" );
    level thread ice_chamber_rumble();
    self.floor_seg delete();
    wait 0.05;
    self movez( n_bottom_dist, n_bottom_time );
    self waittill( "movedone" );
    level thread ice_chamber_rumble();
    self delete();
}

ice_chamber_rumble()
{
    vol_chamber = getent( "zone_ice_chamber", "targetname" );
    vol_anteroom = getent( "zone_ice_anteroom", "targetname" );
    a_players = get_players();

    foreach ( player in a_players )
    {
        if ( player istouching( vol_chamber ) || player istouching( vol_anteroom ) )
        {
            earthquake( 0.2, 1.0, player.origin, 128 );
            player playrumbleonentity( "damage_heavy" );
        }
    }
}

ice_puzzle_1_init()
{
    ice_tiles_randomize();
    a_ceiling_tile_brushes = getentarray( "ice_ceiling_tile", "script_noteworthy" );
    level.unsolved_tiles = a_ceiling_tile_brushes;

    foreach ( tile in a_ceiling_tile_brushes )
    {
        tile.showing_tile_side = 0;
        tile.value = int( tile.script_string );
        tile ceiling_tile_flip();
        tile thread ceiling_tile_process_damage();
    }

    a_ice_ternary_digit_brushes = getentarray( "ice_chamber_digit", "targetname" );

    foreach ( digit in a_ice_ternary_digit_brushes )
    {
        digit ghost();
        digit notsolid();
    }

    level.ternary_digits = [];
    level.ternary_digits[0] = array( -1, 0, -1 );
    level.ternary_digits[1] = array( -1, 1, -1 );
    level.ternary_digits[2] = array( -1, 2, -1 );
    level.ternary_digits[3] = array( 1, -1, 0 );
    level.ternary_digits[4] = array( 1, -1, 1 );
    level.ternary_digits[5] = array( 1, -1, 2 );
    level.ternary_digits[6] = array( 2, -1, 0 );
    level.ternary_digits[7] = array( 2, -1, 1 );
    level.ternary_digits[8] = array( 2, -1, 2 );
    level.ternary_digits[9] = array( 1, 0, 0 );
    level.ternary_digits[10] = array( 1, 0, 1 );
    level.ternary_digits[11] = array( 1, 0, 2 );
    level thread update_ternary_display();
}

ice_puzzle_1_cleanup()
{
    a_ceiling_tile_brushes = getentarray( "ice_ceiling_tile", "script_noteworthy" );

    foreach ( tile in a_ceiling_tile_brushes )
        tile ceiling_tile_flip( 0 );

    a_ice_ternary_digit_brushes = getentarray( "ice_chamber_digit", "targetname" );
    array_delete( a_ice_ternary_digit_brushes );
}

ice_tiles_randomize()
{
    a_original_tiles = getentarray( "ice_tile_original", "targetname" );
    a_original_positions = [];

    foreach ( e_tile in a_original_tiles )
        a_original_positions[a_original_positions.size] = e_tile.origin;

    a_unused_tiles = getentarray( "ice_ceiling_tile", "script_noteworthy" );
    n_total_tiles = a_unused_tiles.size;

    foreach ( v_pos in a_original_positions )
    {
        e_tile = random( a_unused_tiles );
        arrayremovevalue( a_unused_tiles, e_tile, 0 );
        e_tile moveto( v_pos, 0.5, 0.1, 0.1 );
        e_tile waittill( "movedone" );
    }

    assert( a_unused_tiles.size == n_total_tiles - a_original_positions.size );
    array_delete( a_unused_tiles );
}

reset_tiles()
{
    a_ceiling_tile_brushes = getentarray( "ice_ceiling_tile", "script_noteworthy" );

    foreach ( tile in a_ceiling_tile_brushes )
        tile ceiling_tile_flip( 1 );
}

update_ternary_display()
{
    a_ice_ternary_digit_brushes = getentarray( "ice_chamber_digit", "targetname" );
    level endon( "ice_puzzle_1_complete" );

    while ( true )
    {
        level waittill( "update_ice_chamber_digits", newval );

        foreach ( digit in a_ice_ternary_digit_brushes )
        {
            digit ghost();

            if ( isdefined( newval ) )
            {
                digit_slot = int( digit.script_noteworthy );
                shown_value = level.ternary_digits[newval][digit_slot];
                digit_value = int( digit.script_string );

                if ( shown_value == digit_value )
                    digit show();
            }
        }
    }
}

change_ice_gem_value()
{
    ice_gem = getent( "ice_chamber_gem", "targetname" );

    if ( level.unsolved_tiles.size != 0 )
    {
        correct_tile = random( level.unsolved_tiles );
        ice_gem.value = correct_tile.value;
        level notify( "update_ice_chamber_digits", ice_gem.value );
    }
    else
        level notify( "update_ice_chamber_digits", -1 );
}

process_gem_shooting()
{
    level endon( "ice_puzzle_1_complete" );
    ice_gem = getent( "ice_chamber_gem", "targetname" );
    ice_gem.value = -1;
    ice_gem setcandamage( 1 );

    while ( true )
    {
        self waittill( "damage", damage, attacker, direction_vec, point, mod, tagname, modelname, partname, weaponname );

        if ( weaponname == "staff_water_zm" )
            change_ice_gem_value();
    }
}

ice_puzzle_1_run()
{
    level thread process_gem_shooting();
    change_ice_gem_value();
}

ceiling_tile_flip( b_flip_to_tile_side )
{
    if ( !isdefined( b_flip_to_tile_side ) )
        b_flip_to_tile_side = !self.showing_tile_side;

    if ( b_flip_to_tile_side == self.showing_tile_side )
        return;

    self.showing_tile_side = !self.showing_tile_side;
    self rotateroll( 180, 0.5, 0.1, 0.1 );

    if ( !self.showing_tile_side )
        arrayremovevalue( level.unsolved_tiles, self, 0 );
    else
        level.unsolved_tiles[level.unsolved_tiles.size] = self;

    if ( level.unsolved_tiles.size == 0 )
        flag_set( "ice_puzzle_1_complete" );
}

ceiling_tile_process_damage()
{
    level endon( "ice_puzzle_1_complete" );
    ice_gem = getent( "ice_chamber_gem", "targetname" );
    self setcandamage( 1 );
    ice_gem setcandamage( 1 );

    while ( true )
    {
        self waittill( "damage", damage, attacker, direction_vec, point, mod, tagname, modelname, partname, weaponname );

        if ( issubstr( weaponname, "water" ) && self.showing_tile_side && !flag( "ice_tile_flipping" ) )
        {
            flag_set( "ice_tile_flipping" );

            if ( ice_gem.value == self.value )
                self ceiling_tile_flip( 0 );
            else
                reset_tiles();

            change_ice_gem_value();
            wait 2.0;
            flag_clear( "ice_tile_flipping" );
        }
    }
}

ice_puzzle_2_init()
{

}

ice_puzzle_2_run()
{
    a_stone_positions = getstructarray( "puzzle_stone_water", "targetname" );
    level.ice_stones_remaining = a_stone_positions.size;
    array_thread( a_stone_positions, ::ice_stone_run );
}

ice_stone_run()
{
    v_up = anglestoup( self.angles );
    v_spawn_pos = self.origin - 64 * v_up;
    self.e_model = spawn( "script_model", v_spawn_pos );
    self.e_model.angles = self.angles;
    self.e_model setmodel( "p6_zm_tm_note_rock_01" );
    self.e_model moveto( self.origin, 1.0, 0.5, 0.5 );
    playfx( level._effect["digging"], self.origin );
    self.e_model setcandamage( 1 );
    playfxontag( level._effect["ice_drip"], self.e_model, "tag_origin" );

    while ( !flag( "ice_puzzle_2_complete" ) )
    {
        self.e_model waittill( "damage", amount, inflictor, direction, point, type, tagname, modelname, partname, weaponname, idflags );

        if ( issubstr( weaponname, "water" ) )
            break;
    }

    self.e_model delete();
    self.e_model = spawn( "script_model", self.origin );
    self.e_model.angles = self.angles;
    self.e_model setmodel( "p6_zm_tm_note_rock_02" );
    self.e_model moveto( self.origin, 1.0, 0.5, 0.5 );
    self.e_model setcandamage( 1 );

    while ( !flag( "ice_puzzle_2_complete" ) )
    {
        self.e_model waittill( "damage", amount, inflictor, direction, point, type, tagname, modelname, partname, weaponname, idflags );

        if ( !issubstr( weaponname, "staff" ) && issubstr( type, "BULLET" ) )
            break;
    }

    self.e_model delete();
    playfx( level._effect["ice_explode"], self.origin, anglestoforward( self.angles ), anglestoup( self.angles ) );
    level.ice_stones_remaining--;

    if ( level.ice_stones_remaining <= 0 )
    {
        flag_set( "ice_puzzle_2_complete" );
        level thread play_puzzle_stinger_on_all_players();
        level.weather_snow = 5;
        level.weather_rain = 0;

        foreach ( player in getplayers() )
            player set_weather_to_player();

        wait 5.0;
        level.weather_snow = 0;
        level.weather_rain = 0;

        foreach ( player in getplayers() )
            player set_weather_to_player();
    }
}
