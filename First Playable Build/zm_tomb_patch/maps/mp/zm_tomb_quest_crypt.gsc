// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_unitrigger;

main()
{
    precachemodel( "p6_power_lever" );
    flag_init( "staff_air_zm_upgrade_unlocked" );
    flag_init( "staff_water_zm_upgrade_unlocked" );
    flag_init( "staff_fire_zm_upgrade_unlocked" );
    flag_init( "staff_lightning_zm_upgrade_unlocked" );
    flag_wait( "chamber_entrance_opened" );
    chamber_disc_puzzle_init();
}

chamber_disc_puzzle_init()
{
    init_crypt_gems();
    chamber_discs = getentarray( "crypt_puzzle_disc", "script_noteworthy" );
    array_thread( chamber_discs, ::chamber_disc_run );
    flag_init( "disc_rotation_active", 0 );
    chamber_discs_randomize();
    level.gem_start_pos = [];
    level.gem_start_pos["crypt_gem_fire"] = 0;
    level.gem_start_pos["crypt_gem_air"] = 1;
    level.gem_start_pos["crypt_gem_ice"] = 2;
    level.gem_start_pos["crypt_gem_elec"] = 3;
}

chamber_disc_run()
{
    self.position = 0;
    a_lever_positions = getstructarray( self.target, "targetname" );

    foreach ( s_pos in a_lever_positions )
    {
        s_pos.trigger_stub = spawnstruct();
        s_pos.trigger_stub.origin = s_pos.origin + vectorscale( ( 0, 0, 1 ), 12.0 );
        s_pos.trigger_stub.radius = 35;
        s_pos.trigger_stub.cursor_hint = "HINT_NOICON";
        s_pos.trigger_stub.hint_string = "";
        s_pos.trigger_stub.script_unitrigger_type = "unitrigger_radius_use";
        s_pos.trigger_stub.require_look_at = 0;
        maps\mp\zombies\_zm_unitrigger::register_unitrigger( s_pos.trigger_stub, ::crypt_switch_unitrigger_think );
        s_pos.model = spawn( "script_model", s_pos.origin );
        s_pos.model.angles = s_pos.angles;
        s_pos.model setmodel( "p6_power_lever" );
        clockwise = !isdefined( s_pos.script_string ) && !isdefined( "clockwise" ) || isdefined( s_pos.script_string ) && isdefined( "clockwise" ) && s_pos.script_string == "clockwise";
        s_pos.trigger_stub thread chamber_disc_trigger_run( self, s_pos.model, clockwise );
    }
}

crypt_switch_unitrigger_think()
{
    self endon( "kill_trigger" );

    while ( true )
    {
        self waittill( "trigger", player );
        self.stub notify( "trigger", player );
    }
}

init_crypt_gems()
{
    disc = getent( "crypt_puzzle_disc_main", "targetname" );
    gems = getentarray( "crypt_gem", "script_noteworthy" );

    foreach ( gem in gems )
    {
        gem linkto( disc );
        gem thread run_crypt_gem_pos();
    }
}

crypt_gem_beam_fx( v_start, v_end )
{
    e_fx = spawn( "script_model", v_start );
    e_fx setmodel( "tag_origin" );
    wait 1;
    playfxontag( level._effect["crypt_gem_beam"], e_fx, "tag_origin" );
    e_fx moveto( v_end, 3.0 );
    e_fx waittill( "movedone" );
    e_fx delete();
}

run_crypt_gem_pos()
{
    str_weapon = undefined;
    complete_flag = undefined;
    str_orb_path = undefined;
    str_glow_fx = undefined;

    switch ( self.targetname )
    {
        case "crypt_gem_air":
            str_weapon = "staff_air_zm";
            complete_flag = "staff_air_zm_upgrade_unlocked";
            str_orb_path = "air_orb_exit_path";
            str_glow_fx = "air_glow";
            str_final_pos = "air_orb_plinth_final";
            break;
        case "crypt_gem_ice":
            str_weapon = "staff_water_zm";
            complete_flag = "staff_water_zm_upgrade_unlocked";
            str_orb_path = "ice_orb_exit_path";
            str_glow_fx = "ice_glow";
            str_final_pos = "ice_orb_plinth_final";
            break;
        case "crypt_gem_fire":
            str_weapon = "staff_fire_zm";
            complete_flag = "staff_fire_zm_upgrade_unlocked";
            str_orb_path = "fire_orb_exit_path";
            str_glow_fx = "fire_glow";
            str_final_pos = "fire_orb_plinth_final";
            break;
        case "crypt_gem_elec":
            str_weapon = "staff_lightning_zm";
            complete_flag = "staff_lightning_zm_upgrade_unlocked";
            str_orb_path = "lightning_orb_exit_path";
            str_glow_fx = "elec_glow";
            str_final_pos = "lightning_orb_plinth_final";
            break;
        default:
/#
            assertmsg( "Unknown crypt gem targetname: " + self.targetname );
#/
            return;
    }

    e_gem_model = puzzle_orb_chamber_to_crypt( str_orb_path, self );
    e_main_disc = getent( "crypt_puzzle_disc_main", "targetname" );
    e_gem_model linkto( e_main_disc );
    str_targetname = self.targetname;
    self delete();
    e_gem_model setcandamage( 1 );

    while ( true )
    {
        e_gem_model waittill( "damage", damage, attacker, direction_vec, point, mod, tagname, modelname, partname, weaponname );

        if ( weaponname == str_weapon )
            break;
    }

    playfxontag( level._effect[str_glow_fx], e_gem_model, "tag_origin" );

    while ( true )
    {
        if ( chamber_disc_gem_has_clearance( str_targetname ) )
            break;

        level waittill( "crypt_disc_rotation" );
    }

    playfxontag( level._effect["puzzle_orb_trail"], e_gem_model, "tag_origin" );
    playfxontag( level._effect[str_glow_fx], e_gem_model, "tag_origin" );
    flag_set( "disc_rotation_active" );
    puzzle_orb_pillar_show( 1 );
    e_gem_model unlink();
    s_ascent = getstruct( "orb_crypt_ascent_path", "targetname" );
    v_next_pos = ( e_gem_model.origin[0], e_gem_model.origin[1], s_ascent.origin[2] );
    e_gem_model puzzle_orb_move( v_next_pos );
    flag_clear( "disc_rotation_active" );
    level thread chamber_discs_randomize();
    e_gem_model puzzle_orb_follow_path( s_ascent );
    v_next_pos = ( e_gem_model.origin[0], e_gem_model.origin[1], e_gem_model.origin[2] + 800 );
    e_gem_model puzzle_orb_move( v_next_pos );
    puzzle_orb_pillar_show( 0 );
    s_chamber_path = getstruct( str_orb_path, "targetname" );
    e_gem_model puzzle_orb_follow_path_reverse( s_chamber_path, vectorscale( ( 0, 0, 1 ), 800.0 ) );
    s_final = getstruct( str_final_pos, "targetname" );
    e_gem_model puzzle_orb_move( s_final.origin );
    e_new_gem = spawn( "script_model", s_final.origin );
    e_new_gem setmodel( e_gem_model.model );
    playfxontag( level._effect[str_glow_fx], e_new_gem, "tag_origin" );
    e_gem_model delete();
    flag_set( complete_flag );
}

chamber_disc_move_to_position()
{
    new_angles = ( self.angles[0], self.position * 90, self.angles[2] );
    self rotateto( new_angles, 0.5, 0.1, 0.1 );
}

chamber_discs_move_all_to_position( discs )
{
    if ( !isdefined( discs ) )
        discs = undefined;

    if ( !isdefined( discs ) )
        discs = getentarray( "chamber_puzzle_disc", "script_noteworthy" );

    array_thread( discs, ::chamber_disc_move_to_position );
}

chamber_disc_get_gem_position( gem_name )
{
    disc = getent( "crypt_puzzle_disc_main", "targetname" );
    return ( disc.position + level.gem_start_pos[gem_name] ) % 4;
}

chamber_disc_gem_has_clearance( gem_name )
{
    gem_position = chamber_disc_get_gem_position( gem_name );
    discs = getentarray( "crypt_puzzle_disc", "script_noteworthy" );

    foreach ( disc in discs )
    {
        if ( !isdefined( disc.targetname ) && !isdefined( "crypt_puzzle_disc_main" ) || isdefined( disc.targetname ) && isdefined( "crypt_puzzle_disc_main" ) && disc.targetname == "crypt_puzzle_disc_main" )
            continue;

        if ( disc.position != gem_position )
            return false;
    }

    return true;
}

chamber_disc_rotate( b_clockwise )
{
    if ( b_clockwise )
        self.position = ( self.position + 1 ) % 4;
    else
        self.position = ( self.position + 3 ) % 4;

    self chamber_disc_move_to_position();
}

chamber_discs_randomize()
{
    discs = getentarray( "crypt_puzzle_disc", "script_noteworthy" );
    prev_disc_pos = 0;

    foreach ( disc in discs )
    {
        disc.position = ( prev_disc_pos + randomintrange( 1, 3 ) ) % 4;
        prev_disc_pos = disc.position;
    }

    chamber_discs_move_all_to_position( discs );
}

chamber_disc_trigger_run( e_disc, e_lever, b_clockwise )
{
    discs_to_rotate = array( e_disc );

    while ( true )
    {
        self waittill( "trigger" );

        if ( !flag( "disc_rotation_active" ) )
        {
            flag_set( "disc_rotation_active" );
            e_lever rotateroll( -45, 0.2, 0, 0 );
            array_thread( discs_to_rotate, ::chamber_disc_rotate, b_clockwise );
            wait 0.5;
            e_lever rotateroll( 45, 0.2, 0, 0 );
            e_lever waittill( "rotatedone" );
            flag_clear( "disc_rotation_active" );
        }

        level notify( "crypt_disc_rotation" );
    }
}
