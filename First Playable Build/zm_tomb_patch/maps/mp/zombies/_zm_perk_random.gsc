// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_score;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_perks;

init()
{
    level._random_zombie_perk_cost = 2500;
    level thread precache();
    level thread precache_random_perk();
    registerclientfield( "scriptmover", "perk_bottle_cycle_state", 14000, 2, "int" );
    registerclientfield( "scriptmover", "turn_on_perk_light", 14000, 1, "int" );
    registerclientfield( "scriptmover", "turn_active_perk_light", 14000, 1, "int" );
    level._effect["perk_machine_light"] = loadfx( "maps/zombie_tomb/fx_tomb_dieselmagic_light" );
    level._effect["perk_machine_light_on"] = loadfx( "maps/zombie_tomb/fx_tomb_dieselmagic_on" );
}

#using_animtree("zm_perk_random");

init_animtree()
{
    scriptmodelsuseanimtree( #animtree );
}

start_random_machine()
{
    level thread machines_setup();
    level thread machine_selector();
}

precache()
{
    precachemodel( "p6_zm_vending_diesel_magic" );
}

machines_setup()
{
    level waittill( "start_of_round" );
    level.perk_bottle_weapon_array = arraycombine( level.machine_assets, level._custom_perks, 0, 1 );
    start_machines = getentarray( "start_machine", "script_noteworthy" );
    assert( isdefined( start_machines.size != 0 ), "missing start random perk machine" );

    if ( start_machines.size == 1 )
        level.random_perk_start_machine = start_machines[0];
    else
        level.random_perk_start_machine = start_machines[randomint( start_machines.size )];

    machines = getentarray( "random_perk_machine", "targetname" );

    foreach ( machine in machines )
    {
        machine.use_trigger = getent( machine.target, "targetname" );
        machine.use_trigger sethintstring( &"ZM_TOMB_RANDOM_PERK_BUY", level._random_zombie_perk_cost );
        assert( isdefined( machine.use_trigger ), "missing random perk machine use trigger" );
        spawn_location = spawn( "script_model", machine.origin );
        spawn_location setmodel( "tag_origin" );
        spawn_location.angles = machine.angles;
        forward_dir = anglestoright( machine.angles );
        spawn_location.origin = spawn_location.origin + vectorscale( ( 0, 0, 1 ), 40.0 );
        machine setclientfield( "turn_on_perk_light", 1 );
        machine.bottle_spawn_location = spawn_location;
        machine useanimtree( #animtree );

        if ( machine != level.random_perk_start_machine )
        {
            machine.use_trigger setinvisibletoall();
            continue;
        }

        machine thread machine_think();
    }
}

machine_think()
{
    self show();
    self.use_trigger setvisibletoall();
    self.num_time_used = 0;
    self.num_til_moved = randomintrange( 4, 7 );

    while ( isdefined( self.use_trigger.is_locked ) && self.use_trigger.is_locked )
        wait 1;

    self thread update_animation( "start" );
    self setclientfield( "turn_active_perk_light", 1 );

    while ( true )
    {
        self.use_trigger waittill( "trigger", player );

        if ( player.score < level._random_zombie_perk_cost )
        {
            self playsound( "evt_perk_deny" );
            player maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "perk_deny", undefined, 0 );
            continue;
        }

        if ( player.num_perks >= 4 )
        {
            self playsound( "evt_perk_deny" );
            player maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "sigh" );
            continue;
        }

        if ( self.num_time_used >= self.num_til_moved )
        {
            self.use_trigger setinvisibletoall();
            self thread update_animation( "shut_down" );
            level notify( "random_perk_moving" );
            self setclientfield( "turn_active_perk_light", 0 );
            break;
        }

        self.num_time_used++;
        player maps\mp\zombies\_zm_score::minus_to_player_score( level._random_zombie_perk_cost );
        self.use_trigger setinvisibletoall();
        self thread update_animation( "in_use" );

        while ( true )
        {
            random_perk = get_random_perk();
            self thread start_perk_bottle_cycling();

            if ( player hasperk( random_perk ) )
                continue;
            else
            {
                model = get_perk_weapon_model( random_perk );
                wait 3;
                self notify( "done_cycling" );
                self.bottle_spawn_location setmodel( model );
                self thread grab_check( player, random_perk );
                self thread time_out_check();
                self waittill_either( "grab_check", "time_out_check" );
                self.bottle_spawn_location setclientfield( "perk_bottle_cycle_state", 0 );
                self.bottle_spawn_location setmodel( "tag_origin" );
                self.use_trigger sethintstring( &"ZM_TOMB_RANDOM_PERK_BUY", level._random_zombie_perk_cost );
                self.use_trigger setvisibletoall();
                self thread update_animation( "idle" );
                break;
            }
        }
    }
}

grab_check( player, random_perk )
{
    self endon( "time_out_check" );
    self.use_trigger sethintstring( &"ZM_TOMB_RANDOM_PERK_PICKUP" );
    self.use_trigger setvisibletoplayer( player );
    self.use_trigger waittill( "trigger" );
    self notify( "grab_check" );
    self notify( "time_out_or_perk_grab" );
    gun = player maps\mp\zombies\_zm_perks::perk_give_bottle_begin( random_perk );
    evt = player waittill_any_return( "fake_death", "death", "player_downed", "weapon_change_complete" );

    if ( evt == "weapon_change_complete" )
        player thread maps\mp\zombies\_zm_perks::wait_give_perk( random_perk, 1 );

    player maps\mp\zombies\_zm_perks::perk_give_bottle_end( gun, random_perk );
}

time_out_check()
{
    self endon( "grab_check" );
    wait 10;
    self notify( "time_out_check" );
}

machine_selector()
{
    while ( true )
    {
        level waittill( "random_perk_moving" );
        machines = getentarray( "random_perk_machine", "targetname" );

        if ( machines.size == 1 )
        {
            new_machine = machines[0];
            new_machine thread machine_think();
            continue;
        }

        for ( new_machine = machines[randomint( machines.size )]; new_machine == level.random_perk_start_machine; new_machine = machines[randomint( machines.size )] )
        {

        }

        level.random_perk_start_machine = new_machine;
        wait 10;
        new_machine thread machine_think();
    }
}

precache_random_perk()
{
    level._random_perk_machine_perk_list = [];
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_armorvest";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_quickrevive";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_fastreload";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_rof";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_longersprint";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_deadshot";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_additionalprimaryweapon";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_flakjacket";
    level._random_perk_machine_perk_list[level._random_perk_machine_perk_list.size] = "specialty_grenadepulldeath";
}

get_random_perk()
{
    random_perk = level._random_perk_machine_perk_list[randomint( level._random_perk_machine_perk_list.size )];
    return random_perk;
}

start_perk_bottle_cycling()
{
    self endon( "done_cycling" );
    array_key = getarraykeys( level.perk_bottle_weapon_array );
    timer = 0;
    self.bottle_spawn_location setclientfield( "perk_bottle_cycle_state", 1 );

    while ( true )
    {
        for ( i = 0; i < array_key.size; i++ )
        {
            if ( isdefined( level.perk_bottle_weapon_array[array_key[i]].weapon ) )
                model = getweaponmodel( level.perk_bottle_weapon_array[array_key[i]].weapon );
            else
                model = getweaponmodel( level.perk_bottle_weapon_array[array_key[i]].perk_bottle );

            self.bottle_spawn_location setmodel( model );
            wait 0.2;
        }
    }
}

get_perk_weapon_model( perk )
{
    switch ( perk )
    {
        case " _upgrade":
        case "specialty_armorvest":
            weapon = level.machine_assets["juggernog"].weapon;
            break;
        case "specialty_quickrevive":
        case "specialty_quickrevive_upgrade":
            weapon = level.machine_assets["revive"].weapon;
            break;
        case "specialty_fastreload":
        case "specialty_fastreload_upgrade":
            weapon = level.machine_assets["speedcola"].weapon;
            break;
        case "specialty_rof":
        case "specialty_rof_upgrade":
            weapon = level.machine_assets["doubletap"].weapon;
            break;
        case "specialty_longersprint":
        case "specialty_longersprint_upgrade":
            weapon = level.machine_assets["marathon"].weapon;
            break;
        case "specialty_flakjacket":
        case "specialty_flakjacket_upgrade":
            weapon = level.machine_assets["divetonuke"].weapon;
            break;
        case "specialty_deadshot":
        case "specialty_deadshot_upgrade":
            weapon = level.machine_assets["deadshot"].weapon;
            break;
        case "specialty_additionalprimaryweapon":
        case "specialty_additionalprimaryweapon_upgrade":
            weapon = level.machine_assets["additionalprimaryweapon"].weapon;
            break;
        case "specialty_scavenger":
        case "specialty_scavenger_upgrade":
            weapon = level.machine_assets["tombstone"].weapon;
            break;
        case "specialty_finalstand":
        case "specialty_finalstand_upgrade":
            weapon = level.machine_assets["whoswho"].weapon;
            break;
    }

    if ( isdefined( level._custom_perks[perk] ) && isdefined( level._custom_perks[perk].perk_bottle ) )
        weapon = level._custom_perks[perk].perk_bottle;

    return getweaponmodel( weapon );
}

update_animation( animation )
{
    switch ( animation )
    {
        case "start":
            self clearanim( %root, 0.2 );
            self setanim( %o_zombie_dlc4_vending_diesel_turn_on, 1, 0.2, 1 );
            break;
        case "shut_down":
            self clearanim( %root, 0.2 );
            self setanim( %o_zombie_dlc4_vending_diesel_turn_off, 1, 0.2, 1 );
            break;
        case "in_use":
            self clearanim( %root, 0.2 );
            self setanim( %o_zombie_dlc4_vending_diesel_ballspin_loop, 1, 0.2, 1 );
            break;
        case "idle":
            self clearanim( %root, 0.2 );
            self setanim( %o_zombie_dlc4_vending_diesel_on_idle, 1, 0.2, 1 );
            break;
        default:
            self clearanim( %root, 0.2 );
            self setanim( %o_zombie_dlc4_vending_diesel_on_idle, 1, 0.2, 1 );
            break;
    }
}
