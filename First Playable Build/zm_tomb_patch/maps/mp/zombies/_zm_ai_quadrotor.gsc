// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include animscripts\utility;
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_equipment;
#include maps\mp\zombies\_zm_laststand;

precache()
{
    precachemodel( "veh_t6_dlc_zm_quadrotor" );
    precachevehicle( "heli_quadrotor_zm" );
}

init()
{
    level._effect["quadrotor_damage04"] = loadfx( "destructibles/fx_quadrotor_damagestate04" );
    level._effect["quadrotor_nudge"] = loadfx( "destructibles/fx_quadrotor_nudge01" );
    level._effect["qd_revive"] = loadfx( "maps/zombie_tomb/fx_tomb_veh_quadrotor_revive_health" );
    maps\mp\zombies\_zm_equipment::register_equipment( "equip_dieseldrone_zm", &"ZOMBIE_TOMB_EQUIP_DIESELDRONE_PICKUP_HINT_STRING", &"ZM_TOMB_EQUIP_DIESELDRONE_HOWTO", "riotshield_zm_icon", "riotshield" );
}

quadrotor_dealt_no_damage_to_player( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime )
{
    if ( isdefined( sweapon ) && sweapon == "quadrotorturret_zm" )
        return 0;

    return idamage;
}

quadrotor_think()
{
    self enableaimassist();
    self sethoverparams( 25.0, 60.0, 40 );
    self setneargoalnotifydist( 30 );
    self.flyheight = getdvarfloat( #"g_quadrotorFlyHeight" );
    self setvehicleavoidance( 1 );
    self.vehfovcosine = 0;
    self.vehfovcosinebusy = 0.574;
    self.vehaircraftcollisionenabled = 1;

    if ( !isdefined( self.goalradius ) )
        self.goalradius = 256;

    if ( !isdefined( self.goalpos ) )
        self.goalpos = self.origin;

    self thread quadrotor_death();
    self thread quadrotor_damage();
    quadrotor_start_ai();
    self thread quadrotor_set_team( "allies" );
}

follow_ent( e_followee )
{
    self endon( "death" );

    while ( isdefined( e_followee ) )
    {
        v_facing = e_followee getplayerangles();
        v_forward = anglestoforward( ( 0, v_facing[1], 0 ) );
        self.goalpos = e_followee.origin + v_forward * 256;
        wait( randomfloatrange( 2.0, 3.0 ) );
    }
}

quadrotor_start_ai()
{
    self.goalpos = self.origin;
    quadrotor_main();
}

quadrotor_main()
{
    self thread quadrotor_blink_lights();
    self thread quadrotor_fireupdate();
    self thread quadrotor_movementupdate();
    self thread quadrotor_collision();
}

quadrotor_fireupdate()
{
    self endon( "death" );

    while ( true )
    {
        if ( isdefined( self.enemy ) && self vehcansee( self.enemy ) )
        {
            if ( distancesquared( self.enemy.origin, self.origin ) < 1638400 )
            {
                self setturrettargetent( self.enemy );
                self quadrotor_fire_for_time( randomfloatrange( 1.0, 2.0 ) );
            }

            if ( isdefined( self.enemy ) && isai( self.enemy ) )
                wait( randomfloatrange( 0.5, 1.0 ) );
            else
                wait( randomfloatrange( 0.5, 1.5 ) );
        }
        else
            wait 0.4;
    }
}

quadrotor_check_move( position )
{
    results = physicstrace( self.origin, position, ( -15, -15, -5 ), ( 15, 15, 5 ) );

    if ( results["fraction"] == 1 )
        return true;

    return false;
}

quadrotor_adjust_goal_for_enemy_height( goalpos )
{
    if ( isdefined( self.enemy ) )
    {
        if ( isai( self.enemy ) )
            offset = 45;
        else
            offset = -100;

        if ( self.enemy.origin[2] + offset > goalpos[2] )
        {
            goal_z = self.enemy.origin[2] + offset;

            if ( goal_z > goalpos[2] + 400 )
                goal_z = goalpos[2] + 400;

            results = physicstrace( goalpos, ( goalpos[0], goalpos[1], goal_z ), ( -15, -15, -5 ), ( 15, 15, 5 ) );

            if ( results["fraction"] == 1 )
                goalpos = ( goalpos[0], goalpos[1], goal_z );
        }
    }

    return goalpos;
}

make_sure_goal_is_well_above_ground( pos )
{
    start = pos + ( 0, 0, self.flyheight );
    end = pos + ( 0, 0, self.flyheight * -1 );
    trace = bullettrace( start, end, 0, self, 0, 0 );
    end = trace["position"];
    pos = end + ( 0, 0, self.flyheight );
    z = self getheliheightlockheight( pos );
    pos = ( pos[0], pos[1], z );
    return pos;
}

waittill_pathing_done()
{
    self endon( "death" );
    self endon( "change_state" );

    if ( self.vehonpath )
        self waittill_any( "near_goal", "reached_end_node", "force_goal" );
}

quadrotor_movementupdate()
{
    self endon( "death" );
    self endon( "change_state" );
    assert( isalive( self ) );
    a_powerups = [];
    old_goalpos = self.goalpos;
    self.goalpos = self make_sure_goal_is_well_above_ground( self.goalpos );

    if ( !self.vehonpath )
    {
        if ( isdefined( self.attachedpath ) )
            self script_delay();
        else if ( distancesquared( self.origin, self.goalpos ) < 10000 && ( self.goalpos[2] > old_goalpos[2] + 10 || self.origin[2] + 10 < self.goalpos[2] ) )
        {
            self setvehgoalpos( self.goalpos, 1 );
            self pathvariableoffset( vectorscale( ( 0, 0, 1 ), 20.0 ), 2 );
            self waittill_any_or_timeout( 4, "near_goal", "force_goal" );
        }
        else
        {
            goalpos = self quadrotor_get_closest_node();
            self setvehgoalpos( goalpos, 1 );
            self waittill_any_or_timeout( 2, "near_goal", "force_goal" );
        }
    }

    assert( isalive( self ) );
    self setvehicleavoidance( 1 );
    goalfailures = 0;

    while ( true )
    {
        self waittill_pathing_done();
        self thread quadrotor_blink_lights();

        if ( !isdefined( self.revive_target ) )
        {
            player = self player_in_last_stand_within_range( 500 );

            if ( isdefined( player ) )
            {
                self.revive_target = player;
                player.quadrotor_revive = 1;
            }
        }

        if ( isdefined( self.revive_target ) )
        {
            origin = self.revive_target.origin;
            origin = ( origin[0], origin[1], origin[2] + 150 );
            z = self getheliheightlockheight( origin );
            origin = ( origin[0], origin[1], z );

            if ( self setvehgoalpos( origin, 1, 2, 1 ) )
            {
                self waittill_any( "near_goal", "force_goal", "reached_end_node" );
                level thread watch_for_fail_revive( self );
                wait 1;

                if ( isdefined( self.revive_target ) && self.revive_target maps\mp\zombies\_zm_laststand::player_is_in_laststand() )
                {
                    playfxontag( level._effect["staff_charge"], self.revive_target, "tag_origin" );
                    self.revive_target notify( "remote_revive", self.player_owner );
                }

                self.revive_target = undefined;
                self setvehgoalpos( origin, 1 );
                wait 1;
                continue;
            }
            else
                player.quadrotor_revive = undefined;

            wait 0.1;
        }

        a_powerups = [];

        if ( level.active_powerups.size > 0 && isdefined( self.player_owner ) )
            a_powerups = get_array_of_closest( self.player_owner.origin, level.active_powerups, undefined, undefined, 500 );

        if ( a_powerups.size > 0 )
        {
            b_got_powerup = 0;

            foreach ( powerup in a_powerups )
            {
                if ( self setvehgoalpos( powerup.origin, 1, 2, 1 ) )
                {
                    self waittill_any( "near_goal", "force_goal", "reached_end_node" );

                    if ( isdefined( powerup ) )
                    {
                        self.player_owner.ignore_range_powerup = powerup;
                        b_got_powerup = 1;
                    }

                    wait 1;
                    break;
                }
            }

            if ( b_got_powerup )
                continue;

            wait 0.1;
        }

        goalpos = quadrotor_find_new_position();
        goalpos = quadrotor_adjust_goal_for_enemy_height( goalpos );

        if ( self setvehgoalpos( goalpos, 1, 2, 1 ) )
        {
            goalfailures = 0;

            if ( isdefined( self.goal_node ) )
                self.goal_node.quadrotor_claimed = 1;

            if ( isdefined( self.enemy ) && self vehcansee( self.enemy ) )
            {
                if ( randomint( 100 ) > 50 )
                    self setlookatent( self.enemy );
            }

            self waittill_any_timeout( 12, "near_goal", "force_goal", "reached_end_node" );

            if ( isdefined( self.enemy ) && self vehcansee( self.enemy ) )
            {
                self setlookatent( self.enemy );
                wait( randomfloatrange( 1, 4 ) );
                self clearlookatent();
            }

            if ( isdefined( self.goal_node ) )
                self.goal_node.quadrotor_claimed = undefined;
        }
        else
        {
            goalfailures++;

            if ( isdefined( self.goal_node ) )
                self.goal_node.quadrotor_fails = 1;

            if ( goalfailures == 1 )
            {
                wait 0.5;
                continue;
            }
            else if ( goalfailures == 2 )
                goalpos = self.origin;
            else if ( goalfailures == 3 )
            {
                goalpos = self quadrotor_get_closest_node();
                self setvehgoalpos( goalpos, 1 );
                self waittill( "near_goal" );
            }
            else if ( goalfailures > 3 )
            {
/#
                println( "WARNING: Quadrotor can't find path to goal over 4 times." + self.origin + " " + goalpos );
                line( self.origin, goalpos, ( 1, 1, 1 ), 1, 100 );
#/
                self.goalpos = make_sure_goal_is_well_above_ground( goalpos );
            }

            old_goalpos = goalpos;
            offset = ( randomfloatrange( -50, 50 ), randomfloatrange( -50, 50 ), randomfloatrange( 50, 150 ) );
            goalpos = goalpos + offset;
            goalpos = quadrotor_adjust_goal_for_enemy_height( goalpos );

            if ( self quadrotor_check_move( goalpos ) )
            {
                self setvehgoalpos( goalpos, 1 );
                self waittill_any( "near_goal", "force_goal", "start_vehiclepath" );
                wait( randomfloatrange( 1, 3 ) );

                if ( !self.vehonpath )
                {
                    self setvehgoalpos( old_goalpos, 1 );
                    self waittill_any( "near_goal", "force_goal", "start_vehiclepath" );
                }
            }

            wait 0.5;
        }
    }
}

quadrotor_get_closest_node()
{
    nodes = getnodesinradiussorted( self.origin, 200, 0, 500, "Path" );

    if ( nodes.size == 0 )
        nodes = getnodesinradiussorted( self.goalpos, 3000, 0, 2000, "Path" );

    foreach ( node in nodes )
    {
        if ( node.type == "BAD NODE" || !node has_spawnflag( 2097152 ) )
            continue;

        return make_sure_goal_is_well_above_ground( node.origin );
    }

    return self.origin;
}

quadrotor_find_new_position()
{
    if ( !isdefined( self.goalpos ) )
        self.goalpos = self.origin;

    origin = self.goalpos;
    nodes = getnodesinradius( self.goalpos, self.goalradius, 0, self.flyheight + 300, "Path" );

    if ( nodes.size == 0 )
        nodes = getnodesinradius( self.goalpos, self.goalradius + 1000, 0, self.flyheight + 1000, "Path" );

    if ( nodes.size == 0 )
        nodes = getnodesinradius( self.goalpos, self.goalradius + 5000, 0, self.flyheight + 4000, "Path" );

    best_node = undefined;
    best_score = 0;

    foreach ( node in nodes )
    {
        if ( node.type == "BAD NODE" || !node has_spawnflag( 2097152 ) )
            continue;

        if ( isdefined( node.quadrotor_fails ) || isdefined( node.quadrotor_claimed ) )
            score = randomfloat( 30 );
        else
            score = randomfloat( 100 );

        if ( score > best_score )
        {
            best_score = score;
            best_node = node;
        }
    }

    if ( isdefined( best_node ) )
    {
        origin = best_node.origin + ( 0, 0, self.flyheight + randomfloatrange( -30, 40 ) );
        z = self getheliheightlockheight( origin );
        origin = ( origin[0], origin[1], z );
        self.goal_node = best_node;
    }

    return origin;
}

quadrotor_teleport_to_nearest_node()
{
    self.origin = self quadrotor_get_closest_node();
}

quadrotor_get_damage_effect( health_pct )
{
    if ( health_pct < 0.25 )
        return level._effect["quadrotor_damage04"];

    return undefined;
}

quadrotor_play_single_fx_on_tag( effect, tag )
{
    if ( isdefined( self.damage_fx_ent ) )
    {
        if ( self.damage_fx_ent.effect == effect )
            return;

        self.damage_fx_ent delete();
    }

    ent = spawn( "script_model", ( 0, 0, 0 ) );
    ent setmodel( "tag_origin" );
    ent.origin = self gettagorigin( tag );
    ent.angles = self gettagangles( tag );
    ent notsolid();
    ent hide();
    ent linkto( self, tag );
    ent.effect = effect;
    playfxontag( effect, ent, "tag_origin" );
    ent playsound( "veh_qrdrone_sparks" );
    self.damage_fx_ent = ent;
}

quadrotor_update_damage_fx()
{
    max_health = self.healthdefault;

    if ( isdefined( self.health_max ) )
        max_health = self.health_max;

    effect = quadrotor_get_damage_effect( self.health / max_health );

    if ( isdefined( effect ) )
        quadrotor_play_single_fx_on_tag( effect, "tag_origin" );
    else if ( isdefined( self.damage_fx_ent ) )
        self.damage_fx_ent delete();
}

quadrotor_damage()
{
    self endon( "crash_done" );

    while ( isdefined( self ) )
    {
        self waittill( "damage", damage, undefined, dir, point, type );

        if ( self.health > 0 && damage > 1 )
            quadrotor_update_damage_fx();

        if ( isdefined( self.off ) )
            continue;

        if ( type == "MOD_EXPLOSIVE" || type == "MOD_GRENADE_SPLASH" || type == "MOD_PROJECTILE_SPLASH" )
        {
            self setvehvelocity( self.velocity + vectornormalize( dir ) * 300 );
            ang_vel = self getangularvelocity();
            ang_vel = ang_vel + ( randomfloatrange( -300, 300 ), randomfloatrange( -300, 300 ), randomfloatrange( -300, 300 ) );
            self setangularvelocity( ang_vel );
        }
        else
        {
            ang_vel = self getangularvelocity();
            yaw_vel = randomfloatrange( -320, 320 );

            if ( yaw_vel < 0 )
                yaw_vel = yaw_vel - 150;
            else
                yaw_vel = yaw_vel + 150;

            ang_vel = ang_vel + ( randomfloatrange( -150, 150 ), yaw_vel, randomfloatrange( -150, 150 ) );
            self setangularvelocity( ang_vel );
        }

        wait 0.3;
    }
}

quadrotor_cleanup_fx()
{
    if ( isdefined( self.damage_fx_ent ) )
        self.damage_fx_ent delete();

    if ( isdefined( self.stun_fx ) )
        self.stun_fx delete();
}

quadrotor_death()
{
    wait 0.1;
    self notify( "nodeath_thread" );
    self waittill( "death", attacker, damagefromunderneath, weaponname, point, dir );
    self notify( "nodeath_thread" );

    if ( isdefined( self.goal_node ) && isdefined( self.goal_node.quadrotor_claimed ) )
        self.goal_node.quadrotor_claimed = undefined;

    if ( isdefined( self.delete_on_death ) )
    {
        if ( isdefined( self ) )
        {
            self quadrotor_cleanup_fx();
            self delete();
        }

        return;
    }

    if ( !isdefined( self ) )
        return;

    self endon( "death" );
    self disableaimassist();
    self death_fx();
    self thread death_radius_damage();
    self thread set_death_model( self.deathmodel, self.modelswapdelay );
    self thread quadrotor_crash_movement( attacker, dir );
    self quadrotor_cleanup_fx();
    self waittill( "crash_done" );
    self delete();
}

death_fx()
{
    if ( isdefined( self.deathfx ) )
        playfxontag( self.deathfx, self, self.deathfxtag );

    self playsound( "veh_qrdrone_sparks" );
}

quadrotor_crash_movement( attacker, hitdir )
{
    self endon( "crash_done" );
    self endon( "death" );
    self cancelaimove();
    self clearvehgoalpos();
    self clearlookatent();
    self setphysacceleration( vectorscale( ( 0, 0, -1 ), 800.0 ) );
    self.vehcheckforpredictedcrash = 1;

    if ( !isdefined( hitdir ) )
        hitdir = ( 1, 0, 0 );

    side_dir = vectorcross( hitdir, ( 0, 0, 1 ) );
    side_dir_mag = randomfloatrange( -100, 100 );
    side_dir_mag = side_dir_mag + sign( side_dir_mag ) * 80;
    side_dir = side_dir * side_dir_mag;
    self setvehvelocity( self.velocity + vectorscale( ( 0, 0, 1 ), 100.0 ) + vectornormalize( side_dir ) );
    ang_vel = self getangularvelocity();
    ang_vel = ( ang_vel[0] * 0.3, ang_vel[1], ang_vel[2] * 0.3 );
    yaw_vel = randomfloatrange( 0, 210 ) * sign( ang_vel[1] );
    yaw_vel = yaw_vel + sign( yaw_vel ) * 180;
    ang_vel = ang_vel + ( randomfloatrange( -1, 1 ), yaw_vel, randomfloatrange( -1, 1 ) );
    self setangularvelocity( ang_vel );
    self.crash_accel = randomfloatrange( 75, 110 );

    if ( !isdefined( self.off ) )
        self thread quadrotor_crash_accel();

    self thread quadrotor_collision();
    self playsound( "veh_qrdrone_dmg_hit" );

    if ( !isdefined( self.off ) )
        self thread qrotor_dmg_snd();

    wait 0.1;

    if ( randomint( 100 ) < 40 && !isdefined( self.off ) )
        self thread quadrotor_fire_for_time( randomfloatrange( 0.7, 2.0 ) );

    wait 15;
    self notify( "crash_done" );
}

qrotor_dmg_snd()
{
    dmg_ent = spawn( "script_origin", self.origin );
    dmg_ent linkto( self );
    dmg_ent playloopsound( "veh_qrdrone_dmg_loop" );
    self waittill_any( "crash_done", "death" );
    dmg_ent stoploopsound( 1 );
    wait 2;
    dmg_ent delete();
}

quadrotor_fire_for_time( totalfiretime )
{
    self endon( "crash_done" );
    self endon( "change_state" );
    self endon( "death" );

    if ( isdefined( self.emped ) )
        return;

    weaponname = self seatgetweapon( 0 );
    firetime = weaponfiretime( weaponname );
    time = 0;
    firecount = 1;

    while ( time < totalfiretime && !isdefined( self.emped ) )
    {
        if ( isdefined( self.enemy ) && isdefined( self.enemy.attackeraccuracy ) && self.enemy.attackeraccuracy == 0 )
            self fireweapon( undefined, undefined, 1 );
        else
            self fireweapon();

        firecount++;
        wait( firetime );
        time = time + firetime;
    }
}

quadrotor_crash_accel()
{
    self endon( "crash_done" );
    self endon( "death" );
    count = 0;

    while ( true )
    {
        self setvehvelocity( self.velocity + anglestoup( self.angles ) * self.crash_accel );
        self.crash_accel = self.crash_accel * 0.98;
        wait 0.1;
        count++;

        if ( count % 8 == 0 )
        {
            if ( randomint( 100 ) > 40 )
            {
                if ( self.velocity[2] > 150.0 )
                    self.crash_accel = self.crash_accel * 0.75;
                else if ( self.velocity[2] < 40.0 && count < 60 )
                {
                    if ( abs( self.angles[0] ) > 30 || abs( self.angles[2] ) > 30 )
                        self.crash_accel = randomfloatrange( 160, 200 );
                    else
                        self.crash_accel = randomfloatrange( 85, 120 );
                }
            }
        }
    }
}

quadrotor_predicted_collision()
{
    self endon( "crash_done" );
    self endon( "death" );

    while ( true )
    {
        self waittill( "veh_predictedcollision", velocity, normal );

        if ( normal[2] >= 0.6 )
            self notify( "veh_collision", velocity, normal );
    }
}

quadrotor_collision_player()
{
    self endon( "change_state" );
    self endon( "crash_done" );
    self endon( "death" );

    while ( true )
    {
        self waittill( "veh_collision", velocity, normal );
        driver = self getseatoccupant( 0 );

        if ( isdefined( driver ) && lengthsquared( velocity ) > 4900 )
        {
            earthquake( 0.25, 0.25, driver.origin, 50 );
            driver playrumbleonentity( "damage_heavy" );
        }
    }
}

quadrotor_collision()
{
    self endon( "change_state" );
    self endon( "crash_done" );
    self endon( "death" );

    if ( !isalive( self ) )
        self thread quadrotor_predicted_collision();

    while ( true )
    {
        self waittill( "veh_collision", velocity, normal );
        ang_vel = self getangularvelocity() * 0.5;
        self setangularvelocity( ang_vel );

        if ( normal[2] < 0.6 || isalive( self ) && !isdefined( self.emped ) )
        {
            self setvehvelocity( self.velocity + normal * 90 );
            self playsound( "veh_qrdrone_wall" );

            if ( normal[2] < 0.6 )
                fx_origin = self.origin - normal * 28;
            else
                fx_origin = self.origin - normal * 10;

            playfx( level._effect["quadrotor_nudge"], fx_origin, normal );
        }
        else if ( isdefined( self.emped ) )
        {
            if ( isdefined( self.bounced ) )
            {
                self playsound( "veh_qrdrone_wall" );
                self setvehvelocity( ( 0, 0, 0 ) );
                self setangularvelocity( ( 0, 0, 0 ) );

                if ( self.angles[0] < 0 )
                {
                    if ( self.angles[0] < -15 )
                        self.angles = ( -15, self.angles[1], self.angles[2] );
                    else if ( self.angles[0] > -10 )
                        self.angles = ( -10, self.angles[1], self.angles[2] );
                }
                else if ( self.angles[0] > 15 )
                    self.angles = ( 15, self.angles[1], self.angles[2] );
                else if ( self.angles[0] < 10 )
                    self.angles = ( 10, self.angles[1], self.angles[2] );

                self.bounced = undefined;
                self notify( "landed" );
                return;
            }
            else
            {
                self.bounced = 1;
                self setvehvelocity( self.velocity + normal * 120 );
                self playsound( "veh_qrdrone_wall" );

                if ( normal[2] < 0.6 )
                    fx_origin = self.origin - normal * 28;
                else
                    fx_origin = self.origin - normal * 10;

                playfx( level._effect["quadrotor_nudge"], fx_origin, normal );
            }
        }
        else
        {
            createdynentandlaunch( self.deathmodel, self.origin, self.angles, self.origin, self.velocity * 0.01 );
            self playsound( "veh_qrdrone_explo" );
            self thread death_fire_loop_audio();
            self notify( "crash_done" );
        }
    }
}

death_fire_loop_audio()
{
    sound_ent = spawn( "script_origin", self.origin );
    sound_ent playloopsound( "veh_qrdrone_death_fire_loop", 0.1 );
    wait 11;
    sound_ent stoploopsound( 1 );
    sound_ent delete();
}

quadrotor_set_team( team )
{
    self.team = team;
    self.vteam = team;
    self setteam( team );

    if ( !isdefined( self.off ) )
        quadrotor_blink_lights();
}

quadrotor_blink_lights()
{
    self endon( "death" );
    self lights_off();
    wait 0.1;
    self lights_on();
}

quadrotor_self_destruct()
{
    self endon( "death" );
    self endon( "exit_vehicle" );
    self_destruct = 0;
    self_destruct_time = 0;

    while ( true )
    {
        if ( !self_destruct )
        {
            if ( level.player meleebuttonpressed() )
            {
                self_destruct = 1;
                self_destruct_time = 5;
            }

            wait 0.05;
            continue;
        }
        else
        {
            iprintlnbold( self_destruct_time );
            wait 1;
            self_destruct_time = self_destruct_time - 1;

            if ( self_destruct_time == 0 )
            {
                driver = self getseatoccupant( 0 );

                if ( isdefined( driver ) )
                    driver disableinvulnerability();

                earthquake( 3, 1, self.origin, 256 );
                radiusdamage( self.origin, 1000, 15000, 15000, level.player, "MOD_EXPLOSIVE" );
                self dodamage( self.health + 1000, self.origin );
            }

            continue;
        }
    }
}

quadrotor_level_out_for_landing()
{
    self endon( "death" );
    self endon( "emped" );
    self endon( "landed" );

    while ( isdefined( self.emped ) )
    {
        velocity = self.velocity;
        self.angles = ( self.angles[0] * 0.85, self.angles[1], self.angles[2] * 0.85 );
        ang_vel = self getangularvelocity() * 0.85;
        self setangularvelocity( ang_vel );
        self setvehvelocity( velocity );
        wait 0.05;
    }
}

quadrotor_temp_bullet_shield( invulnerable_time )
{
    self notify( "bullet_shield" );
    self endon( "bullet_shield" );
    self.bullet_shield = 1;
    wait( invulnerable_time );

    if ( isdefined( self ) )
    {
        self.bullet_shield = undefined;
        wait 3;

        if ( isdefined( self ) && self.health < 40 )
            self.health = 40;
    }
}

lights_on()
{
    self clearclientflag( 10 );
}

lights_off()
{
    self setclientflag( 10 );
}

death_radius_damage()
{
    if ( !isdefined( self ) || self.radiusdamageradius <= 0 )
        return;

    wait 0.05;

    if ( isdefined( self ) )
        self radiusdamage( self.origin + vectorscale( ( 0, 0, 1 ), 15.0 ), self.radiusdamageradius, self.radiusdamagemax, self.radiusdamagemin, self, "MOD_EXPLOSIVE" );
}

set_death_model( smodel, fdelay )
{
    assert( isdefined( smodel ) );

    if ( isdefined( fdelay ) && fdelay > 0 )
        wait( fdelay );

    if ( !isdefined( self ) )
        return;

    if ( isdefined( self.deathmodel_attached ) )
        return;

    self setmodel( smodel );
}

player_in_last_stand_within_range( range )
{
    players = getplayers();

    if ( players.size == 1 )
        return;

    foreach ( player in players )
    {
        if ( player maps\mp\zombies\_zm_laststand::player_is_in_laststand() && distancesquared( self.origin, player.origin ) < range * range && !isdefined( player.quadrotor_revive ) )
            return player;
    }
}

qdrotor_update_revive_location()
{
    self endon( "death" );
}

watch_for_fail_revive( quad_rotor )
{
    quadrotor = quad_rotor;
    owner = quad_rotor.player_owner;
    revive_target = quad_rotor.revive_target;
    revive_target endon( "bled_out" );
    revive_target endon( "disconnect" );
    level thread kill_fx_if_target_revive( quadrotor, revive_target );
    revive_target.revive_hud settext( &"GAME_PLAYER_IS_REVIVING_YOU", owner );
    revive_target revive_hud_show_n_fade( 1.0 );
    wait 1;

    if ( isdefined( revive_target ) )
        revive_target.quadrotor_revive = undefined;
}

kill_fx_if_target_revive( quadrotor, revive_target )
{
    e_fx = spawn( "script_model", quadrotor gettagorigin( "tag_origin" ) );
    e_fx setmodel( "tag_origin" );
    playfxontag( level._effect["qd_revive"], e_fx, "tag_origin" );
    e_fx moveto( revive_target.origin, 1 );
    timer = 0;

    while ( true )
    {
        if ( isdefined( revive_target ) && revive_target maps\mp\zombies\_zm_laststand::player_is_in_laststand() && isdefined( quadrotor ) )
        {
            wait 0.1;
            timer = timer + 0.1;

            if ( timer >= 1 )
            {
                playfxontag( level._effect["staff_soul"], e_fx, "tag_origin" );
                break;
            }
        }
        else
            break;
    }

    e_fx delete();
}
