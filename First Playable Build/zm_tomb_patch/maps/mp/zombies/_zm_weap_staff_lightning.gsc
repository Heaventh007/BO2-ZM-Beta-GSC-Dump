// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\animscripts\shared;

init()
{
    level._effect["lightning_hit"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_elec_ug_impact_hit" );
    level._effect["lightning_hit_end"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_elec_ug_impact_hit_end" );
    level._effect["lightning_miss"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_elec_ug_impact_miss" );
    level._effect["lightning_arc"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_elec_trail_bolt_cheap" );
    level._effect["lightning_impact"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_elec_ug_impact_hit_torso" );
    level._effect["tesla_shock_eyes"] = loadfx( "maps/zombie/fx_zombie_tesla_shock_eyes" );
    registerclientfield( "actor", "lightning_hit_fx", 14000, 1, "int" );
    registerclientfield( "actor", "lightning_impact_fx", 14000, 1, "int" );
    registerclientfield( "scriptmover", "lightning_miss_fx", 14000, 1, "int" );
    registerclientfield( "scriptmover", "lightning_arc_fx", 14000, 1, "int" );
    set_zombie_var( "tesla_head_gib_chance", 50 );
    onplayerconnect_callback( ::onplayerconnect );
    maps\mp\zombies\_zm_spawner::register_zombie_damage_callback( ::staff_lightning_zombie_damage_response );
    maps\mp\zombies\_zm_spawner::register_zombie_death_event_callback( ::staff_lightning_death_event );
}

onplayerconnect()
{
    self thread onplayerspawned();
}

onplayerspawned()
{
    self endon( "disconnect" );
    self thread watch_staff_lightning_fired();
    self thread watch_staff_usage();
}

watch_staff_lightning_fired()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "missile_fire", e_projectile, str_weapon );

        if ( str_weapon == "staff_lightning_upgraded2_zm" || str_weapon == "staff_lightning_upgraded3_zm" )
            self thread lightning_locate_target();
    }
}

staff_lightning_find_source( v_detonate )
{
    self endon( "disconnect" );

    if ( !isdefined( v_detonate ) )
        return;

    a_zombies = get_round_enemy_array();
    a_zombies = get_array_of_closest( v_detonate, a_zombies );

    if ( a_zombies.size )
    {
        for ( i = 0; i < a_zombies.size; i++ )
        {
            if ( isalive( a_zombies[i] ) )
            {
                if ( is_true( a_zombies[i].staff_hit ) )
                    continue;

                if ( distance2dsquared( v_detonate, a_zombies[i].origin ) <= 10000 )
                    self thread staff_lightning_zombie_source( a_zombies[0] );
                else
                    self thread staff_lightning_position_source( v_detonate );

                return;
            }
        }
    }
    else
        self thread staff_lightning_position_source( v_detonate );
}

staff_lightning_zombie_source( ai_zombie )
{
    self endon( "disconnect" );
    ai_zombie endon( "death" );
    ai_zombie.staff_hit = 1;
    ai_zombie.is_source = 1;

    if ( !isdefined( ai_zombie.is_mechz ) )
        ai_zombie thread handle_lightning_source_zombie( self );
}

staff_lightning_position_source( v_detonate )
{
    self endon( "disconnect" );

    if ( isdefined( v_detonate ) )
    {
        e_fx = spawn( "script_model", v_detonate );
        e_fx setmodel( "tag_origin" );
        e_fx setclientfield( "lightning_miss_fx", 1 );
        a_zombies = staff_lightning_zombie_range( self, e_fx );
    }

    if ( !isdefined( a_zombies ) )
        return;

    wait 1;
    self staff_lightning_select_zombies( a_zombies, v_detonate );
    wait 0.5;

    if ( isdefined( e_fx ) )
        e_fx delete();
}

staff_lightning_zombie_range( player, e_source )
{
    player endon( "disconnect" );
    v_source = e_source.origin;
    n_range = get_lightning_blast_range( player.chargeshotlevel );
    a_enemies = [];
    a_zombies = get_round_enemy_array();
    a_zombies = get_array_of_closest( v_source, a_zombies );

    if ( isdefined( a_zombies ) )
    {
        for ( i = 0; i < a_zombies.size; i++ )
        {
            if ( !isdefined( a_zombies[i] ) )
                continue;

            v_zombie_pos = a_zombies[i] gettagorigin( "j_head" );

            if ( isdefined( a_zombies[i].staff_hit ) && a_zombies[i].staff_hit == 1 )
                continue;

            if ( distancesquared( v_source, v_zombie_pos ) > n_range )
                continue;

            a_enemies[a_enemies.size] = a_zombies[i];
        }
    }

    return a_enemies;
}

handle_lightning_source_zombie( player )
{
    player endon( "disconnect" );
    self setclientfield( "lightning_hit_fx", 1 );
    self thread zombie_shock_eyes();
    self thread staff_lightning_kill_zombie( player );

    if ( isdefined( self ) )
        a_zombies = staff_lightning_zombie_range( player, self );

    if ( a_zombies.size )
        player staff_lightning_select_zombies( a_zombies, self getcentroid() );
}

staff_lightning_select_zombies( a_zombies, v_source )
{
    self endon( "disconnect" );

    if ( !isdefined( a_zombies ) )
        return;

    n_limit = self.chargeshotlevel * 3;

    if ( a_zombies.size < self.chargeshotlevel * 2 )
        n_limit = a_zombies.size;

    wait 0.5;

    for ( i = 0; i < n_limit; i++ )
    {
        if ( isalive( a_zombies[i] ) )
        {
            self thread staff_lightning_arc_fx( v_source, a_zombies[i] );
            wait 0.1;
        }
    }
}

get_lightning_blast_range( n_charge )
{
    switch ( n_charge )
    {
        case 1:
            n_range = 40000;
            break;
        case 2:
            n_range = 90000;
            break;
        case 3:
            n_range = 250000;
            break;
    }

    return n_range;
}

staff_lightning_arc_fx( v_source, ai_zombie )
{
    self endon( "disconnect" );

    if ( is_true( ai_zombie.is_mechz ) )
        return;

    if ( !isdefined( ai_zombie ) )
        return;

    target_tag = "J_SpineUpper";

    if ( ai_zombie.isdog )
        target_tag = "J_Spine1";

    target_origin = ai_zombie gettagorigin( target_tag );
    e_fxorg = spawn( "script_model", v_source );
    e_fxorg setmodel( "tag_origin" );
    e_fxorg setclientfield( "lightning_arc_fx", 1 );
    e_fxorg moveto( target_origin, 0.1 );
    e_fxorg waittill( "movedone" );

    if ( isalive( ai_zombie ) )
    {
        ai_zombie thread staff_lightning_death_fx();
        ai_zombie thread staff_lightning_kill_zombie( self );
    }

    e_fxorg delete();
}

staff_lightning_kill_zombie( player )
{
    player endon( "disconnect" );

    if ( !isalive( self ) )
        return;

    if ( !self.isdog )
    {
        if ( self.has_legs )
        {
            if ( !self hasanimstatefromasd( "zm_death_tesla" ) )
                return;

            self.deathanim = "zm_death_tesla";
        }
        else
        {
            if ( !self hasanimstatefromasd( "zm_death_tesla_crawl" ) )
                return;

            self.deathanim = "zm_death_tesla_crawl";
        }
    }
    else
        self.a.nodeath = undefined;

    if ( is_true( self.is_traversing ) )
        self.deathanim = undefined;

    self dodamage( self.health, player.origin, player );
    player maps\mp\zombies\_zm_score::player_add_points( "death", "", "" );
}

staff_lightning_death_fx()
{
    if ( isdefined( self ) )
    {
        self setclientfield( "lightning_impact_fx", 1 );

        if ( cointoss() )
            self thread zombie_shock_eyes();
        else if ( isdefined( self.tesla_head_gib_func ) && !self.head_gibbed )
            [[ self.tesla_head_gib_func ]]();
    }
}

zombie_shock_eyes()
{
    if ( isdefined( self.head_gibbed ) && self.head_gibbed )
        return;

    if ( isdefined( self gettagorigin( "J_Eyeball_LE" ) ) )
        network_safe_play_fx_on_tag( "shock_eyes", 2, level._effect["tesla_shock_eyes"], self, "J_Eyeball_LE" );
}

zombie_gib_all()
{
    a_gib_ref = [];
    a_gib_ref[0] = level._zombie_gib_piece_index_all;
    self gib( "normal", a_gib_ref );
}

staff_lightning_zombie_damage_response( mod, hit_location, hit_origin, player, amount )
{
    if ( self is_staff_lightning_damage() )
    {
        self thread stun_zombie();
        self thread staff_lightning_zombie_hit_response_internal( mod, self.damageweapon, player );
        return true;
    }

    return false;
}

is_staff_lightning_damage()
{
    return isdefined( self.damageweapon ) && ( self.damageweapon == "staff_lightning_zm" || self.damageweapon == "staff_lightning_upgraded_zm" );
}

staff_lightning_zombie_hit_response_internal( mod, damageweapon, player )
{
    player endon( "disconnect" );

    if ( !isalive( self ) )
        return;
}

staff_lightning_death_event()
{
    if ( is_staff_lightning_damage() )
    {
        if ( is_true( self.is_mechz ) )
            return;

        self thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( "death", self.animname );
        self thread zombie_eye_glow_stop();

        if ( !self.isdog )
        {
            if ( self.has_legs )
            {
                if ( !self hasanimstatefromasd( "zm_death_tesla" ) )
                    return;

                self.deathanim = "zm_death_tesla";
            }
            else
            {
                if ( !self hasanimstatefromasd( "zm_death_tesla_crawl" ) )
                    return;

                self.deathanim = "zm_death_tesla_crawl";
            }
        }
        else
            self.a.nodeath = undefined;

        if ( is_true( self.is_traversing ) )
            self.deathanim = undefined;

        tag = "J_SpineUpper";

        if ( self.isdog )
            tag = "J_Spine1";

        self setclientfield( "lightning_impact_fx", 1 );
        self thread zombie_shock_eyes();

        if ( isdefined( self.deathanim ) )
            self waittillmatch( "death_anim", "die" );

        self dodamage( self.health, self.attacker.origin, self.attacker );
    }
}

stun_zombie()
{
    self endon( "death" );

    if ( is_true( self.is_mechz ) )
        return;

    if ( is_true( self.is_electrocuted ) )
        return;

    self.forcemovementscriptstate = 1;
    self.ignoreall = 1;
    self.is_electrocuted = 1;
    tag = "J_SpineUpper";

    if ( self.isdog )
        tag = "J_Spine1";

    network_safe_play_fx_on_tag( "lightning_impact", 2, level._effect["lightning_impact"], self, tag );
    self animscripted( self.origin, self.angles, "zm_electric_stun" );
    self maps\mp\animscripts\shared::donotetracks( "stunned" );

    if ( self.damageweapon == "staff_lightning_upgraded_zm" || self.damageweapon == "staff_lightning_upgraded2_zm" || self.damageweapon == "staff_lightning_upgraded3_zm" )
    {
        self animscripted( self.origin, self.angles, "zm_electric_stun" );
        self maps\mp\animscripts\shared::donotetracks( "stunned" );
    }

    self.forcemovementscriptstate = 0;
    self.ignoreall = 0;
    self.is_electrocuted = 0;
}

lightning_locate_target( is_not_upgraded )
{
    if ( !isdefined( is_not_upgraded ) )
        is_not_upgraded = 1;

    fire_angles = self getplayerangles();
    fire_origin = self getplayercamerapos();
    a_targets = getaiarray( "axis" );
    a_targets = get_array_of_closest( self.origin, a_targets, undefined, undefined, 500 );

    foreach ( target in a_targets )
    {
        if ( within_fov( fire_origin, fire_angles, target gettagorigin( "j_spine4" ), cos( 45 ) ) )
        {
            if ( isai( target ) )
                target dodamage( 2000, self.origin, self, self, "none", "MOD_EXPLOSIVE", 0, "staff_lightning_zm" );
        }
    }
}
