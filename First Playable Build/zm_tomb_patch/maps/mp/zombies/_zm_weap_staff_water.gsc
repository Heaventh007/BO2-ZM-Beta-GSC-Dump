// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_score;

init()
{
    level._effect["staff_water_damage_torso"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_ice_ug_impact_hit" );
    level._effect["staff_water_ice_shard"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_ice_trail_bolt" );
    registerclientfield( "scriptmover", "staff_water_torso_damage_fx", 14000, 1, "int" );
    registerclientfield( "scriptmover", "ice_sphere_fx", 14000, 1, "int" );
    registerclientfield( "actor", "anim_rate", 14000, 5, "float" );
    registerclientfield( "actor", "attach_bullet_model", 14000, 1, "int" );
    onplayerconnect_callback( ::onplayerconnect );
    precacheitem( "staff_water_fake_dart_zm" );
    precacheitem( "staff_water_dart_zm" );
    init_tag_array();
    level thread water_dart_cleanup();
    maps\mp\zombies\_zm_spawner::register_zombie_damage_callback( ::staff_water_zombie_damage_response );
    maps\mp\zombies\_zm_spawner::register_zombie_death_event_callback( ::staff_water_death_event );
    maps\mp\zombies\_zm_spawner::add_cusom_zombie_spawn_logic( ::staff_water_on_zombie_spawned );
    level.m_sphere = getent( "ice_sphere", "targetname" );
    level.m_sphere ghost();
}

init_tag_array()
{
    level.zombie_water_icicle_tag = [];
    level.zombie_water_icicle_tag[0] = "j_hip_le";
    level.zombie_water_icicle_tag[1] = "j_hip_ri";
    level.zombie_water_icicle_tag[2] = "j_spine4";
    level.zombie_water_icicle_tag[3] = "j_elbow_le";
    level.zombie_water_icicle_tag[4] = "j_elbow_ri";
    level.zombie_water_icicle_tag[5] = "j_clavicle_le";
    level.zombie_water_icicle_tag[6] = "j_clavicle_ri";
}

water_dart_cleanup()
{
    while ( true )
    {
        a_grenades = getentarray( "grenade", "classname" );

        foreach ( e_grenade in a_grenades )
        {
            if ( isdefined( e_grenade.model ) && e_grenade.model == "p6_zm_tm_staff_projectile_ice" )
            {
                time = gettime();

                if ( time - e_grenade.birthtime >= 1000 )
                    e_grenade delete();
            }
        }

        wait 0.1;
    }
}

onplayerconnect()
{
    self thread onplayerspawned();
}

onplayerspawned()
{
    self endon( "disconnect" );
    self thread watch_staff_water_fired();
    self thread watch_staff_water_impact();
    self thread watch_staff_usage();
}

watch_staff_water_fired()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "missile_fire", e_projectile, str_weapon );

        if ( str_weapon == "staff_water_zm" || str_weapon == "staff_water_upgraded_zm" )
        {
            wait_network_frame();
            _icicle_locate_target( 1 );
            wait_network_frame();
            _icicle_locate_target( 1 );
            wait_network_frame();
            _icicle_locate_target( 1 );
        }
    }
}

watch_staff_water_impact()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "projectile_impact", e_ent, v_explode_point, n_radius, str_name, n_impact );

        if ( e_ent == "staff_water_upgraded2_zm" || e_ent == "staff_water_upgraded3_zm" )
        {
            self thread staff_water_find_source( v_explode_point );
            level notify( "ice_shot" );
        }
    }
}

staff_water_find_source( v_detonate )
{
    self endon( "disconnect" );

    if ( !isdefined( v_detonate ) )
        return;

    a_zombies = get_round_enemy_array();
    a_zombies = get_array_of_closest( v_detonate, a_zombies );

    if ( !isdefined( a_zombies ) || !isdefined( v_detonate ) )
        return;

    if ( isalive( a_zombies[0] ) )
    {
        if ( isdefined( a_zombies[0].staff_hit ) && a_zombies[0].staff_hit )
            return;

        if ( distance2dsquared( v_detonate, a_zombies[0].origin ) <= 10000 )
            self thread staff_water_zombie_source( a_zombies[0] );
        else
            self thread staff_water_position_source( v_detonate );
    }
}

staff_water_zombie_source( ai_zombie )
{
    self endon( "disconnect" );
    ai_zombie endon( "death" );
    ai_zombie.staff_hit = 1;
    ai_zombie.is_source = 1;
    self thread source_zombie_death( ai_zombie );
}

staff_water_kill_zombie( player, n_delay )
{
    self endon( "death" );
    wait( n_delay );
    self freeze_zombie();
    self dodamage( self.health, self.origin, player, player, "none", "MOD_RIFLE_BULLET", 0, "staff_water_zm" );

    if ( isdefined( self.deathanim ) )
        self waittillmatch( "death_anim", "shatter" );

    if ( isdefined( self ) )
        self thread frozen_zombie_shatter();

    player maps\mp\zombies\_zm_score::player_add_points( "death", "", "" );
}

freeze_zombie()
{
    if ( is_true( self.is_mechz ) )
        return;

    if ( !self.isdog )
    {
        if ( self.has_legs )
        {
            if ( !self hasanimstatefromasd( "zm_death_freeze" ) )
                return;

            self.deathanim = "zm_death_freeze";
        }
        else
        {
            if ( !self hasanimstatefromasd( "zm_death_freeze_crawl" ) )
                return;

            self.deathanim = "zm_death_freeze_crawl";
        }
    }
    else
        self.a.nodeath = undefined;

    if ( is_true( self.is_traversing ) )
        self.deathanim = undefined;
}

frozen_zombie_shatter()
{
    if ( is_true( self.is_mechz ) )
        return;

    if ( isdefined( self ) )
    {
        if ( is_mature() )
            self thread frozen_zombie_gib( "normal" );
        else
            self startragdoll();
    }
}

frozen_zombie_gib( gib_type )
{
    gibarray = [];
    gibarray[gibarray.size] = level._zombie_gib_piece_index_all;
    self gib( gib_type, gibarray );
    self ghost();
    wait 0.4;

    if ( isdefined( self ) )
        self self_delete();
}

source_zombie_death( ai_zombie )
{
    self endon( "disconnect" );
    tag = "J_SpineUpper";

    if ( ai_zombie.isdog )
        tag = "J_Spine1";

    if ( isalive( ai_zombie ) )
    {
        if ( !isdefined( ai_zombie.is_mechz ) )
            ai_zombie thread staff_water_kill_zombie( self, 0 );

        self thread staff_water_position_source( ai_zombie.origin );
    }
}

staff_water_position_source( v_detonate )
{
    self endon( "disconnect" );

    if ( isdefined( v_detonate ) )
    {
        e_fx = spawn( "script_model", v_detonate + vectorscale( ( 0, 0, 1 ), 33.0 ) );
        e_fx setmodel( "tag_origin" );
        e_fx setclientfield( "staff_water_torso_damage_fx", 1 );
        wait 1;
        e_fx thread ice_sphere_shield( self );
        e_fx thread ice_sphere_timeout( self.chargeshotlevel );
        e_fx thread ice_sphere_off();
    }
}

ice_sphere_shield( player )
{
    player endon( "disconnect" );
    self endon( "ice_off" );

    while ( true )
    {
        a_zombies = get_round_enemy_array();

        foreach ( zombie in a_zombies )
        {
            if ( isalive( zombie ) && !isdefined( zombie.staff_hit ) && !isdefined( zombie.is_mechz ) )
            {
                if ( distancesquared( self.origin, zombie.origin ) <= 30625 )
                {
                    if ( zombie.zombie_move_speed == "walk" )
                        n_delay = randomfloatrange( 1.0, 1.5 );
                    else if ( zombie.zombie_move_speed == "run" )
                        n_delay = randomfloatrange( 0.5, 1.0 );
                    else if ( zombie.zombie_move_speed == "sprint" )
                        n_delay = randomfloatrange( 0.1, 0.5 );

                    zombie.staff_hit = 1;
                    zombie thread staff_water_kill_zombie( player, n_delay );
                }
            }
        }

        wait 0.1;
    }
}

ice_sphere_timeout( n_time )
{
    self endon( "death" );
    wait 5;
    self notify( "ice_off" );
    self setclientfield( "staff_water_torso_damage_fx", 0 );
    wait 0.1;
    self delete();
}

ice_sphere_off()
{
    self endon( "death" );
    level waittill( "ice_shot" );
    self notify( "ice_off" );
    self setclientfield( "staff_water_torso_damage_fx", 0 );
    wait 0.1;
    self delete();
}

ice_turret_seek_zombies( e_fx )
{
    self endon( "disconnect" );
    a_zombies = staff_water_zombie_range( e_fx.origin, get_ice_blast_range( self.chargeshotlevel ) );
    a_zombies = array_randomize( a_zombies );

    if ( !isdefined( a_zombies ) )
        return;

    n_limit = self.chargeshotlevel * 2;

    if ( a_zombies.size < self.chargeshotlevel * 2 )
        n_limit = a_zombies.size;

    for ( i = 0; i < n_limit; i++ )
    {
        if ( isalive( a_zombies[i] ) )
            self thread ice_turret_fireat_zombies( e_fx.origin, a_zombies[i] );

        wait( randomfloatrange( 0.1, 0.3 ) );
    }

    e_fx delete();
}

get_ice_blast_range( n_charge )
{
    switch ( n_charge )
    {
        case 0:
        case 1:
            n_range = 250000;
            break;
        case 2:
            n_range = 640000;
            break;
        case 3:
            n_range = 1000000;
            break;
    }

    return n_range;
}

ice_turret_fireat_zombies( v_source, ai_zombie )
{
    self endon( "disconnect" );
    ai_zombie endon( "death" );

    if ( !isdefined( ai_zombie ) )
        return;

    target_tag = "J_SpineUpper";

    if ( ai_zombie.isdog )
        target_tag = "J_Spine1";

    magicbullet( "staff_water_zm_cheap", v_source, ai_zombie gettagorigin( target_tag ), self );

    if ( isalive( ai_zombie ) )
        ai_zombie thread staff_water_kill_zombie( self, 0 );
}

staff_water_proximity_kill( a_zombies )
{
    self endon( "disconnect" );

    if ( !isdefined( a_zombies ) )
        return;

    foreach ( ai_zombie in a_zombies )
        ai_zombie thread staff_water_kill_zombie( self, 0 );
}

staff_water_zombie_range( v_source, n_range )
{
    a_enemies = [];
    a_zombies = get_round_enemy_array();
    a_zombies = get_array_of_closest( v_source, a_zombies );

    if ( isdefined( a_zombies ) )
    {
        for ( i = 0; i < a_zombies.size; i++ )
        {
            if ( !isdefined( a_zombies[i] ) )
                continue;

            v_zombie_pos = a_zombies[i] gettagorigin( "j_head" );

            if ( isdefined( a_zombies[i].staff_hit ) && a_zombies[i].staff_hit == 1 )
                continue;

            if ( distancesquared( v_source, v_zombie_pos ) > n_range )
                continue;

            if ( !bullettracepassed( v_source, v_zombie_pos, 0, undefined ) )
                continue;

            a_enemies[a_enemies.size] = a_zombies[i];
        }
    }

    return a_enemies;
}

staff_water_damage_handler( player )
{
    e_fx = spawn( "script_model", self.origin + vectorscale( ( 0, 0, 1 ), 32.0 ) );
    e_fx setmodel( "tag_origin" );
    e_fx setclientfield( "staff_water_torso_damage_fx", 1 );
    wait 0.38;
    level.m_sphere moveto( e_fx.origin + ( 0, 0, 0 ), 0.05 );
    level.m_sphere waittill( "movedone" );
    level.m_sphere show();
    level.m_sphere setclientfield( "ice_sphere_fx", 1 );
    wait 6;
    level.m_sphere ghost();
    level.m_sphere setclientfield( "ice_sphere_fx", 0 );
    wait 5;
    e_fx setclientfield( "staff_water_torso_damage_fx", 0 );

    if ( isdefined( player ) )
    {
        a_zombies = staff_water_zombie_range( e_fx.origin, get_ice_blast_range( player.chargeshotlevel ) );

        if ( a_zombies.size )
            player thread staff_water_proximity_kill( a_zombies );
    }

    e_fx delete();
}

staff_water_zombie_damage_response( mod, hit_location, hit_origin, player, amount )
{
    if ( self is_staff_water_damage() )
        self thread staff_water_zombie_hit_response_internal( mod, self.damageweapon, player );

    return false;
}

is_staff_water_damage()
{
    return isdefined( self.damageweapon ) && ( self.damageweapon == "staff_water_zm" || self.damageweapon == "staff_water_upgraded_zm" || self.damageweapon == "staff_water_fake_dart_zm" );
}

staff_water_zombie_hit_response_internal( mod, damageweapon, player )
{
    player endon( "disconnect" );

    if ( !isdefined( self ) || !isalive( self ) )
        return;

    if ( is_true( self.is_mechz ) )
        return;

    self thread iced_fx();
    self thread slow_zombie( 0.3 );
}

iced_fx()
{
    self endon( "death" );

    if ( isdefined( self.is_on_ice ) && self.is_on_ice )
        return;

    self.is_on_ice = 1;
}

slow_zombie( n_time )
{
    self endon( "death" );

    if ( is_true( self.is_slowing ) )
        return;

    self.is_slowing = 1;
    n_speed = 0.3;
    self set_anim_rate( 0.3 );
    wait 2;

    while ( n_speed < 1 )
    {
        n_speed = n_speed + 0.1;
        self set_anim_rate( n_speed );
        wait 0.05;
    }

    self set_anim_rate( 1 );
    self setclientfield( "attach_bullet_model", 0 );
    self.is_slowing = 0;
}

set_anim_rate( n_speed )
{
    self setclientfield( "anim_rate", n_speed );
    n_rate = self getclientfield( "anim_rate" );
    self setentityanimrate( n_rate );
}

staff_water_on_zombie_spawned()
{
    self setclientfield( "anim_rate", 1 );
    n_rate = self getclientfield( "anim_rate" );
    self setentityanimrate( n_rate );
}

staff_water_death_event()
{
    self.no_gib = 1;
    self.nodeathragdoll = 1;

    if ( is_staff_water_damage() )
    {
        self freeze_zombie();

        if ( isdefined( self.deathanim ) )
            self waittillmatch( "death_anim", "shatter" );

        self thread frozen_zombie_shatter();
    }
}

_icicle_locate_target( is_not_upgraded )
{
    if ( !isdefined( is_not_upgraded ) )
        is_not_upgraded = 1;

    fire_angles = self getplayerangles();
    fire_origin = self getplayercamerapos();
    a_targets = getaiarray( "axis" );
    a_targets = get_array_of_closest( self.origin, a_targets, undefined, undefined, 1500 );

    foreach ( target in a_targets )
    {
        if ( within_fov( fire_origin, fire_angles, target gettagorigin( "j_spine4" ), cos( 25 ) ) )
        {
            if ( isai( target ) )
            {
                a_tags = [];
                a_tags[0] = "j_hip_le";
                a_tags[1] = "j_hip_ri";
                a_tags[2] = "j_spine4";
                a_tags[3] = "j_elbow_le";
                a_tags[4] = "j_elbow_ri";
                a_tags[5] = "j_clavicle_le";
                a_tags[6] = "j_clavicle_ri";
                str_tag = a_tags[randomint( a_tags.size )];
                b_trace_pass = bullettracepassed( fire_origin, target gettagorigin( str_tag ), 1, self, target );

                if ( b_trace_pass )
                {
                    e_dart = magicbullet( "staff_water_fake_dart_zm", fire_origin, target gettagorigin( str_tag ), self );
                    target setclientfield( "attach_bullet_model", 1 );
                    return;
                }
            }
        }
    }

    vec = anglestoforward( fire_angles );
    trace_end = fire_origin + vec * 20000;
    trace = bullettrace( fire_origin, trace_end, 1, self );
    offsetpos = trace["position"] + _icicle_get_spread( 10 );
    e_dart = magicbullet( "staff_water_fake_dart_zm", fire_origin, offsetpos, self );
}

_icicle_get_spread( n_spread )
{
    n_x = randomintrange( n_spread * -1, n_spread );
    n_y = randomintrange( n_spread * -1, n_spread );
    n_z = randomintrange( n_spread * -1, n_spread );
    return ( n_x, n_y, n_z );
}
