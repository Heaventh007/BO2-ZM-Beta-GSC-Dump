// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\mp\zombies\_zm_zonemgr;
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\zm_tomb_tank;
#include maps\mp\zombies\_zm_ai_mechz_dev;
#include maps\mp\zombies\_zm_ai_mechz_claw;
#include maps\mp\zombies\_zm_ai_mechz_ft;
#include maps\mp\zombies\_zm_ai_mechz_booster;
#include maps\mp\zombies\_zm_ai_mechz;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\animscripts\zm_shared;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\zombies\_zm_ai_basic;

precache()
{
    precacheshellshock( "mp_radiation_high" );
    precacheshellshock( "mp_radiation_med" );
    precacheshellshock( "mp_radiation_low" );
    level thread mechz_setup_armor_pieces();
    precachemodel( "c_zom_mech_claw" );
    precachemodel( "c_zom_mech_faceplate" );
    precachemodel( "c_zom_mech_powersupply_cap" );
    level._effect["mech_dmg_sparks"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_dmg_sparks" );
    level._effect["mech_dmg_steam"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_dmg_steam" );
    level._effect["mech_booster"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_jump_booster" );
    level._effect["mech_wpn_source"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_wpn_source" );
    level._effect["mech_wpn_flamethrower"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_wpn_flamethrower" );
    level._effect["mech_booster_landing"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_jump_landing" );
    level._effect["mech_faceplate_dmg"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_dmg_armor_face" );
    level._effect["mech_armor_dmg"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_dmg_armor" );
    level._effect["mech_exhaust"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_exhaust_smoke" );
    level._effect["mech_booster_feet"] = loadfx( "maps/zombie_tomb/fx_tomb_mech_jump_booster_sm" );
    setdvar( "zombie_double_wide_checks", 1 );
    precacherumble( "mechz_footsteps" );
}

#using_animtree("mechz_claw");

init()
{
    level.mechz_spawners = getentarray( "mechz_spawner", "script_noteworthy" );

    if ( level.mechz_spawners.size == 0 )
        return;

    for ( i = 0; i < level.mechz_spawners.size; i++ )
    {
        level.mechz_spawners[i].is_enabled = 1;
        level.mechz_spawners[i].script_forcespawn = 1;
    }

    level.mechz_base_health = 800;
    level.mechz_health = level.mechz_base_health;
    level.mechz_health_increase = 300;
    level.mechz_damage_percent = 0.1;
    level.mechz_min_round_fq = 3;
    level.mechz_max_round_fq = 5;
    level.mechz_reset_dist_sq = 262144;
    level.mechz_aggro_dist_sq = 16384;
    level.mechz_zombie_per_round = 1;
    level.mechz_left_to_spawn = 0;
    level.mechz_players_in_zone_spawn_point_cap = 120;
    level.mechz_shotgun_damage_mod = 5;
    level.mechz_failed_paths_to_jump = 3;
    level.mechz_jump_dist_threshold = 4410000;
    level.mechz_jump_delay = 3;
    level.mechz_player_flame_dmg = 10;
    level.mechz_half_front_arc = cos( 45 );
    level.mechz_ft_sweep_chance = 10;
    level.mechz_aim_max_pitch = 60;
    level.mechz_aim_max_yaw = 45;
    level.mechz_custom_goalradius = 48;
    level.mechz_tank_knockdown_time = 5;
    level.mechz_robot_knockdown_time = 10;
    level.mechz_dist_for_sprint = 1440000;
    level.mechz_dist_for_stop_sprint = 490000;
    level.mechz_claw_cooldown_time = 7000;
    level.mechz_flamethrower_cooldown_time = 5000;
    level.mechz_health_percent_ceiling = 0.2;
    mechz_weapon_damage_overrides();
    level.mechz_min_extra_spawn = 8;
    level.mechz_max_extra_spawn = 11;
    level.mechz_remove_helmet_head_dmg_base = 500;
    level.mechz_remove_helmet_head_dmg = level.mechz_remove_helmet_head_dmg_base;
    level.mechz_remove_helmet_head_dmg_increase = 250;
    level.mechz_explosive_dmg_head_scaler = 0.25;
    level.mechz_points_for_killer = 250;
    level.mechz_points_for_team = 500;
    level.mechz_points_for_helmet = 100;
    level.mechz_points_for_powerplant = 100;
    level.mechz_flogger_stun_time = 3;
    level.mechz_powerplant_stun_time = 4;
    level.mechz_powerplant_expose_dmg_base = 300;
    level.mechz_powerplant_expose_dmg = level.mechz_powerplant_expose_base_dmg;
    level.mechz_powerplant_expose_dmg_increase = 100;
    level.mechz_powerplant_destroy_dmg_base = 500;
    level.mechz_powerplant_destroy_dmg = level.mechz_powerplant_destroy_dmg_base;
    level.mechz_powerplant_destroy_dmg_increase = 150;
    level.mechz_explosive_dmg_to_cancel_claw = 1000;
    flag_init( "mechz_launching_claw" );
    registerclientfield( "actor", "mechz_fx", 14000, 12, "int" );
    registerclientfield( "toplayer", "mechz_grab", 14000, 1, "int" );
    level thread init_flamethrower_triggers();
    level thread maps\mp\zombies\_zm_ai_mechz::mechz_spawning_logic();
    scriptmodelsuseanimtree( #animtree );
/#
    setup_devgui();
#/
}

mechz_setup_armor_pieces()
{
    level.mechz_armor_info = [];
    level.mechz_armor_info[0] = spawnstruct();
    level.mechz_armor_info[0].model = "c_zom_mech_armor_knee_left";
    level.mechz_armor_info[0].tag = "J_Knee_Attach_LE";
    level.mechz_armor_info[1] = spawnstruct();
    level.mechz_armor_info[1].model = "c_zom_mech_armor_knee_right";
    level.mechz_armor_info[1].tag = "J_Knee_attach_RI";
    level.mechz_armor_info[2] = spawnstruct();
    level.mechz_armor_info[2].model = "c_zom_mech_armor_shoulder_left";
    level.mechz_armor_info[2].tag = "J_ShoulderArmor_LE";
    level.mechz_armor_info[3] = spawnstruct();
    level.mechz_armor_info[3].model = "c_zom_mech_armor_shoulder_right";
    level.mechz_armor_info[3].tag = "J_ShoulderArmor_RI";
    level.mechz_armor_info[4] = spawnstruct();
    level.mechz_armor_info[4].tag = "J_Root_Attach_LE";
    level.mechz_armor_info[5] = spawnstruct();
    level.mechz_armor_info[5].tag = "J_Root_Attach_RI";

    for ( i = 0; i < level.mechz_armor_info.size; i++ )
    {
        if ( isdefined( level.mechz_armor_info[i].model ) )
            precachemodel( level.mechz_armor_info[i].model );
    }
}

mechz_setup_fx()
{
    self.fx_field = 0;
    self thread booster_fx_watcher();
    self thread flamethrower_fx_watcher();
}

clear_one_off_fx( fx_id )
{
    self endon( "death" );
    wait 10;
    self.fx_field = self.fx_field & ~fx_id;
    self setclientfield( "mechz_fx", self.fx_field );
}

booster_fx_watcher()
{
    self endon( "death" );

    while ( true )
    {
        self waittill( "jump_anim", notetrack );

        if ( notetrack == "booster_on" )
        {
            self.fx_field = self.fx_field | 128;
            self.sndloopent playsound( "zmb_mechz_rocket_start" );
            self.sndloopent playloopsound( "zmb_mechz_rocket_loop", 0.25 );
        }
        else if ( notetrack == "booster_off" )
        {
            self.fx_field = self.fx_field & ~128;
            self.sndloopent playsound( "zmb_mechz_rocket_stop" );
            self.sndloopent stoploopsound( 1 );
        }
        else if ( notetrack == "impact" )
        {
            self.fx_field = self.fx_field | 512;
            self.fx_field = self.fx_field | 2048;
            self thread clear_one_off_fx( 512 );
        }

        self setclientfield( "mechz_fx", self.fx_field );
    }
}

flamethrower_fx_watcher()
{
    self endon( "death" );

    while ( true )
    {
        self waittill( "flamethrower_anim", notetrack );

        if ( notetrack == "start_ft" )
        {
            self.sndloopent playsound( "zmb_mechz_flamethrower_start" );
            self.sndloopent playloopsound( "zmb_mechz_flamethrower_loop", 0.25 );
            self.fx_field = self.fx_field | 64;
        }
        else if ( notetrack == "stop_ft" )
        {
            self.sndloopent stoploopsound( 1 );
            self.fx_field = self.fx_field & ~64;
        }

        self setclientfield( "mechz_fx", self.fx_field );
    }
}

mechz_setup_snd()
{
    self.audio_type = "mechz";

    if ( !isdefined( self.sndloopent ) )
    {
        self.sndloopent = spawn( "script_origin", self.origin );
        self.sndloopent linkto( self, "tag_origin" );
        self thread snddeleteentondeath( self.sndloopent );
    }
}

snddeleteentondeath( ent )
{
    self waittill( "death" );
    ent delete();
}

play_ambient_mechz_vocals()
{
    self endon( "death" );
    wait( randomintrange( 2, 4 ) );

    while ( true )
    {
        if ( isdefined( self ) )
        {
            if ( isdefined( self.favoriteenemy ) && distance( self.origin, self.favoriteenemy.origin ) <= 150 )
            {

            }
            else
                self playsound( "zmb_vocals_mechz_ambience" );
        }

        wait( randomfloatrange( 1, 1.5 ) );
    }
}

enable_mechz_rounds()
{
/#
    if ( getdvarint( #"_id_FA81816F" ) >= 2 )
        return;
#/
    level.mechz_rounds_enabled = 1;
    flag_init( "mechz_round" );
    level thread mechz_round_tracker();
}

mechz_round_tracker()
{
    level.next_mechz_increment_round = randomintrange( level.mechz_min_extra_spawn, level.mechz_max_extra_spawn );
    level.num_mechz_spawned = 0;
    old_spawn_func = level.round_spawn_func;
    old_wait_func = level.round_wait_func;

    while ( !isdefined( level.zombie_mechz_locations ) )
        wait 0.05;

    flag_wait( "activate_zone_nml" );
    level.next_mechz_round = level.round_number + randomint( 2 );
    level thread debug_print_mechz_round();

    while ( true )
    {
        if ( level.num_mechz_spawned > 0 )
            level.mechz_should_drop_powerup = 1;

        if ( level.next_mechz_increment_round <= level.round_number && level.num_mechz_spawned > 0 )
        {
            level.next_mechz_increment_round = level.round_number + randomintrange( level.mechz_min_extra_spawn, level.mechz_max_extra_spawn );

            if ( level.mechz_zombie_per_round < 4 )
                level.mechz_zombie_per_round++;
        }

        if ( level.mechz_left_to_spawn == 0 && level.next_mechz_round <= level.round_number )
        {
            mechz_health_increases();
            level.mechz_left_to_spawn = int( max( level.mechz_zombie_per_round, level.players.size ) );
            wait( randomfloatrange( 0.0, 60.0 ) );
            level notify( "spawn_mechz" );
            level.next_mechz_round = level.round_number + randomintrange( level.mechz_min_round_fq, level.mechz_max_round_fq );
            level thread debug_print_mechz_round();
            level.num_mechz_spawned = level.num_mechz_spawned + int( max( level.mechz_zombie_per_round, level.players.size ) );
        }

        level waittill( "between_round_over" );
        mechz_clear_spawns();
    }
}

debug_print_mechz_round()
{
    flag_wait( "start_zombie_round_logic" );
/#
    iprintln( "Next mechz Round = " + level.next_mechz_round );
#/
}

mechz_spawning_logic()
{
    level thread enable_mechz_rounds();

    while ( true )
    {
        level waittill( "spawn_mechz" );

        while ( level.mechz_left_to_spawn )
        {
            while ( level.zombie_mechz_locations.size < 1 )
                wait( randomfloatrange( 5.0, 10.0 ) );

            ai = spawn_zombie( level.mechz_spawners[0] );
            ai thread mechz_spawn();
            level.mechz_left_to_spawn--;
            wait( randomfloatrange( 60.0, 90.0 ) );
        }
    }
}

mechz_prespawn()
{

}

mechz_attach_objects()
{
    self detachall();
    self.armor_state = [];

    for ( i = 0; i < level.mechz_armor_info.size; i++ )
    {
        self.armor_state[i] = spawnstruct();
        self.armor_state[i].index = i;
        self.armor_state[i].tag = level.mechz_armor_info[i].tag;

        if ( isdefined( level.mechz_armor_info[i].model ) )
        {
            self attach( level.mechz_armor_info[i].model, level.mechz_armor_info[i].tag, 1 );
            self.armor_state[i].model = level.mechz_armor_info[i].model;
        }
    }

    if ( isdefined( self.m_claw ) )
    {
        self.m_claw delete();
        self.m_claw = undefined;
    }

    org = self gettagorigin( "tag_claw" );
    ang = self gettagangles( "tag_claw" );
    self.m_claw = spawn( "script_model", org );
    self.m_claw setmodel( "c_zom_mech_claw" );
    self.m_claw.angles = ang;
    self.m_claw linkto( self, "tag_claw" );
    self.m_claw useanimtree( #animtree );
    self attach( "c_zom_mech_faceplate", "J_Helmet", 1 );
    self.has_helmet = 1;
    self attach( "c_zom_mech_powersupply_cap", "tag_powersupply", 1 );
    self.has_powerplant = 1;
    self.powerplant_covered = 1;
    self.armor_state = array_randomize( self.armor_state );
}

mechz_set_starting_health()
{
    self.maxhealth = level.mechz_health;
    self.helmet_dmg = 0;
    self.helmet_dmg_for_removal = level.mechz_remove_helmet_head_dmg;
    self.powerplant_cover_dmg = 0;
    self.powerplant_cover_dmg_for_removal = level.mechz_powerplant_expose_dmg;
    self.powerplant_dmg = 0;
    self.powerplant_dmg_for_destroy = level.mechz_powerplant_destroy_dmg;
/#
    if ( getdvarint( #"_id_E7121222" ) > 0 )
    {
        println( "\\nMZ: MechZ Starting Health: " + self.maxhealth );
        println( "\\nMZ: MechZ Required Helmet Dmg: " + self.helmet_dmg_for_removal );
    }
#/
    self.health = level.mechz_health;
    self.non_attacker_func = ::mechz_non_attacker_damage_override;
    self.non_attack_func_takes_attacker = 1;
    self.actor_damage_func = ::mechz_damage_override;
    self.instakill_func = ::mechz_instakill_override;
    self.nuke_damage_func = ::mechz_nuke_override;
}

mechz_spawn()
{
    self endon( "death" );
    level endon( "intermission" );
    self mechz_attach_objects();
    self mechz_set_starting_health();
    self mechz_setup_fx();
    self mechz_setup_snd();
    self.closest_player_override = maps\mp\zombies\_zm_ai_mechz::get_favorite_enemy;
    self.animname = "mechz_zombie";
    self.has_legs = 1;
    self.no_gib = 1;
    self.ignore_all_poi = 1;
    self.is_mechz = 1;
    self.ignore_enemy_count = 1;
    self.no_damage_points = 1;
    self.melee_anim_func = ::melee_anim_func;
    self.meleedamage = 75;
    recalc_zombie_array();
    self setphysparams( 20, 0, 80 );
    self.zombie_init_done = 1;
    self notify( "zombie_init_done" );
    self.allowpain = 0;
    self animmode( "normal" );
    self orientmode( "face enemy" );
    self maps\mp\zombies\_zm_spawner::zombie_setup_attack_properties();
    self maps\mp\zombies\_zm_spawner::zombie_complete_emerging_into_playable_area();
    self setfreecameralockonallowed( 0 );
    level thread maps\mp\zombies\_zm_spawner::zombie_death_event( self );
    self thread maps\mp\zombies\_zm_spawner::enemy_death_detection();

    if ( level.zombie_mechz_locations.size )
        spawn_pos = self get_best_mechz_spawn_pos();

    if ( !isdefined( spawn_pos ) )
    {
/#
        println( "ERROR: Tried to spawn mechz with no mechz spawn_positions!\\n" );
        iprintln( "ERROR: Tried to spawn mechz with no mechz spawn_positions!" );
#/
        self delete();
        return;
    }

    if ( isdefined( level.mechz_force_spawn_pos ) )
    {
        spawn_pos = level.mechz_force_spawn_pos;
        level.mechz_force_spawn_pos = undefined;
    }

    if ( !isdefined( spawn_pos.angles ) )
        spawn_pos.angles = ( 0, 0, 0 );

    self thread mechz_death();
    self forceteleport( spawn_pos.origin, spawn_pos.angles );

    if ( !isdefined( spawn_pos.angles ) )
        spawn_pos.angles = ( 0, 0, 0 );

    self animscripted( spawn_pos.origin, spawn_pos.angles, "zm_spawn" );
    self maps\mp\animscripts\zm_shared::donotetracks( "jump_anim" );
    self set_zombie_run_cycle( "walk" );
    self thread mechz_find_flesh();
    self thread mechz_jump_think( spawn_pos );
}

get_closest_mechz_spawn_pos( org )
{
    best_dist = -1;
    best_pos = undefined;
    players = get_players();

    for ( i = 0; i < level.zombie_mechz_locations.size; i++ )
    {
        dist = distancesquared( org, level.zombie_mechz_locations[i].origin );

        if ( dist < best_dist || best_dist < 0 )
        {
            best_dist = dist;
            best_pos = level.zombie_mechz_locations[i];
        }
    }

    return best_pos;
}

get_best_mechz_spawn_pos( ignore_used_positions )
{
    if ( !isdefined( ignore_used_positions ) )
        ignore_used_positions = 0;

    best_dist = -1;
    best_pos = undefined;
    players = get_players();

    for ( i = 0; i < level.zombie_mechz_locations.size; i++ )
    {
        if ( !ignore_used_positions && ( isdefined( level.zombie_mechz_locations[i].has_been_used ) && level.zombie_mechz_locations[i].has_been_used ) )
            continue;

        for ( j = 0; j < players.size; j++ )
        {
            if ( is_player_valid( players[j], 1, 1 ) )
            {
                dist = distancesquared( level.zombie_mechz_locations[i].origin, players[j].origin );

                if ( dist < best_dist || best_dist < 0 )
                {
                    best_dist = dist;
                    best_pos = level.zombie_mechz_locations[i];
                }
            }
        }
    }

    if ( isdefined( best_pos ) )
        best_pos.has_been_used = 1;
    else if ( level.zombie_mechz_locations.size > 0 )
        return level.zombie_mechz_locations[randomint( level.zombie_mechz_locations.size )];

    return best_pos;
}

mechz_clear_spawns()
{
    for ( i = 0; i < level.zombie_mechz_locations.size; i++ )
        level.zombie_mechz_locations[i].has_been_used = 0;
}

mechz_health_increases()
{
    if ( !isdefined( level.mechz_last_spawn_round ) || level.round_number > level.mechz_last_spawn_round )
    {
        a_players = getplayers();
        n_player_modifier = 1;

        if ( a_players.size > 1 )
            n_player_modifier = a_players.size * 0.75;

        level.mechz_health = int( n_player_modifier * ( level.mechz_base_health + level.mechz_health_increase * level.round_number ) );

        if ( level.mechz_health >= 7500 * n_player_modifier )
            level.mechz_health = int( 7500 * n_player_modifier );

        level.mechz_remove_helmet_head_dmg = int( n_player_modifier * ( level.mechz_remove_helmet_head_dmg_base + level.mechz_remove_helmet_head_dmg_increase * level.round_number ) );

        if ( level.mechz_remove_helmet_head_dmg >= 1500 * n_player_modifier )
            level.mechz_remove_helmet_head_dmg = 1500 * n_player_modifier;

        level.mechz_powerplant_expose_dmg = int( n_player_modifier * ( level.mechz_powerplant_expose_dmg_base + level.mechz_powerplant_expose_dmg_increase * level.round_number ) );

        if ( level.mechz_powerplant_expose_dmg >= 1500 * n_player_modifier )
            level.mechz_powerplant_expose_dmg = 1500 * n_player_modifier;

        level.mechz_powerplant_destroy_dmg = int( n_player_modifier * ( level.mechz_powerplant_destroy_dmg_base + level.mechz_powerplant_destroy_dmg_increase * level.round_number ) );

        if ( level.mechz_powerplant_destroy_dmg >= 1500 * n_player_modifier )
            level.mechz_powerplant_destroy_dmg = 1500 * n_player_modifier;

        level.mechz_last_spawn_round = level.round_number;
    }
}

mechz_death()
{
    self endon( "mechz_cleanup" );
    thread mechz_cleanup();
    self waittill( "death" );
    level notify( "mechz_killed", self.origin );
    self release_flamethrower_trigger();
    self.fx_field = 0;
    self setclientfield( "mechz_fx", self.fx_field );
    self mechz_interrupt();

    if ( isdefined( self.favoriteenemy ) )
    {
        if ( isdefined( self.favorite_enemy.hunted_by ) )
            self.favorite_enemy.hunted_by--;
    }

    self playsound( "zmb_mechz_death" );
    level thread mechz_explode( self.origin );

    if ( get_current_zombie_count() == 0 && level.zombie_total == 0 )
    {
        level.last_mechz_origin = self.origin;
        level notify( "last_mechz_down" );
    }

    if ( isplayer( self.attacker ) )
    {
        event = "death";

        if ( issubstr( self.damageweapon, "knife_ballistic_" ) )
            event = "ballistic_knife_death";

        self.attacker thread do_player_general_vox( "general", "mechz_killed", 20, 20 );
        self.attacker maps\mp\zombies\_zm_score::player_add_points( event, self.damagemod, self.damagelocation, 1 );

        if ( isdefined( level.mechz_should_drop_powerup ) && level.mechz_should_drop_powerup )
        {
            wait_network_frame();
            wait_network_frame();
            level.mechz_should_drop_powerup = 0;

            if ( level.powerup_drop_count >= level.zombie_vars["zombie_powerup_drop_max_per_round"] )
                level.powerup_drop_count = level.zombie_vars["zombie_powerup_drop_max_per_round"] - 1;

            level.zombie_vars["zombie_drop_item"] = 1;
            level thread maps\mp\zombies\_zm_powerups::powerup_drop( self.origin );
        }
    }
}

mechz_explode( v_origin )
{
    wait 3.0;
    level notify( "mechz_exploded", v_origin );
    playsoundatposition( "zmb_mechz_death_explode", v_origin );
    playfx( level._effect["mechz_death"], v_origin );
    radiusdamage( v_origin, 128, 100, 25 );
    earthquake( 0.5, 1.0, v_origin, 256 );
    playrumbleonposition( "grenade_rumble", v_origin );
}

mechz_cleanup()
{
    self waittill( "mechz_cleanup" );
    self mechz_interrupt();
    level.sndmechzistalking = 0;

    if ( isdefined( self.sndmechzmusicent ) )
    {
        self.sndmechzmusicent delete();
        self.sndmechzmusicent = undefined;
    }

    if ( isdefined( self.favoriteenemy ) )
    {
        if ( isdefined( self.favorite_enemy.hunted_by ) )
            self.favorite_enemy.hunted_by--;
    }
}

mechz_interrupt()
{
    self notify( "kill_claw" );
    self notify( "kill_ft" );
    self notify( "kill_jump" );
}

mechz_stun( time )
{
    self endon( "death" );

    if ( !isalive( self ) )
        return;

    curr_time = 0;
    anim_time = self getanimlengthfromasd( "zm_stun", 0 );
    self mechz_interrupt();
    self mechz_claw_detach();
    wait 0.05;
    self.not_interruptable = 1;

    while ( curr_time < time )
    {
        self animscripted( self.origin, self.angles, "zm_stun" );
        self thread maps\mp\animscripts\zm_shared::donotetracks( "stun_anim" );
        self waittillmatch( "stun_anim", "end" );
        self clearanim( %root, 0 );
        curr_time = curr_time + anim_time;
    }

    self.not_interruptable = 0;
}

mechz_tank_hit_callback()
{
    self endon( "death" );
    self.not_interruptable = 1;
    timer = 0;
    self animscripted( self.origin, self.angles, "zm_tank_hit_in" );
    self maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
    anim_length = self getanimlengthfromasd( "zm_tank_hit_loop", 0 );

    while ( timer < level.mechz_tank_knockdown_time )
    {
        timer = timer + anim_length;
        self animscripted( self.origin, self.angles, "zm_tank_hit_loop" );
        self maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
    }

    self animscripted( self.origin, self.angles, "zm_tank_hit_out" );
    self maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
    self.not_interruptable = 0;
}

mechz_robot_stomp_callback()
{
    self endon( "death" );
    self.not_interruptable = 1;
    timer = 0;
    self animscripted( self.origin, self.angles, "zm_robot_hit_in" );
    self maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
    anim_length = self getanimlengthfromasd( "zm_robot_hit_loop", 0 );

    while ( timer < level.mechz_tank_knockdown_time )
    {
        timer = timer + anim_length;
        self animscripted( self.origin, self.angles, "zm_robot_hit_loop" );
        self maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
    }

    self animscripted( self.origin, self.angles, "zm_robot_hit_out" );
    self maps\mp\animscripts\zm_shared::donotetracks( "jump_anim" );
    self.not_interruptable = 0;
}

mechz_delayed_item_delete()
{
    wait 30;
    self delete();
}

mechz_get_closest_valid_player()
{
    players = get_players();

    if ( isdefined( self.ignore_player ) )
    {
        for ( i = 0; i < self.ignore_player.size; i++ )
            arrayremovevalue( players, self.ignore_player[i] );
    }

    for ( i = 0; i < players.size; i++ )
    {
        if ( isdefined( level._zombie_using_humangun ) && level._zombie_using_humangun && isai( players[i] ) )
            return players[i];

        if ( !is_player_valid( players[i], 1, 1 ) )
        {
            arrayremovevalue( players, players[i] );
            i--;
        }
    }

    switch ( players.size )
    {
        case 0:
            return undefined;
        case 1:
            return players[0];
        default:
            if ( isdefined( level.closest_player_override ) )
                player = [[ level.closest_player_override ]]( self.origin, players );
            else if ( isdefined( level.calc_closest_player_using_paths ) && level.calc_closest_player_using_paths )
                player = get_closest_player_using_paths( self.origin, players );
            else
                player = getclosest( self.origin, players );

            return player;
    }
}

get_favorite_enemy( origin, players )
{
    if ( isdefined( self.favoriteenemy ) && is_player_valid( self.favoriteenemy, 1, 1 ) )
    {
        if ( distancesquared( self.origin, self.favoriteenemy.origin ) <= level.mechz_reset_dist_sq )
            return self.favoriteenemy;
    }

    mechz_targets = getplayers();
    least_hunted = undefined;

    for ( i = 0; i < mechz_targets.size; i++ )
    {
        if ( !isdefined( mechz_targets[i].hunted_by ) || mechz_targets[i].hunted_by < 0 )
            mechz_targets[i].hunted_by = 0;

        if ( !is_player_valid( mechz_targets[i], 1, 1 ) )
            continue;

        if ( !isdefined( least_hunted ) || mechz_targets[i].hunted_by < least_hunted.hunted_by )
            least_hunted = mechz_targets[i];
    }

    if ( isdefined( self.favoriteenemy ) && isdefined( least_hunted ) && self.favoriteenemy != least_hunted )
    {
        if ( isdefined( self.favoriteenemy.hunted_by ) )
            self.favoriteenemy.hunted_by--;
    }

    if ( isdefined( least_hunted ) )
        least_hunted.hunted_by++;

    return least_hunted;
}

mechz_check_in_arc()
{
    facing_vec = anglestoforward( self.angles );
    enemy_vec = self.favoriteenemy.origin - self.origin;
    enemy_yaw_vec = ( enemy_vec[0], enemy_vec[1], 0 );
    facing_yaw_vec = ( facing_vec[0], facing_vec[1], 0 );
    enemy_yaw_vec = vectornormalize( enemy_yaw_vec );
    facing_yaw_vec = vectornormalize( facing_yaw_vec );
    enemy_dot = vectordot( facing_yaw_vec, enemy_yaw_vec );

    if ( enemy_dot < cos( level.mechz_aim_max_yaw ) )
        return false;

    enemy_angles = vectortoangles( enemy_vec );

    if ( abs( angleclamp180( enemy_angles[0] ) ) > level.mechz_aim_max_pitch )
        return false;

    return true;
}

mechz_get_aim_anim( anim_prefix, target_pos )
{
    in_arc = self mechz_check_in_arc();

    if ( !in_arc )
        return undefined;

    aiming_vec = vectortoangles( target_pos - self.origin );
    pitch = angleclamp180( aiming_vec[0] );
    yaw = angleclamp180( self.angles[1] - aiming_vec[1] );
    centered_ud = abs( pitch ) < level.mechz_aim_max_pitch / 2;
    centered_lr = abs( yaw ) < level.mechz_aim_max_yaw / 2;
    right_anim = self.angles[1] - aiming_vec[1] > 0;
    up_anim = pitch < 0;

    if ( centered_ud && centered_lr )
        return anim_prefix + "_aim_5";
    else if ( centered_ud && right_anim )
        return anim_prefix + "_aim_6";
    else if ( centered_ud )
        return anim_prefix + "_aim_4";
    else if ( centered_lr && up_anim )
        return anim_prefix + "_aim_8";
    else if ( centered_lr )
        return anim_prefix + "_aim_2";
    else if ( right_anim && up_anim )
        return anim_prefix + "_aim_9";
    else if ( right_anim )
        return anim_prefix + "_aim_3";
    else if ( up_anim )
        return anim_prefix + "_aim_7";
    else
        return anim_prefix + "_aim_1";
}

mechz_start_basic_find_flesh()
{
    self.goalradius = level.mechz_custom_goalradius;
    self.custom_goalradius_override = level.mechz_custom_goalradius;

    if ( !isdefined( self.ai_state ) || self.ai_state != "find_flesh" )
    {
        self.ai_state = "find_flesh";
        self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
    }
}

mechz_stop_basic_find_flesh()
{
    if ( isdefined( self.ai_state ) && self.ai_state == "find_flesh" )
    {
        self.ai_state = undefined;
        self notify( "stop_find_flesh" );
        self notify( "zombie_acquire_enemy" );
    }
}

watch_for_player_dist()
{
    self endon( "death" );

    while ( true )
    {
        player = mechz_get_closest_valid_player();

        if ( !isdefined( player ) || distancesquared( player.origin, self.origin ) > level.mechz_reset_dist_sq )
            self.disable_complex_behaviors = 0;

        wait 0.5;
    }
}

mechz_find_flesh()
{
    self endon( "death" );
    level endon( "intermission" );

    if ( level.intermission )
        return;

    self.helitarget = 1;
    self.ignoreme = 0;
    self.nododgemove = 1;
    self.ignore_player = [];
    self.goalradius = 32;
    self.ai_state = "spawning";
    self thread watch_for_player_dist();

    while ( true )
    {
/#
        if ( isdefined( self.force_behavior ) && self.force_behavior )
        {
            wait 0.05;
            continue;
        }
#/

        if ( isdefined( self.not_interruptable ) && self.not_interruptable )
        {
/#
            if ( getdvarint( #"_id_E7121222" ) > 1 )
                println( "\\nMZ: Not thinking since a behavior has set not_interruptable\\n" );
#/
            wait 0.05;
            continue;
        }

        player = get_favorite_enemy();
        self mechz_set_locomotion_speed();
/#
        if ( getdvarint( #"_id_E7121222" ) > 1 )
            println( "\\nMZ: Doing think\\n" );
#/

        if ( !isdefined( player ) )
        {
/#
            if ( getdvarint( #"_id_E7121222" ) > 1 )
                println( "\\n\\tMZ: No Enemy, idling\\n" );
#/
            self.goal_pos = self.origin;
            self.ai_state = "idle";
            self setanimstatefromasd( "zm_idle" );
            wait 0.5;
            continue;
        }

        self.favorite_enemy = player;
        self.favoriteenemy = player;

        if ( player entity_on_tank() )
        {
/#
            if ( getdvarint( #"_id_E7121222" ) > 1 )
                println( "\\n\\tMZ: Enemy on tank, targetting a tank pos\\n" );
#/
            self.disable_complex_behaviors = 0;
            self mechz_stop_basic_find_flesh();
            self.ai_state = "tracking_tank";
            self.goalradius = level.mechz_custom_goalradius;
            self.custom_goalradius_override = level.mechz_custom_goalradius;
            self orientmode( "face enemy" );
            self.goal_pos = level.vh_tank get_closest_tank_tag( player.origin );
            self setgoalpos( self.goal_pos );
            wait 0.5;
            continue;
        }
        else if ( self.zombie_move_speed == "sprint" && isdefined( player ) )
        {
/#
            if ( getdvarint( #"_id_E7121222" ) > 1 )
                println( "\\n\\tMZ: Sprinting\\n" );
#/
            self.goal_pos = player.origin;
            self setgoalpos( self.goal_pos );
        }
        else if ( distancesquared( self.origin, player.origin ) < level.mechz_aggro_dist_sq )
        {
/#
            if ( getdvarint( #"_id_E7121222" ) > 1 )
                println( "\\n\\tMZ: Player very close, switching to melee only\\n" );
#/
            self.disable_complex_behaviors = 1;
        }
        else if ( self should_do_claw_attack() )
        {
            self mechz_do_claw_grab();
            continue;
        }
        else if ( self should_do_flamethrower_attack() )
        {
            self mechz_do_flamethrower_attack();
            continue;
        }
        else if ( isdefined( self.jump_requested ) && self.jump_requested || isdefined( self.force_jump ) && self.force_jump )
        {
            if ( self mechz_in_range_for_jump() )
                self mechz_do_jump();
            else
            {
/#
                if ( getdvarint( #"_id_E7121222" ) > 1 )
                    println( "\\n\\tMZ: Jump Requested, going to jump pos\\n" );
#/
                self.goal_pos = self.jump_pos.origin;
                self setgoalpos( self.goal_pos );
            }
        }

/#
        if ( getdvarint( #"_id_E7121222" ) > 1 )
            println( "\\n\\tMZ: No special behavior valid, heading after player\\n" );
#/
        self.goal_pos = player.origin;
        mechz_start_basic_find_flesh();
        wait 0.5;
    }
}

melee_anim_func()
{
    self.next_leap_time = gettime() + 1500;
}

mechz_weapon_damage_overrides()
{
    level.mechz_weapon_ceilings = [];
    level.mechz_weapon_ceilings["raygun_mark2_zm"] = 0.05;
    level.mechz_weapon_ceilings["raygun_mark2_upgraded_zm"] = 0.05;
}

mechz_launch_armor_piece()
{
    if ( !isdefined( self.next_armor_piece ) )
        self.next_armor_piece = 0;

    if ( !isdefined( self.armor_state ) || self.next_armor_piece >= self.armor_state.size )
    {
/#
        println( "Trying to launch armor piece after all pieces have already been launched!" );
#/
        return;
    }

    if ( isdefined( self.armor_state[self.next_armor_piece].model ) )
        self detach( self.armor_state[self.next_armor_piece].model, self.armor_state[self.next_armor_piece].tag );

    self.fx_field = self.fx_field | 1 << self.armor_state[self.next_armor_piece].index;
    self setclientfield( "mechz_fx", self.fx_field );
    self.next_armor_piece++;
}

mechz_damage_override( inflictor, attacker, damage, flags, meansofdeath, weapon, vpoint, vdir, shitloc, poffsettime, boneindex )
{
    num_tiers = level.mechz_armor_info.size + 1;
    old_health_tier = int( num_tiers * self.health / self.maxhealth );
    bonename = getpartname( "c_zom_mech_body", boneindex );

    if ( isdefined( self.last_damage_time ) && self.last_damage_time >= gettime() )
        return 0;

    self.last_damage_time = gettime();

    if ( isdefined( attacker ) && isalive( attacker ) && isplayer( attacker ) && ( level.zombie_vars[attacker.team]["zombie_insta_kill"] || isdefined( attacker.personal_instakill ) && attacker.personal_instakill ) )
    {
        n_mechz_damage_percent = 1.0;
        n_mechz_headshot_modifier = 2.0;
    }
    else
    {
        n_mechz_damage_percent = level.mechz_damage_percent;
        n_mechz_headshot_modifier = 1.0;
    }

    if ( isdefined( weapon ) && is_weapon_shotgun( weapon ) )
    {
        n_mechz_damage_percent = n_mechz_damage_percent * level.mechz_shotgun_damage_mod;
        n_mechz_headshot_modifier = n_mechz_headshot_modifier * level.mechz_shotgun_damage_mod * 2;
    }
    else if ( isdefined( weapon ) && issubstr( weapon, "staff" ) && isplayer( attacker ) )
    {
        if ( issubstr( weapon, "upgraded" ) )
            n_mechz_damage_percent = 1.0;
        else
            n_mechz_damage_percent = 0.5;
    }

    if ( is_explosive_damage( meansofdeath ) )
    {
        if ( n_mechz_damage_percent < 0.5 )
            n_mechz_damage_percent = 0.5;

        final_damage = damage * n_mechz_damage_percent;

        if ( !isdefined( self.explosive_dmg_taken ) )
            self.explosive_dmg_taken = 0;

        self.explosive_dmg_taken = self.explosive_dmg_taken + damage;
        self.helmet_dmg = self.helmet_dmg + damage;
    }
    else if ( shitloc != "head" && shitloc != "helmet" )
    {
        if ( bonename == "tag_powersupply" )
        {
            final_damage = damage * n_mechz_damage_percent;

            if ( !( isdefined( self.powerplant_covered ) && self.powerplant_covered ) )
                self.powerplant_dmg = self.powerplant_dmg + damage;
            else
                self.powerplant_cover_dmg = self.powerplant_cover_dmg + damage;
        }

        if ( isdefined( self.e_grabbed ) && ( shitloc == "left_hand" || shitloc == "left_arm_lower" ) )
            self thread mechz_claw_release();

        final_damage = damage * n_mechz_damage_percent;
    }
    else if ( !( isdefined( self.has_helmet ) && self.has_helmet ) )
        final_damage = damage * n_mechz_headshot_modifier;
    else
    {
        final_damage = damage * n_mechz_damage_percent;
        self.helmet_dmg = self.helmet_dmg + damage;
    }

    if ( isdefined( weapon ) && isdefined( level.mechz_weapon_ceilings[weapon] ) )
        health_percent_ceiling = level.mechz_weapon_ceilings[weapon];
    else
        health_percent_ceiling = level.mechz_health_percent_ceiling;

    if ( final_damage > self.maxhealth * health_percent_ceiling )
        final_damage = int( self.maxhealth * health_percent_ceiling );

    if ( !isdefined( weapon ) || weapon == "none" )
        final_damage = 0;

    new_health_tier = int( num_tiers * ( self.health - final_damage ) / self.maxhealth );

    if ( old_health_tier > new_health_tier )
    {
        while ( old_health_tier > new_health_tier )
        {
/#
            if ( getdvarint( #"_id_E7121222" ) > 0 )
                println( "\\nMZ: Old tier: " + old_health_tier + "   New Health Tier: " + new_health_tier + "   Launching armor piece" );
#/

            if ( old_health_tier < num_tiers )
                self mechz_launch_armor_piece();

            old_health_tier--;
        }
    }

    if ( isdefined( self.has_helmet ) && self.has_helmet && self.helmet_dmg >= self.helmet_dmg_for_removal )
    {
        self.has_helmet = 0;
        self detach( "c_zom_mech_faceplate", "J_Helmet" );
        self.fx_field = self.fx_field | 1024;
        self setclientfield( "mechz_fx", self.fx_field );
    }

    if ( isdefined( self.powerplant_covered ) && self.powerplant_covered && self.powerplant_cover_dmg >= self.powerplant_cover_dmg_for_removal )
    {
        self.powerplant_covered = 0;
        self detach( "c_zom_mech_powersupply_cap", "tag_powersupply" );
        cap_model = spawn( "script_model", self gettagorigin( "tag_powersupply" ) );
        cap_model.angles = self gettagangles( "tag_powersupply" );
        cap_model setmodel( "c_zom_mech_powersupply_cap" );
        cap_model physicslaunch( cap_model.origin, anglestoforward( cap_model.angles ) );
        cap_model thread mechz_delayed_item_delete();
    }
    else if ( !( isdefined( self.powerplant_covered ) && self.powerplant_covered ) && ( isdefined( self.has_powerplant ) && self.has_powerplant ) && self.powerplant_dmg >= self.powerplant_dmg_for_destroy )
    {
        self.has_powerplant = 0;
        self thread mechz_stun( level.mechz_powerplant_stun_time );
    }

/#
    if ( getdvarint( #"_id_E7121222" ) > 0 )
    {
        println( "\\nMZ: Doing " + final_damage + " damage to mechz,   Health Remaining: " + self.health + " Time: " + self.last_damage_time );

        if ( self.helmet_dmg < self.helmet_dmg_for_removal )
            println( "\\nMZ: Current helmet dmg: " + self.helmet_dmg + "    Required helmet dmg: " + self.helmet_dmg_for_removal );
    }
#/
    return final_damage;
}

mechz_non_attacker_damage_override( damage, weapon, attacker )
{
    if ( attacker == level.vh_tank )
        self thread mechz_tank_hit_callback();

    return false;
}

mechz_instakill_override()
{

}

mechz_nuke_override()
{
    self endon( "death" );
    wait( randomfloatrange( 0.1, 0.7 ) );
    self playsound( "evt_nuked" );
    self dodamage( self.health * 0.25, self.origin );
}

mechz_fire_trap_callback()
{
    return false;
}

mechz_flogger_trap_callback( flogger_trap )
{
    self mechz_stun( level.mechz_flogger_stun_time );
}

mechz_set_locomotion_speed()
{
    self endon( "death" );
    self.prev_move_speed = self.zombie_move_speed;

    if ( !isdefined( self.favoriteenemy ) )
        self.zombie_move_speed = "walk";
    else if ( isdefined( self.force_run ) && self.force_run )
        self.zombie_move_speed = "run";
    else if ( isdefined( self.force_sprint ) && self.force_sprint )
        self.zombie_move_speed = "sprint";
    else if ( isdefined( self.favoriteenemy ) && self.favoriteenemy entity_on_tank() && isdefined( level.vh_tank ) && level.vh_tank ent_flag( "tank_activated" ) )
        self.zombie_move_speed = "run";
    else if ( isdefined( self.favoriteenemy ) && distancesquared( self.origin, self.favoriteenemy.origin ) > level.mechz_dist_for_sprint )
        self.zombie_move_speed = "sprint";
    else if ( !( isdefined( self.has_powerplant ) && self.has_powerplant ) )
        self.zombie_move_speed = "run";
    else
        self.zombie_move_speed = "walk";

    if ( self.zombie_move_speed == "sprint" && self.prev_move_speed != "sprint" )
    {
        self animscripted( self.origin, self.angles, "zm_sprint_intro" );
        self maps\mp\animscripts\zm_shared::donotetracks( "jump_anim" );
    }
    else if ( self.zombie_move_speed != "sprint" && self.prev_move_speed == "sprint" )
    {
        self animscripted( self.origin, self.angles, "zm_sprint_outro" );
        self maps\mp\animscripts\zm_shared::donotetracks( "jump_anim" );
    }

    self set_zombie_run_cycle( self.zombie_move_speed );
}
