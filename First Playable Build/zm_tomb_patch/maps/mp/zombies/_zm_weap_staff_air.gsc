// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_perk_oneinch_punch;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\animscripts\shared;

init()
{
    level._effect["whirlwind"] = loadfx( "weapon/zmb_staff/fx_zmb_staff_air_ug_impact_miss" );
    registerclientfield( "scriptmover", "whirlwind_play_fx", 14000, 1, "int" );
    onplayerconnect_callback( ::onplayerconnect );
    maps\mp\zombies\_zm_ai_basic::init_inert_zombies();
    level.whirlwind_exists = 0;
    maps\mp\zombies\_zm_spawner::register_zombie_damage_callback( ::staff_air_zombie_damage_response );
    maps\mp\zombies\_zm_spawner::register_zombie_death_event_callback( ::staff_air_death_event );
}

onplayerconnect()
{
    self thread onplayerspawned();
}

onplayerspawned()
{
    self endon( "disconnect" );
    self thread watch_staff_air_fired();
    self thread watch_staff_air_impact();
    self thread watch_staff_usage();
}

watch_staff_air_fired()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "missile_fire", e_projectile, str_weapon );

        if ( str_weapon == "staff_air_upgraded_zm" || str_weapon == "staff_air_zm" )
            wind_locate_target();
    }
}

watch_staff_air_impact()
{
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "projectile_impact", str_weap_name, v_explode_point, n_radius, projectile );

        if ( str_weap_name == "staff_air_upgraded2_zm" || str_weap_name == "staff_air_upgraded3_zm" )
            self thread staff_air_find_source( v_explode_point );
    }
}

staff_air_find_source( v_detonate )
{
    self endon( "disconnect" );

    if ( !isdefined( v_detonate ) )
        return;

    a_zombies = get_round_enemy_array();
    a_zombies = get_array_of_closest( v_detonate, a_zombies );

    if ( a_zombies.size )
    {
        for ( i = 0; i < a_zombies.size; i++ )
        {
            if ( isalive( a_zombies[i] ) )
            {
                if ( is_true( a_zombies[i].staff_hit ) )
                    continue;

                if ( distance2dsquared( v_detonate, a_zombies[i].origin ) <= 10000 )
                    self thread staff_air_zombie_source( a_zombies[0] );
                else
                    self thread staff_air_position_source( v_detonate );

                return;
            }
        }
    }
    else
        self thread staff_air_position_source( v_detonate );
}

staff_air_zombie_source( ai_zombie )
{
    self endon( "disconnect" );
    ai_zombie.staff_hit = 1;
    ai_zombie.is_source = 1;
    v_whirlwind_pos = ai_zombie.origin;
    self thread staff_air_position_source( v_whirlwind_pos );

    if ( !isdefined( ai_zombie.is_mechz ) )
        self thread source_zombie_death( ai_zombie );
}

staff_air_position_source( v_detonate )
{
    self endon( "disconnect" );

    if ( isdefined( v_detonate ) && !level.whirlwind_exists )
    {
        level.whirlwind_exists = 1;
        n_time = self.chargeshotlevel * 3;
        e_whirlwind = spawn( "script_model", v_detonate + vectorscale( ( 0, 0, 1 ), 100.0 ) );
        e_whirlwind setmodel( "tag_origin" );
        e_whirlwind.angles = vectorscale( ( -1, 0, 0 ), 90.0 );
        e_whirlwind moveto( groundpos_ignore_water_new( e_whirlwind.origin ), 0.05 );
        e_whirlwind waittill( "movedone" );
        e_whirlwind setclientfield( "whirlwind_play_fx", 1 );
        e_whirlwind thread whirlwind_timeout( n_time );
        wait 0.5;
        e_whirlwind thread whirlwind_seek_zombies( self.chargeshotlevel );
    }
    else
    {

    }
}

whirlwind_seek_zombies( n_level )
{
    self endon( "death" );
    self.b_found_zombies = 0;
    n_range = get_air_blast_range( n_level );

    while ( true )
    {
        a_zombies = staff_air_zombie_range( self.origin, n_range );

        if ( a_zombies.size )
        {
            self.b_found_zombies = 1;
            self thread whirlwind_kill_zombies( n_level );
            break;
        }

        wait 0.1;
    }
}

whirlwind_timeout( n_time )
{
    self endon( "death" );
    wait( n_time );

    if ( !self.b_found_zombies )
    {
        self setclientfield( "whirlwind_play_fx", 0 );
        level.whirlwind_exists = 0;
        wait 1.5;
        self delete();
    }
    else
    {
        wait( n_time );
        self setclientfield( "whirlwind_play_fx", 0 );
        level.whirlwind_exists = 0;
        wait 1.5;
        self delete();
    }
}

whirlwind_kill_zombies( n_level )
{
    self endon( "death" );
    n_range = get_air_blast_range( n_level );

    while ( true )
    {
        a_zombies = staff_air_zombie_range( self.origin, n_range );
        a_zombies = get_array_of_closest( self.origin, a_zombies );

        if ( !a_zombies.size )
            break;

        n_dist = distance2dsquared( self.origin, a_zombies[0].origin );

        while ( isalive( a_zombies[0] ) && !isdefined( a_zombies[0].is_mechz ) && n_dist > 90000 )
        {
            n_dist = distance2dsquared( self.origin, a_zombies[0].origin );

            if ( isdefined( a_zombies[0].ai_state ) && a_zombies[0].ai_state == "find_flesh" )
                self thread move_along_ground_position( a_zombies[0].origin, 1.0 );
            else
                break;

            wait 0.05;
        }

        self moveto( self.origin, 0.05 );
        self waittill( "movedone" );

        for ( i = 0; i < a_zombies.size; i++ )
        {
            if ( isdefined( a_zombies[i] ) && is_true( a_zombies[i].ai_state == "find_flesh" ) && !isdefined( a_zombies[i].is_mechz ) )
            {
                a_zombies[i] thread whirlwind_drag_zombie( self );
                wait 0.5;
            }
        }

        wait 0.05;
    }
}

whirlwind_drag_zombie( e_whirlwind )
{
    self whirlwind_spin_zombie( e_whirlwind );

    if ( isdefined( self ) && isdefined( e_whirlwind ) )
        self zombie_launch( e_whirlwind );
}

whirlwind_spin_zombie( e_whirlwind )
{
    e_linker = spawn( "script_origin", ( 0, 0, 0 ) );
    e_linker.origin = self.origin;
    e_linker.angles = self.angles;
    e_linker.n_spins = 0;
    n_rot_amount = 90;
    n_range = 400;
    self linkto( e_linker );
    self thread whirlwind_unlink( e_whirlwind );

    if ( isdefined( e_whirlwind ) )
        n_dist = distance2dsquared( e_whirlwind.origin, self.origin );

    while ( isalive( self ) && n_dist > n_range && isdefined( e_whirlwind ) )
    {
        n_dist = distance2dsquared( e_whirlwind.origin, self.origin );

        if ( isdefined( self.ai_state ) && self.ai_state == "find_flesh" )
            e_linker thread move_along_ground_position( e_whirlwind.origin, 1.0 );
        else
            break;

        wait 0.05;
    }

    while ( e_linker.n_spins < 20 )
    {
        e_linker rotateyaw( n_rot_amount, 0.05 );
        wait 0.05;
        e_linker.n_spins++;

        if ( e_linker.n_spins > 10 )
            n_rot_amount = 180;
    }

    e_linker delete();
}

whirlwind_unlink( e_whirlwind )
{
    self endon( "death" );
    e_whirlwind waittill( "death" );
    self unlink();
}

source_zombie_death( ai_zombie )
{
    self endon( "disconnect" );
    n_range = get_air_blast_range( self.chargeshotlevel );
    tag = "J_SpineUpper";

    if ( ai_zombie.isdog )
        tag = "J_Spine1";

    v_source = ai_zombie gettagorigin( tag );
    ai_zombie thread staff_air_fling_zombie( self );
    a_zombies = staff_air_zombie_range( v_source, n_range );

    if ( !isdefined( a_zombies ) )
        return;

    self thread staff_air_proximity_kill( a_zombies );
}

get_air_blast_range( n_charge )
{
    switch ( n_charge )
    {
        case 1:
            n_range = 10000;
            break;
        case 2:
            n_range = 40000;
            break;
        case 3:
            n_range = 90000;
            break;
    }

    return n_range;
}

staff_air_proximity_kill( a_zombies )
{
    self endon( "disconnect" );

    if ( !isdefined( a_zombies ) )
        return;

    for ( i = 0; i < a_zombies.size; i++ )
    {
        if ( isalive( a_zombies[i] ) )
        {
            a_zombies[i] thread staff_air_fling_zombie( self );
            wait 0.05;
        }
    }
}

staff_air_zombie_range( v_source, n_range )
{
    a_enemies = [];
    a_zombies = get_round_enemy_array();
    a_zombies = get_array_of_closest( v_source, a_zombies );

    if ( isdefined( a_zombies ) )
    {
        for ( i = 0; i < a_zombies.size; i++ )
        {
            if ( !isdefined( a_zombies[i] ) )
                continue;

            v_zombie_pos = a_zombies[i].origin;

            if ( isdefined( a_zombies[i].staff_hit ) && a_zombies[i].staff_hit == 1 )
                continue;

            if ( distancesquared( v_source, v_zombie_pos ) > n_range )
                continue;

            a_enemies[a_enemies.size] = a_zombies[i];
        }
    }

    return a_enemies;
}

staff_air_fling_zombie( player )
{
    player endon( "disconnect" );

    if ( !isalive( self ) )
        return;

    if ( isdefined( self.is_source ) )
        self thread zombie_launch( player );
    else if ( cointoss() )
        self thread zombie_launch( player );
    else
    {
        self dodamage( self.health, player.origin, player, player, "none", "MOD_EXPLOSIVE", 0, "staff_air_upgraded_zm" );
        level thread staff_air_gib( self );
    }
}

zombie_launch( e_attacker, v_initial )
{
    if ( isdefined( v_initial ) )
        v_launch = v_initial;
    else
        v_launch = determine_launch_vector( e_attacker, self );

    self dodamage( self.health, e_attacker.origin, e_attacker );
    self startragdoll();

    if ( isdefined( v_launch ) )
        self launchragdoll( v_launch );

    if ( isdefined( self ) && cointoss() )
        self thread monitor_zombie_ragdoll_velocity();
}

monitor_zombie_ragdoll_velocity()
{
    if ( !isdefined( self ) )
        return;

    v_start = vectornormalize( self getvelocity() );

    while ( isdefined( self ) )
    {
        wait 0.1;

        if ( isdefined( self ) )
        {
            v_current = vectornormalize( self getvelocity() );

            if ( isdefined( v_current ) && isdefined( v_start ) )
            {
                n_delta = vectordot( v_start, v_current );

                if ( isdefined( n_delta ) && abs( n_delta ) < 0.9 )
                {
                    level thread staff_air_gib( self );
                    break;
                }
            }
        }
    }
}

determine_launch_vector( e_attacker, ai_target )
{
    v_launch = vectornormalize( ai_target.origin - e_attacker.origin ) * randomintrange( 125, 150 ) + ( 0, 0, randomintrange( 75, 150 ) );
    return v_launch;
}

staff_air_gib( ai_zombie )
{
    a_gib_ref = [];
    a_gib_ref[0] = level._zombie_gib_piece_index_all;
    ai_zombie gib( "normal", a_gib_ref );
}

staff_air_zombie_damage_response( mod, hit_location, hit_origin, player, amount )
{
    if ( self is_staff_air_damage() )
    {
        self thread stun_zombie();
        return true;
    }

    return false;
}

is_staff_air_damage()
{
    return isdefined( self.damageweapon ) && ( self.damageweapon == "staff_air_zm" || self.damageweapon == "staff_air_upgraded_zm" );
}

staff_air_zombie_hit_response_internal( mod, damageweapon, player )
{
    player endon( "disconnect" );
    self endon( "death" );

    if ( !is_true( self.is_mechz ) )
        player thread maps\mp\zombies\_zm_perk_oneinch_punch::zombie_punch_damage( self );
}

staff_air_death_event()
{
    if ( is_staff_air_damage() )
    {
        if ( is_true( self.is_mechz ) )
            return;

        self thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( "death", self.animname );
        self thread zombie_eye_glow_stop();
        self startragdoll();
        v_launch = determine_launch_vector( self.attacker, self );

        if ( isdefined( v_launch ) )
            self launchragdoll( v_launch );

        if ( isdefined( self ) && cointoss() )
            self thread monitor_zombie_ragdoll_velocity();
    }
}

staff_air_impact_damage( v_explode_point )
{
    radiusdamage( v_explode_point, 120, 2000, 1500, self, "MOD_IMPACT", "staff_air_upgraded_zm" );
}

wind_locate_target( is_not_upgraded )
{
    if ( !isdefined( is_not_upgraded ) )
        is_not_upgraded = 1;

    fire_angles = self getplayerangles();
    fire_origin = self getplayercamerapos();
    a_targets = getaiarray( "axis" );
    a_targets = get_array_of_closest( self.origin, a_targets, undefined, undefined, 500 );

    foreach ( target in a_targets )
    {
        if ( within_fov( fire_origin, fire_angles, target gettagorigin( "j_spine4" ), cos( 45 ) ) )
        {
            if ( isai( target ) )
                target dodamage( 2000, self.origin, self, self, "none", "MOD_IMPACT", 0, "staff_air_zm" );
        }
    }
}

stun_zombie()
{
    self endon( "death" );

    if ( is_true( self.is_mechz ) )
        return;

    if ( is_true( self.is_electrocuted ) )
        return;

    self.forcemovementscriptstate = 1;
    self.ignoreall = 1;
    self.is_electrocuted = 1;
    tag = "J_SpineUpper";

    if ( self.isdog )
        tag = "J_Spine1";

    self animscripted( self.origin, self.angles, "zm_electric_stun" );
    self maps\mp\animscripts\shared::donotetracks( "stunned" );
    self.forcemovementscriptstate = 0;
    self.ignoreall = 0;
    self.is_electrocuted = 0;
}
