// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_equipment;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\animscripts\zm_shared;
#include maps\mp\zombies\_zm_zonemgr;

setup_devgui()
{
/#
    setdvar( "build_quadrotor", "off" );
    setdvar( "complete_staffs", "off" );
    setdvar( "open_chambers", "off" );
    setdvar( "complete_puzzles1", "off" );
    setdvar( "complete_puzzles2", "off" );
    adddebugcommand( "devgui_cmd \"Zombies/Tomb:1/Open Chamber Doors:1\" \"open_chambers on\"\n" );
    adddebugcommand( "devgui_cmd \"Zombies/Tomb:1/Skip Chamber Puzzles:2\" \"complete_puzzles1 on\"\n" );
    adddebugcommand( "devgui_cmd \"Zombies/Tomb:1/Skip Top-side Puzzles:3\" \"complete_puzzles2 on\"\n" );
    level thread watch_devgui_quadrotor();
    level thread watch_devgui_complete_puzzles();
    level thread watch_for_upgraded_staffs();
#/
}

watch_for_upgraded_staffs()
{
/#
    cmd = "";

    while ( true )
    {
        wait 0.25;

        if ( !isdefined( level.zombie_devgui_gun ) || level.zombie_devgui_gun != cmd )
        {
            a_players = get_players();

            foreach ( player in a_players )
            {
                has_upgraded_staff = 0;
                has_revive_staff = 0;
                a_str_weapons = player getweaponslist();

                foreach ( str_weapon in a_str_weapons )
                {
                    if ( issubstr( str_weapon, "staff" ) && issubstr( str_weapon, "upgraded" ) )
                        has_upgraded_staff = 1;

                    if ( str_weapon == "staff_revive_zm" )
                        has_revive_staff = 1;
                }

                if ( has_upgraded_staff && !has_revive_staff )
                {
                    player setactionslot( 3, "weapon", "staff_revive_zm" );
                    player giveweapon( "staff_revive_zm" );
                }
            }
        }
    }
#/
}

watch_devgui_complete_puzzles()
{
/#
    while ( true )
    {
        if ( getdvar( #"_id_BB20372B" ) == "on" || getdvar( #"_id_BB20372C" ) == "on" )
        {
            flag_set( "air_puzzle_1_complete" );
            flag_set( "ice_puzzle_1_complete" );
            flag_set( "electric_puzzle_1_complete" );
            flag_set( "fire_puzzle_1_complete" );
            flag_set( "chamber_puzzle_cheat" );
            setdvar( "complete_puzzles1", "off" );
            setdvar( "open_chambers", "on" );
        }

        if ( getdvar( #"_id_BB20372C" ) == "on" )
        {
            flag_set( "air_puzzle_2_complete" );
            flag_set( "ice_puzzle_2_complete" );
            flag_set( "electric_puzzle_2_complete" );
            flag_set( "fire_puzzle_2_complete" );
            flag_set( "chamber_puzzle_cheat" );
            flag_set( "staff_air_zm_upgrade_unlocked" );
            flag_set( "staff_water_zm_upgrade_unlocked" );
            flag_set( "staff_fire_zm_upgrade_unlocked" );
            flag_set( "staff_lightning_zm_upgrade_unlocked" );
            setdvar( "complete_puzzles2", "off" );
        }

        wait 0.5;
    }
#/
}

watch_devgui_quadrotor()
{
/#
    while ( getdvar( #"_id_7D075455" ) != "on" )
        wait 0.1;

    players = getplayers();

    foreach ( player in players )
    {
        player set_player_equipment( "equip_dieseldrone_zm" );
        player giveweapon( "equip_dieseldrone_zm" );
        player setweaponammoclip( "equip_dieseldrone_zm", 1 );
        player thread show_equipment_hint( "equip_dieseldrone_zm" );
        player notify( "equip_dieseldrone_zm" + "_given" );
        player set_equipment_invisibility_to_player( "equip_dieseldrone_zm", 1 );
        player setactionslot( 1, "weapon", "equip_dieseldrone_zm" );
    }
#/
}

include_craftable( craftable_struct )
{
/#
    println( "ZM >> include_craftable = " + craftable_struct.name );
#/
    maps\mp\zombies\_zm_craftables::include_zombie_craftable( craftable_struct );
}

is_craftable()
{
    return self maps\mp\zombies\_zm_craftables::is_craftable();
}

is_part_crafted( craftable_name, part_modelname )
{
    return maps\mp\zombies\_zm_craftables::is_part_crafted( craftable_name, part_modelname );
}

wait_for_craftable( craftable_name )
{
    level waittill( craftable_name + "_crafted", player );
    return player;
}

check_solo_status()
{
    if ( getnumexpectedplayers() == 1 && ( !sessionmodeisonlinegame() || !sessionmodeisprivate() ) )
        level.is_forever_solo_game = 1;
    else
        level.is_forever_solo_game = 0;
}

player_slow_movement_speed_monitor()
{
    self endon( "disconnect" );
    n_move_scale = 1.0;
    n_old_move_scale = n_move_scale;

    while ( true )
    {
        is_player_slowed = 0;

        foreach ( area in level.a_e_slow_areas )
        {
            if ( self istouching( area ) )
            {
                self setclientfieldtoplayer( "sndMudSlow", 1 );
                is_player_slowed = 1;

                if ( isdefined( area.script_string ) && area.script_string == "water" )
                    n_move_scale = 0.6;
                else
                    n_move_scale = 0.6;

                break;
            }
        }

        if ( !is_player_slowed )
        {
            self setclientfieldtoplayer( "sndMudSlow", 0 );
            self setclientfieldtoplayer( "mud_overlay", 0 );
            n_move_scale = 1.0;
        }

        if ( n_move_scale != n_old_move_scale )
        {
            self setclientfieldtoplayer( "mud_overlay", 1 );
            self setmovespeedscale( n_move_scale );
            n_old_move_scale = n_move_scale;
        }

        wait 0.1;
    }
}

dug_zombie_spawn_init( animname_set )
{
    if ( !isdefined( animname_set ) )
        animname_set = 0;

    self.targetname = "zombie";
    self.script_noteworthy = undefined;

    if ( !animname_set )
        self.animname = "zombie";

    if ( isdefined( get_gamemode_var( "pre_init_zombie_spawn_func" ) ) )
        self [[ get_gamemode_var( "pre_init_zombie_spawn_func" ) ]]();

    self thread play_ambient_zombie_vocals();
    self.zmb_vocals_attack = "zmb_vocals_zombie_attack";
    self.ignoreall = 1;
    self.ignoreme = 1;
    self.allowdeath = 1;
    self.force_gib = 1;
    self.is_zombie = 1;
    self.has_legs = 1;
    self allowedstances( "stand" );
    self.zombie_damaged_by_bar_knockdown = 0;
    self.gibbed = 0;
    self.head_gibbed = 0;
    self.disablearrivals = 1;
    self.disableexits = 1;
    self.grenadeawareness = 0;
    self.badplaceawareness = 0;
    self.ignoresuppression = 1;
    self.suppressionthreshold = 1;
    self.nododgemove = 1;
    self.dontshootwhilemoving = 1;
    self.pathenemylookahead = 0;
    self.badplaceawareness = 0;
    self.chatinitialized = 0;
    self.a.disablepain = 1;
    self disable_react();

    if ( isdefined( level.zombie_health ) )
    {
        self.maxhealth = level.zombie_health;

        if ( isdefined( level.zombie_respawned_health ) && level.zombie_respawned_health.size > 0 )
        {
            self.health = level.zombie_respawned_health[0];
            arrayremovevalue( level.zombie_respawned_health, level.zombie_respawned_health[0] );
        }
        else
            self.health = level.zombie_health;
    }
    else
    {
        self.maxhealth = level.zombie_vars["zombie_health_start"];
        self.health = self.maxhealth;
    }

    self.freezegun_damage = 0;
    self.dropweapon = 0;
    level thread zombie_death_event( self );
    self init_zombie_run_cycle();
    self thread dug_zombie_think();
    self thread zombie_gib_on_damage();
    self thread zombie_damage_failsafe();
    self thread enemy_death_detection();

    if ( !isdefined( self.no_eye_glow ) || !self.no_eye_glow )
    {
        if ( !( isdefined( self.is_inert ) && self.is_inert ) )
            self thread delayed_zombie_eye_glow();
    }

    self.deathfunction = ::zombie_death_animscript;
    self.flame_damage_time = 0;
    self.meleedamage = 60;
    self.no_powerups = 1;
    self zombie_history( "zombie_spawn_init -> Spawned = " + self.origin );
    self.thundergun_knockdown_func = level.basic_zombie_thundergun_knockdown;
    self.tesla_head_gib_func = ::zombie_tesla_head_gib;
    self.team = level.zombie_team;

    if ( isdefined( get_gamemode_var( "post_init_zombie_spawn_func" ) ) )
        self [[ get_gamemode_var( "post_init_zombie_spawn_func" ) ]]();

    self.zombie_init_done = 1;
    self notify( "zombie_init_done" );
}

dug_zombie_think()
{
    self endon( "death" );
    assert( !self.isdog );
    self.ai_state = "zombie_think";
    find_flesh_struct_string = undefined;
    self waittill( "zombie_custom_think_done", find_flesh_struct_string );
    node = undefined;
    desired_nodes = [];
    self.entrance_nodes = [];

    if ( isdefined( level.max_barrier_search_dist_override ) )
        max_dist = level.max_barrier_search_dist_override;
    else
        max_dist = 500;

    if ( !isdefined( find_flesh_struct_string ) && isdefined( self.target ) && self.target != "" )
    {
        desired_origin = get_desired_origin();
        assert( isdefined( desired_origin ), "Spawner @ " + self.origin + " has a .target but did not find a target" );
        origin = desired_origin;
        node = getclosest( origin, level.exterior_goals );
        self.entrance_nodes[self.entrance_nodes.size] = node;
        self zombie_history( "zombie_think -> #1 entrance (script_forcegoal) origin = " + self.entrance_nodes[0].origin );
    }
    else if ( self should_skip_teardown( find_flesh_struct_string ) )
    {
        self zombie_setup_attack_properties();

        if ( isdefined( self.target ) )
        {
            end_at_node = getnode( self.target, "targetname" );

            if ( isdefined( end_at_node ) )
            {
                self setgoalnode( end_at_node );
                self waittill( "goal" );
            }
        }

        if ( isdefined( self.start_inert ) && self.start_inert )
        {
            self thread maps\mp\zombies\_zm_ai_basic::start_inert( 1 );
            self zombie_complete_emerging_into_playable_area();
        }
        else
        {
            self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
            self thread dug_zombie_entered_playable();
        }

        return;
    }
    else if ( isdefined( find_flesh_struct_string ) )
    {
        assert( isdefined( find_flesh_struct_string ) );

        for ( i = 0; i < level.exterior_goals.size; i++ )
        {
            if ( level.exterior_goals[i].script_string == find_flesh_struct_string )
            {
                node = level.exterior_goals[i];
                break;
            }
        }

        self.entrance_nodes[self.entrance_nodes.size] = node;
        self zombie_history( "zombie_think -> #1 entrance origin = " + node.origin );
        self thread zombie_assure_node();
    }
    else
    {
        origin = self.origin;
        desired_origin = get_desired_origin();

        if ( isdefined( desired_origin ) )
            origin = desired_origin;

        nodes = get_array_of_closest( origin, level.exterior_goals, undefined, 3 );
        desired_nodes[0] = nodes[0];
        prev_dist = distance( self.origin, nodes[0].origin );

        for ( i = 1; i < nodes.size; i++ )
        {
            dist = distance( self.origin, nodes[i].origin );

            if ( dist - prev_dist > max_dist )
                break;

            prev_dist = dist;
            desired_nodes[i] = nodes[i];
        }

        node = desired_nodes[0];

        if ( desired_nodes.size > 1 )
            node = desired_nodes[randomint( desired_nodes.size )];

        self.entrance_nodes = desired_nodes;
        self zombie_history( "zombie_think -> #1 entrance origin = " + node.origin );
        self thread zombie_assure_node();
    }

    assert( isdefined( node ), "Did not find a node!!! [Should not see this!]" );
    level thread draw_line_ent_to_pos( self, node.origin, "goal" );
    self.first_node = node;
    self thread zombie_goto_entrance( node );
}

dug_zombie_entered_playable()
{
    self endon( "death" );

    if ( !isdefined( level.playable_areas ) )
        level.playable_areas = getentarray( "player_volume", "script_noteworthy" );

    while ( true )
    {
        foreach ( area in level.playable_areas )
        {
            if ( self istouching( area ) )
            {
                self dug_zombie_complete_emerging_into_playable_area();
                return;
            }
        }

        wait 1;
    }
}

dug_zombie_complete_emerging_into_playable_area()
{
    self.completed_emerging_into_playable_area = 1;
    self notify( "completed_emerging_into_playable_area" );
    self.no_powerups = 1;
    self thread zombie_free_cam_allowed();
}

dug_zombie_rise( spot )
{
    self endon( "death" );
    self.in_the_ground = 1;
    self.no_eye_glow = 1;
    self.anchor = spawn( "script_origin", self.origin );
    self.anchor.angles = self.angles;
    self linkto( self.anchor );

    if ( !isdefined( spot.angles ) )
        spot.angles = ( 0, 0, 0 );

    anim_org = spot.origin;
    anim_ang = spot.angles;
    self ghost();
    self.anchor moveto( anim_org, 0.05 );
    self.anchor waittill( "movedone" );
    target_org = get_desired_origin();

    if ( isdefined( target_org ) )
    {
        anim_ang = vectortoangles( target_org - self.origin );
        self.anchor rotateto( ( 0, anim_ang[1], 0 ), 0.05 );
        self.anchor waittill( "rotatedone" );
    }

    self unlink();

    if ( isdefined( self.anchor ) )
        self.anchor delete();

    self thread hide_pop();
    level thread zombie_rise_death( self, spot );
    playfx( level._effect["fast_rise"], spot.origin, anglestoforward( spot.angles ), anglestoup( spot.angles ) );
    substate = 0;

    if ( self.zombie_move_speed == "walk" )
        substate = randomint( 2 );
    else if ( self.zombie_move_speed == "run" )
        substate = 2;
    else if ( self.zombie_move_speed == "sprint" )
        substate = 3;

    self orientmode( "face default" );
    self animscripted( self.origin, spot.angles, "zm_dug_rise" );
    self maps\mp\animscripts\zm_shared::donotetracks( "rise_anim", ::handle_rise_notetracks, spot );
    self.no_eye_glow = 0;
    self thread zombie_eye_glow();
    self notify( "rise_anim_finished" );
    spot notify( "stop_zombie_rise_fx" );
    self.in_the_ground = 0;
    self notify( "risen", spot.script_string );
}

move_along_ground_position( v_position, n_time )
{
    v_diff = vectornormalize( v_position - self.origin );
    v_newpos = self.origin + v_diff * 50 + vectorscale( ( 0, 0, 1 ), 100.0 );
    v_ground = groundpos_ignore_water_new( v_newpos );
    self moveto( v_ground, n_time );
}

watch_staff_usage()
{
    self notify( "watch_staff_usage" );
    self endon( "watch_staff_usage" );
    self endon( "disconnect" );

    while ( true )
    {
        self waittill( "weapon_change", weapon );
        has_upgraded_staff = 0;
        has_revive_staff = 0;
        a_str_weapons = self getweaponslist();

        foreach ( str_weapon in a_str_weapons )
        {
            if ( issubstr( str_weapon, "staff" ) && issubstr( str_weapon, "upgraded" ) )
                has_upgraded_staff = 1;

            if ( str_weapon == "staff_revive_zm" )
                has_revive_staff = 1;
        }

        if ( !has_upgraded_staff && has_revive_staff )
            self takeweapon( "staff_revive_zm" );

        if ( has_upgraded_staff )
        {
            while ( issubstr( weapon, "staff" ) && issubstr( weapon, "upgraded" ) )
            {
                self staff_charge_watch();
                weapon = self getcurrentweapon();
            }
        }
    }
}

staff_charge_watch()
{
    self endon( "disconnect" );
    self endon( "player_downed" );
    self endon( "weapon_change" );
    self endon( "weapon_fired" );

    while ( !self attackbuttonpressed() )
        wait 0.05;

    while ( true )
    {
        switch ( self.chargeshotlevel )
        {
            case 2:
                self playrumbleonentity( "reload_small" );
                break;
            case 3:
            case 4:
                self playrumbleonentity( "damage_light" );
                break;
            case 5:
                self playrumbleonentity( "damage_heavy" );
                break;
        }

        wait 0.1;
    }
}

shovel_tutorial_hint()
{
    hud = setting_tutorial_hud();
    hud settext( &"ZM_TOMB_NEED_SHOVEL" );
    wait 3;
    hud destroy();
}

door_record_hint()
{
    hud = setting_tutorial_hud();
    hud settext( &"ZM_TOMB_RECORD_UNAVAILABLE" );
    wait 3;
    hud destroy();
}

swap_staff_hint()
{
    level notify( "staff_Hint" );
    hud = setting_tutorial_hud();
    hud settext( &"ZM_TOMB_ONE_STAFF_ONLY" );
    level waittill_any_or_timeout( 3.0, "staff_hint" );
    hud destroy();
}

door_gramophone_elsewhere_hint()
{
    hud = setting_tutorial_hud();
    hud settext( &"ZM_TOMB_GRAMOPHONE_ELSEWHERE" );
    wait 3;
    hud destroy();
}

puzzle_debug_position( string_to_show, color, origin )
{
/#
    self endon( "death" );
    self endon( "stop_debug_position" );

    if ( !isdefined( string_to_show ) )
        string_to_show = "+";

    if ( !isdefined( color ) )
        color = vectorscale( ( 1, 1, 1 ), 255.0 );

    while ( true )
    {
        if ( isdefined( origin ) )
            where_to_draw = origin;
        else
            where_to_draw = self.origin;

        print3d( self.origin, string_to_show, color, 1 );
        wait 0.1;
    }
#/
}

placeholder_puzzle_delete_ent( str_flag_name )
{
    self endon( "death" );
    flag_wait( str_flag_name );
    self delete();
}

placeholder_puzzle_spin_model()
{
    self endon( "death" );

    while ( true )
    {
        self rotateyaw( 360, 10, 0, 0 );
        wait 9.9;
    }
}

placeholder_puzzle( str_struct_name, str_puzzle_name, str_flag_name )
{
    level endon( str_flag_name );
    trigger_pos = getstruct( str_struct_name, "script_noteworthy" );
    t_puzzle = spawn( "trigger_radius_use", trigger_pos.origin, 0, 100, 150 );
    t_puzzle triggerignoreteam();
    t_puzzle sethintstring( "TEMP: Press X to Complete " + str_puzzle_name );
    t_puzzle setcursorhint( "HINT_NOICON" );
    e_model = spawn( "script_model", t_puzzle.origin );
    e_model thread placeholder_puzzle_spin_model();
    e_model setmodel( "semtex_bag" );
    playfxontag( level._effect["air_glow"], e_model, "tag_origin" );
    t_puzzle thread placeholder_puzzle_delete_ent( str_flag_name );
    e_model thread placeholder_puzzle_delete_ent( str_flag_name );
    t_puzzle waittill( "trigger" );
    t_puzzle delete();
    e_model delete();

    if ( isdefined( str_flag_name ) )
        flag_set( str_flag_name );
}

setting_tutorial_hud()
{
    client_hint = newclienthudelem( self );
    client_hint.alignx = "center";
    client_hint.aligny = "middle";
    client_hint.horzalign = "center";
    client_hint.vertalign = "bottom";
    client_hint.y = -120;
    client_hint.foreground = 1;
    client_hint.font = "default";
    client_hint.fontscale = 1.5;
    client_hint.alpha = 1;
    client_hint.color = ( 1, 1, 1 );
    return client_hint;
}

zombie_gib_all()
{
    if ( !isdefined( self ) )
        return;

    a_gib_ref = [];
    a_gib_ref[0] = level._zombie_gib_piece_index_all;
    self gib( "normal", a_gib_ref );
    self ghost();
    wait 0.4;

    if ( isdefined( self ) )
        self self_delete();
}

link_platform_nodes( nd_1, nd_2 )
{
    if ( !nodesarelinked( nd_1, nd_2 ) )
        link_nodes( nd_1, nd_2 );

    if ( !nodesarelinked( nd_2, nd_1 ) )
        link_nodes( nd_2, nd_1 );
}

unlink_platform_nodes( nd_1, nd_2 )
{
    if ( nodesarelinked( nd_1, nd_2 ) )
        unlink_nodes( nd_1, nd_2 );

    if ( nodesarelinked( nd_2, nd_1 ) )
        unlink_nodes( nd_2, nd_1 );
}

init_weather_manager()
{
    level.weather_snow = 0;
    level.weather_rain = 0;
    level.weather_fog = 0;
    level thread weather_manager();
    onplayerconnect_callback( ::set_weather_to_player );
}

weather_manager()
{
    while ( true )
    {
        level waittill( "end_of_round" );
        n_round_weather = randomint( 1000 );

        if ( n_round_weather <= 200 )
        {
            level.weather_snow = 0;
            level.weather_rain = 0;
        }
        else if ( n_round_weather > 200 && n_round_weather < 600 )
        {
            level.weather_snow = 0;
            level.weather_rain = randomintrange( 1, 5 );
        }
        else
        {
            level.weather_snow = randomintrange( 1, 5 );
            level.weather_rain = 0;
        }

        if ( cointoss() )
            level.weather_fog = 1;
        else
            level.weather_fog = 0;

        foreach ( player in getplayers() )
        {
            if ( is_player_valid( player, 0, 1 ) )
                player set_weather_to_player();
        }
    }
}

set_weather_to_player()
{
    self setclientfieldtoplayer( "player_rain_level", level.weather_rain );
    self setclientfieldtoplayer( "player_snow_level", level.weather_snow );
    self setclientfieldtoplayer( "player_fog_level", level.weather_fog );
}

play_puzzle_stinger_on_all_players()
{
    players = getplayers();

    foreach ( player in players )
        player playsound( "evt_souls_full" );
}

puzzle_orb_move( v_to_pos )
{
    dist = distance( self.origin, v_to_pos );

    if ( dist == 0.0 )
        return;

    movetime = dist / 300;
    self moveto( v_to_pos, movetime, 0, 0 );
    self waittill( "movedone" );
}

puzzle_orb_follow_path( s_start )
{
    s_next_pos = s_start;

    while ( isdefined( s_next_pos ) )
    {
        self puzzle_orb_move( s_next_pos.origin );

        if ( isdefined( s_next_pos.target ) )
            s_next_pos = getstruct( s_next_pos.target, "targetname" );
        else
            s_next_pos = undefined;
    }
}

puzzle_orb_follow_path_reverse( s_start, v_start_offset )
{
    a_path = [];
    s_next = s_start;

    while ( isdefined( s_next ) )
    {
        a_path[a_path.size] = s_next;

        if ( isdefined( s_next.target ) )
            s_next = getstruct( s_next.target, "targetname" );
        else
            s_next = undefined;
    }

    if ( isdefined( v_start_offset ) )
    {
        v_start = a_path[a_path.size - 1].origin + v_start_offset;
        self puzzle_orb_move( v_start );
    }

    for ( i = a_path.size - 1; i >= 0; i-- )
        self puzzle_orb_move( a_path[i].origin );
}

puzzle_orb_pillar_show( do_show )
{
    if ( !isdefined( do_show ) )
        do_show = 1;

    s_pillar = getstruct( "crypt_pillar", "targetname" );

    if ( do_show )
    {
        if ( !isdefined( s_pillar.e_model ) )
        {
            s_pillar.e_model = spawn( "script_model", s_pillar.origin );
            s_pillar.e_model setmodel( s_pillar.model );
            s_pillar.e_model setclientfield( "sky_pillar", 1 );
            wait 4.0;
        }
    }
    else
    {
        if ( isdefined( s_pillar.e_model ) )
        {
            s_pillar.e_model setclientfield( "sky_pillar", 0 );
            wait 4.0;
        }

        if ( isdefined( s_pillar.e_model ) )
        {
            s_pillar.e_model setclientfield( "sky_pillar", 2 );
            wait_network_frame();
            s_pillar.e_model delete();
        }
    }
}

puzzle_orb_chamber_to_crypt( str_start_point, e_gem_pos )
{
    a_puzzle_flags = strtok( e_gem_pos.script_flag, " " );
    assert( a_puzzle_flags.size == 2 );

    foreach ( str_flag in a_puzzle_flags )
        assert( level flag_exists( str_flag ) );

    flag_wait( a_puzzle_flags[0] );
    s_start = getstruct( str_start_point, "targetname" );
    e_model = spawn( "script_model", s_start.origin );
    e_model setmodel( s_start.model );
    e_model playsound( "evt_souls_full" );
    e_model playloopsound( "evt_souls_full_loop", 0.1 );
    str_zone = maps\mp\zombies\_zm_zonemgr::get_zone_from_position( s_start.origin, 1 );
    n_near_dist_sq = 32400;
    b_player_near = 0;

    while ( !b_player_near && level.zones[str_zone].is_occupied && !flag( "chamber_puzzle_cheat" ) )
    {
        players = getplayers();

        foreach ( player in players )
        {
            dist_sq = distancesquared( player.origin, s_start.origin );

            if ( dist_sq < n_near_dist_sq )
                b_player_near = 1;
        }

        wait 0.5;
    }

    playfxontag( level._effect["puzzle_orb_trail"], e_model, "tag_origin" );
    s_next_pos = getstruct( s_start.target, "targetname" );
    e_model puzzle_orb_follow_path( s_next_pos );
    v_sky_pos = e_model.origin;
    v_sky_pos = ( v_sky_pos[0], v_sky_pos[1], v_sky_pos[2] + 3000 );
    e_model puzzle_orb_move( v_sky_pos );
    e_model ghost();
    s_descend_start = getstruct( "orb_crypt_descent_path", "targetname" );
    v_pos_above_gem = ( s_descend_start.origin[0], s_descend_start.origin[1], e_model.origin[2] );
    e_model moveto( v_pos_above_gem, 0.05, 0, 0 );
    e_model waittill( "movedone" );
    flag_wait( a_puzzle_flags[1] );
    e_model show();
    puzzle_orb_pillar_show( 1 );
    e_model puzzle_orb_follow_path( s_descend_start );
    flag_set( "disc_rotation_active" );
    e_model puzzle_orb_move( e_gem_pos.origin );
    e_model_nofx = spawn( "script_model", e_model.origin );
    e_model_nofx setmodel( e_model.model );
    e_model delete();
    flag_clear( "disc_rotation_active" );
    puzzle_orb_pillar_show( 0 );
    return e_model_nofx;
}

capture_zombie_spawn_init( animname_set )
{
    if ( !isdefined( animname_set ) )
        animname_set = 0;

    self.targetname = "capture_zombie_ai";

    if ( !animname_set )
        self.animname = "zombie";

    if ( isdefined( get_gamemode_var( "pre_init_zombie_spawn_func" ) ) )
        self [[ get_gamemode_var( "pre_init_zombie_spawn_func" ) ]]();

    self thread play_ambient_zombie_vocals();
    self.zmb_vocals_attack = "zmb_vocals_zombie_attack";
    self.no_damage_points = 1;
    self.deathpoints_already_given = 1;
    self.ignore_enemy_count = 1;
    self.ignoreall = 1;
    self.ignoreme = 1;
    self.allowdeath = 1;
    self.force_gib = 1;
    self.is_zombie = 1;
    self.has_legs = 1;
    self allowedstances( "stand" );
    self.zombie_damaged_by_bar_knockdown = 0;
    self.gibbed = 0;
    self.head_gibbed = 0;
    self.disablearrivals = 1;
    self.disableexits = 1;
    self.grenadeawareness = 0;
    self.badplaceawareness = 0;
    self.ignoresuppression = 1;
    self.suppressionthreshold = 1;
    self.nododgemove = 1;
    self.dontshootwhilemoving = 1;
    self.pathenemylookahead = 0;
    self.badplaceawareness = 0;
    self.chatinitialized = 0;
    self.a.disablepain = 1;
    self disable_react();

    if ( isdefined( level.zombie_health ) )
    {
        self.maxhealth = level.zombie_health;

        if ( isdefined( level.zombie_respawned_health ) && level.zombie_respawned_health.size > 0 )
        {
            self.health = level.zombie_respawned_health[0];
            arrayremovevalue( level.zombie_respawned_health, level.zombie_respawned_health[0] );
        }
        else
            self.health = level.zombie_health;
    }
    else
    {
        self.maxhealth = level.zombie_vars["zombie_health_start"];
        self.health = self.maxhealth;
    }

    self.freezegun_damage = 0;
    self.dropweapon = 0;
    level thread zombie_death_event( self );
    self init_zombie_run_cycle();
    self thread dug_zombie_think();
    self thread zombie_gib_on_damage();
    self thread zombie_damage_failsafe();
    self thread enemy_death_detection();

    if ( !isdefined( self.no_eye_glow ) || !self.no_eye_glow )
    {
        if ( !( isdefined( self.is_inert ) && self.is_inert ) )
            self thread delayed_zombie_eye_glow();
    }

    self.deathfunction = ::zombie_death_animscript;
    self.flame_damage_time = 0;
    self.meleedamage = 60;
    self.no_powerups = 1;
    self zombie_history( "zombie_spawn_init -> Spawned = " + self.origin );
    self.thundergun_knockdown_func = level.basic_zombie_thundergun_knockdown;
    self.tesla_head_gib_func = ::zombie_tesla_head_gib;
    self.team = level.zombie_team;

    if ( isdefined( get_gamemode_var( "post_init_zombie_spawn_func" ) ) )
        self [[ get_gamemode_var( "post_init_zombie_spawn_func" ) ]]();

    self.zombie_init_done = 1;
    self notify( "zombie_init_done" );
}
