// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include common_scripts\utility;
#include maps\mp\_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_sidequests;
#include maps\mp\zm_tomb_utility;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_unitrigger;

main()
{
    flag_init( "electric_puzzle_1_complete" );
    flag_init( "electric_puzzle_2_complete" );
    flag_init( "electric_upgrade_available" );
    electric_puzzle_1_init();
    electric_puzzle_2_init();
    flag_wait( "door_electric_opened" );
    level thread electric_puzzle_1_run();
    flag_wait( "electric_puzzle_1_complete" );
    level thread electric_puzzle_2_run();
    flag_wait( "electric_puzzle_2_complete" );
    level thread electric_puzzle_2_cleanup();
    flag_wait( "staff_lightning_zm_upgrade_unlocked" );
    level thread enable_moving_platforms_bolt();
}

enable_moving_platforms_bolt()
{
    flag_wait( "start_zombie_round_logic" );
    level thread bolt_chamber_platform( "left" );
    level thread bolt_chamber_platform( "right" );
}

bolt_chamber_platform( str_side )
{
    s_top_pos = getstruct( "s_" + str_side + "_top_pos", "targetname" );
    s_bottom_pos = getstruct( "s_" + str_side + "_bottom_pos", "targetname" );
    m_platform = getent( "bm_" + str_side + "_platform", "targetname" );
    m_platform setmovingplatformenabled( 1 );

    while ( true )
    {
        m_platform disconnectpaths();
        wait 10;
        m_platform moveto( s_top_pos.origin, 5 );
        m_platform thread disconnect_platform_paths();
        m_platform waittill( "movedone" );
        m_platform disconnectpaths();
        wait 10;
        m_platform moveto( s_bottom_pos.origin, 5 );
        m_platform thread disconnect_platform_paths();
        m_platform waittill( "movedone" );
        m_platform disconnectpaths();
    }
}

disconnect_platform_paths()
{
    self endon( "movedone" );

    while ( true )
    {
        self disconnectpaths();
        wait 0.15;
    }
}

electric_puzzle_1_init()
{
    flag_init( "piano_chord_ringing" );
}

electric_puzzle_1_run()
{
    a_piano_keys = getentarray( "piano_key", "script_noteworthy" );
    level.a_piano_keys_playing = [];
    array_thread( a_piano_keys, ::piano_key_run );
    level thread piano_run_chords();
}

piano_keys_stop()
{
    level notify( "piano_keys_stop" );
    level.a_piano_keys_playing = [];
}

show_chord_debug( a_chord_notes )
{
/#
    if ( !isdefined( a_chord_notes ) )
        a_chord_notes = [];

    a_piano_keys = getentarray( "piano_key", "script_noteworthy" );

    foreach ( e_key in a_piano_keys )
    {
        e_key notify( "stop_debug_position" );

        foreach ( note in a_chord_notes )
        {
            if ( note == e_key.script_string )
            {
                e_key thread puzzle_debug_position();
                break;
            }
        }
    }
#/
}

piano_run_chords()
{
    a_chords = getstructarray( "piano_chord", "targetname" );

    foreach ( s_chord in a_chords )
    {
        s_chord.notes = strtok( s_chord.script_string, " " );
        assert( s_chord.notes.size == 3 );
    }

    a_chord_order = array( "a_minor", "e_minor", "d_minor" );

    foreach ( chord_name in a_chord_order )
    {
        s_chord = getstruct( "piano_chord_" + chord_name, "script_noteworthy" );
/#
        show_chord_debug( s_chord.notes );
#/
        chord_solved = 0;

        while ( !chord_solved )
        {
            level waittill( "piano_key_played" );

            if ( level.a_piano_keys_playing.size == 3 )
            {
                correct_notes_playing = 0;

                foreach ( played_note in level.a_piano_keys_playing )
                {
                    foreach ( requested_note in s_chord.notes )
                    {
                        if ( requested_note == played_note )
                            correct_notes_playing++;
                    }
                }

                if ( correct_notes_playing == 3 )
                    chord_solved = 1;
            }
        }

        flag_set( "piano_chord_ringing" );
        wait 4.0;
        flag_clear( "piano_chord_ringing" );
        piano_keys_stop();
/#
        show_chord_debug();
#/
    }

    flag_set( "electric_puzzle_1_complete" );
}

piano_key_run()
{
    s_glow_pos = getstruct( self.target, "targetname" );
    piano_key_note = self.script_string;
    self setcandamage( 1 );

    while ( true )
    {
        self waittill( "damage", amount, inflictor, direction, point, type, tagname, modelname, partname, weaponname, idflags );
        self.health = 9999;

        if ( weaponname == "staff_lightning_zm" && !flag( "piano_chord_ringing" ) )
        {
            if ( level.a_piano_keys_playing.size >= 3 )
                piano_keys_stop();

            self.e_fx = spawn( "script_model", s_glow_pos.origin );
            self.e_fx.angles = s_glow_pos.angles;
            self.e_fx setmodel( "tag_origin" );
            playfxontag( level._effect["elec_piano_glow"], self.e_fx, "tag_origin" );
            level.a_piano_keys_playing[level.a_piano_keys_playing.size] = piano_key_note;
            level notify( "piano_key_played", self, piano_key_note );
            level waittill( "piano_keys_stop" );
            self.e_fx delete();
        }
    }
}

electric_puzzle_2_init()
{
    level.electric_relays = [];
    level.electric_relays["bunker"] = spawnstruct();
    level.electric_relays["tank_platform"] = spawnstruct();
    level.electric_relays["start"] = spawnstruct();
    level.electric_relays["elec"] = spawnstruct();
    level.electric_relays["ruins"] = spawnstruct();
    level.electric_relays["air"] = spawnstruct();
    level.electric_relays["ice"] = spawnstruct();
    level.electric_relays["village"] = spawnstruct();

    foreach ( s_relay in level.electric_relays )
        s_relay.connections = [];

    level.electric_relays["tank_platform"].connections[0] = "ruins";
    level.electric_relays["start"].connections[1] = "tank_platform";
    level.electric_relays["elec"].connections[0] = "ice";
    level.electric_relays["ruins"].connections[2] = "chamber";
    level.electric_relays["air"].connections[2] = "start";
    level.electric_relays["ice"].connections[3] = "village";
    level.electric_relays["village"].connections[2] = "air";
    level.electric_relays["bunker"].position = 2;
    level.electric_relays["tank_platform"].position = 1;
    level.electric_relays["start"].position = 3;
    level.electric_relays["elec"].position = 1;
    level.electric_relays["ruins"].position = 3;
    level.electric_relays["air"].position = 0;
    level.electric_relays["ice"].position = 1;
    level.electric_relays["village"].position = 1;
    a_switches = getentarray( "puzzle_relay_switch", "script_noteworthy" );

    foreach ( e_switch in a_switches )
        level.electric_relays[e_switch.script_string].e_switch = e_switch;

    array_thread( level.electric_relays, ::relay_switch_run );
}

electric_puzzle_2_run()
{
    update_relays();
}

electric_puzzle_2_cleanup()
{
    foreach ( s_relay in level.electric_relays )
    {
        if ( isdefined( s_relay.trigger_stub ) )
            maps\mp\zombies\_zm_unitrigger::register_unitrigger( s_relay.trigger_stub );

        if ( isdefined( s_relay.e_fx ) )
            s_relay.e_fx delete();
    }
}

kill_all_relay_power()
{
    foreach ( s_relay in level.electric_relays )
    {
        s_relay.receiving_power = 0;
        s_relay.sending_power = 0;
    }
}

relay_give_power( s_relay )
{
    if ( !flag( "electric_puzzle_1_complete" ) )
        return;

    if ( !isdefined( s_relay ) )
    {
        kill_all_relay_power();
        s_relay = level.electric_relays["elec"];
    }

    s_relay.receiving_power = 1;
    str_target_relay = s_relay.connections[s_relay.position];

    if ( isdefined( str_target_relay ) )
    {
        if ( str_target_relay == "chamber" )
        {
            flag_set( "electric_puzzle_2_complete" );
            level thread play_puzzle_stinger_on_all_players();
        }
        else
        {
            s_relay.sending_power = 1;
            s_target_relay = level.electric_relays[str_target_relay];
            relay_give_power( s_target_relay );
        }
    }
}

update_relay_fx_and_sound()
{
    if ( !flag( "electric_puzzle_1_complete" ) )
        return;

    foreach ( s_relay in level.electric_relays )
    {
        if ( s_relay.sending_power )
        {
            if ( isdefined( s_relay.e_fx ) )
                s_relay.e_fx delete();

            continue;
        }

        if ( s_relay.receiving_power )
        {
            if ( !isdefined( s_relay.e_fx ) )
            {
                v_offset = anglestoright( s_relay.e_switch.angles ) * 1.0;
                s_relay.e_fx = spawn( "script_model", s_relay.e_switch.origin + v_offset );
                s_relay.e_fx.angles = s_relay.e_switch.angles + vectorscale( ( 0, 0, -1 ), 90.0 );
                s_relay.e_fx setmodel( "tag_origin" );
                playfxontag( level._effect["elec_switch_spark"], s_relay.e_fx, "tag_origin" );
            }

            continue;
        }

        if ( isdefined( s_relay.e_fx ) )
            s_relay.e_fx delete();
    }
}

update_relay_rotation()
{
    self.e_switch rotateto( ( self.position * 90, self.e_switch.angles[1], self.e_switch.angles[2] ), 0.1, 0, 0 );
    self.e_switch waittill( "rotatedone" );
}

update_relays()
{
    relay_give_power();
    update_relay_fx_and_sound();
}

relay_switch_run()
{
    assert( isdefined( self.e_switch ) );
    self.trigger_stub = spawnstruct();
    self.trigger_stub.origin = self.e_switch.origin;
    self.trigger_stub.radius = 150;
    self.trigger_stub.cursor_hint = "HINT_NOICON";
    self.trigger_stub.hint_string = "";
    self.trigger_stub.script_unitrigger_type = "unitrigger_radius_use";
    self.trigger_stub.require_look_at = 1;
    maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.trigger_stub, ::relay_unitrigger_think );
    level endon( "electric_puzzle_2_complete" );
    self thread update_relay_rotation();

    while ( true )
    {
        self.trigger_stub waittill( "trigger" );
        self.position = ( self.position + 1 ) % 4;
        self update_relay_rotation();
        update_relays();
    }
}

relay_unitrigger_think()
{
    self endon( "kill_trigger" );

    while ( true )
    {
        self waittill( "trigger", player );
        self.stub notify( "trigger", player );
    }
}
