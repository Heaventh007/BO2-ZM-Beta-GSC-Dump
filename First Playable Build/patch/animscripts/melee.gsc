// T6 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool
#include maps\_utility;
#include animscripts\utility;
#include animscripts\setposemovement;
#include animscripts\combat_utility;
#include animscripts\debug;
#include animscripts\anims;
#include common_scripts\utility;
#include animscripts\face;
#include animscripts\shared;
#include animscripts\run;

melee_tryexecuting()
{
    if ( !isdefined( self.enemy ) )
        return false;

    if ( is_true( self.dontmelee ) || is_true( self.enemy.dontmeleeme ) )
        return false;

    if ( self.enemy isvehicle() || isai( self.enemy ) && self.enemy.isbigdog )
        return false;

    if ( !melee_acquiremutex( self.enemy ) )
        return false;

    melee_resetaction();

    if ( !melee_chooseaction() )
    {
        melee_releasemutex( self.enemy );
        return false;
    }

    self animcustom( ::melee_mainloop, ::melee_endscript );
}

melee_resetaction()
{
    assert( isdefined( self.melee ) );
    self.melee.target = self.enemy;
    self.melee.initiated = 0;
    self.melee.inprogress = 0;
}

melee_chooseaction()
{
    if ( !melee_isvalid() )
        return false;

    self.melee.initiated = 1;

    if ( melee_aivsai_chooseaction() )
    {
        self.melee.func = ::melee_aivsai_main;
        return true;
    }

    if ( melee_standard_chooseaction() )
    {
        if ( isdefined( self.specialmelee_standard ) )
            self.melee.func = self.specialmelee_standard;
        else
            self.melee.func = ::melee_standard_main;

        return true;
    }

    self.melee.func = undefined;
    self.nextmeleechecktime = gettime() + 150;
    self.nextmeleechecktarget = self.melee.target;
    return false;
}

melee_updateandvalidatestartpos()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.startpos ) );
    assert( isdefined( self.melee.target ) );
    ignoreactors = 1;
    distfromtarget2d = distance2d( self.melee.startpos, self.melee.target.origin );

    if ( distfromtarget2d < 32 )
    {
        dirtostartpos2d = vectornormalize( ( self.melee.startpos[0] - self.melee.target.origin[0], self.melee.startpos[1] - self.melee.target.origin[1], 0 ) );

        if ( distfromtarget2d <= 31.9 )
            return false;

        self.melee.startpos = self.melee.startpos + dirtostartpos2d * ( 32 - distfromtarget2d );
        assert( distance2d( self.melee.startpos, self.melee.target.origin ) >= 31.9, "Invalid distance to target: " + distance2d( self.melee.startpos, self.melee.target.origin ) + ", should be more than " + 31.9 );
        ignoreactors = 0;
    }

    floorpos = self getdroptofloorposition( self.melee.startpos );

    if ( !isdefined( floorpos ) )
        return false;

    if ( abs( self.melee.startpos[2] - floorpos[2] ) > 51.2 )
        return false;

    if ( abs( self.origin[2] - floorpos[2] ) > 51.2 )
        return false;

    self.melee.startpos = floorpos;
    assert( distance2d( self.melee.startpos, self.melee.target.origin ) >= 31.9, "Invalid distance to target: " + distance2d( self.melee.startpos, self.melee.target.origin ) + ", should be more than " + 31.9 );

    if ( !self maymovetopoint( self.melee.startpos, 1 ) )
        return false;

    if ( isdefined( self.melee.starttotargetcornerangles ) )
    {
        targettostartpos = self.melee.startpos - self.melee.target.origin;
        cornerdir = anglestoforward( self.melee.starttotargetcornerangles );
        cornerdirlen = vectordot( cornerdir, targettostartpos );
        maymovetargetorigin = self.melee.startpos - cornerdir * cornerdirlen;
        cornertotarget = self.melee.target.origin - maymovetargetorigin;
        cornertotargetlen = distance2d( self.melee.target.origin, maymovetargetorigin );

        if ( cornertotargetlen < 32 )
            maymovetargetorigin = maymovetargetorigin - cornertotarget * ( ( 32 - cornertotargetlen ) / 32 );
    }
    else
    {
        dirtostartpos2d = vectornormalize( ( self.melee.startpos[0] - self.melee.target.origin[0], self.melee.startpos[1] - self.melee.target.origin[1], 0 ) );
        maymovetargetorigin = self.melee.target.origin + dirtostartpos2d * 32;
    }

    assert( isdefined( maymovetargetorigin ) );

    if ( !self maymovefrompointtopoint( self.melee.startpos, maymovetargetorigin ) )
        return false;

    return true;
}

melee_isvalid()
{
    if ( !isdefined( self.melee.target ) )
        return false;

    target = self.melee.target;

    if ( isdefined( target.dontmelee ) && target.dontmelee )
        return false;

    enemydistancesq = distancesquared( self.origin, target.origin );

    if ( isdefined( self.meleechargedistsq ) )
        chargedistsq = self.meleechargedistsq;
    else if ( isplayer( target ) )
        chargedistsq = 40000;
    else
        chargedistsq = 25600;

    if ( !self.melee.initiated && enemydistancesq > chargedistsq )
        return false;

    if ( !isalive( self ) )
        return false;

    if ( isdefined( self.a.nofirstframemelee ) && self.a.scriptstarttime >= gettime() + 50 )
        return false;

    if ( !isplayer( target ) )
    {
        if ( isdefined( self.nextmeleechecktime ) && isdefined( self.nextmeleechecktarget ) && gettime() < self.nextmeleechecktime && self.nextmeleechecktarget == target )
            return false;
    }

    if ( self.a.pose == "back" || self.a.pose == "prone" )
        return false;

    if ( isdefined( self.grenade ) )
        return false;

    if ( !isalive( target ) )
        return false;

    if ( isdefined( target.dontattackme ) || isdefined( target.ignoreme ) && target.ignoreme )
        return false;

    if ( !isai( target ) && !isplayer( target ) )
        return false;

    if ( isai( target ) )
    {
        if ( target isinscriptedstate() )
            return false;

        if ( is_true( target.doinglongdeath ) || target.delayeddeath )
            return false;
    }

    if ( isplayer( target ) )
        enemypose = target getstance();
    else
        enemypose = target.a.pose;

    if ( enemypose != "stand" && enemypose != "crouch" )
        return false;

    if ( isdefined( self.magic_bullet_shield ) && isdefined( target.magic_bullet_shield ) )
        return false;

    if ( isdefined( target.grenade ) )
        return false;

    if ( self.melee.inprogress )
        yawthreshold = 110;
    else
        yawthreshold = 60;

    yawtoenemy = angleclamp180( self.angles[1] - vectortoangles( target.origin - self.origin )[1] );

    if ( abs( yawtoenemy ) > yawthreshold )
        return false;

    if ( enemydistancesq <= 4096 )
        return true;

    if ( self.melee.inprogress )
        return false;

    if ( !isplayer( target ) )
    {
        if ( isdefined( self.nextmeleechargetime ) && isdefined( self.nextmeleechargetarget ) && gettime() < self.nextmeleechargetime && self.nextmeleechargetarget == target )
            return false;
    }

    return true;
}

melee_startmovement()
{
    self.melee.playingmovementanim = 1;
    self.a.movement = "run";
}

#using_animtree("generic_human");

melee_stopmovement()
{
    self clearanim( %body, 0.2 );
    self.melee.playingmovementanim = undefined;
    self.a.movement = "stop";
    self orientmode( "face default" );
}

melee_mainloop()
{
    self endon( "killanimscript" );
    self endon( "end_melee" );
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.func ) );

    while ( true )
    {
        prevfunc = self.melee.func;
        [[ self.melee.func ]]();

        if ( !isdefined( self.melee.func ) || prevfunc == self.melee.func )
            break;
    }
}

melee_standard_delaystandardcharge( target )
{
    if ( !isdefined( target ) )
        return;

    self.nextmeleestandardchargetime = gettime() + 2500;
    self.nextmeleestandardchargetarget = target;
}

melee_standard_checktimeconstraints()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.target ) );
    targetdistsq = distancesquared( self.melee.target.origin, self.origin );

    if ( targetdistsq > 4096 && isdefined( self.nextmeleestandardchargetime ) && isdefined( self.nextmeleestandardchargetarget ) && gettime() < self.nextmeleestandardchargetime && self.nextmeleestandardchargetarget == self.melee.target )
        return false;

    return true;
}

melee_standard_chooseaction()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.target ) );

    if ( isdefined( self.melee.target.magic_bullet_shield ) )
        return 0;

    if ( !melee_standard_checktimeconstraints() )
        return 0;

    if ( isdefined( self.melee.target.specialmeleechooseaction ) )
        return 0;

    return melee_standard_updateandvalidatetarget();
}

melee_standard_resetgiveuptime()
{
    if ( isdefined( self.meleechargedistsq ) )
        chargedistsq = self.meleechargedistsq;
    else if ( isplayer( self.melee.target ) )
        chargedistsq = 40000;
    else
        chargedistsq = 25600;

    if ( distancesquared( self.origin, self.melee.target.origin ) > chargedistsq )
        self.melee.giveuptime = gettime() + 3000;
    else
        self.melee.giveuptime = gettime() + 1000;
}

melee_standard_main()
{
    self animmode( "zonly_physics" );
    melee_standard_resetgiveuptime();

    while ( true )
    {
        if ( !isdefined( self.melee.target ) )
            break;

        melee_notify_wrapper();

        if ( self.animtype == "default" && animarrayanyexist( "melee_2", "combat" ) && self weaponanims() == "rifle" )
            self.melee.meleeanimvarientindex = randomint( 2 );
        else
            self.melee.meleeanimvarientindex = 0;

        if ( !melee_standard_getinposition() )
        {
            self.nextmeleechargetime = gettime() + 1500;
            self.nextmeleechargetarget = self.melee.target;
            break;
        }

        assert( self.a.pose == "stand" || self.a.pose == "crouch" );
        self orientmode( "face point", self.melee.target.origin );
        self setflaggedanimknoballrestart( "meleeanim", animarray( "melee_" + self.melee.meleeanimvarientindex, "combat" ), %body, 1, 0.2, self.moveplaybackrate );
        self.melee.inprogress = 1;

        if ( !melee_standard_playattackloop() )
        {
            melee_standard_delaystandardcharge( self.melee.target );
            break;
        }
    }

    self animmode( "none" );
}

melee_standard_playattackloop()
{
    while ( true )
    {
        self waittill( "meleeanim", note );

        if ( note == "end" )
            return true;

        if ( note == "stop" )
        {
            if ( !melee_chooseaction() )
                return false;

            assert( isdefined( self.melee.func ) );

            if ( self.melee.func != ::melee_standard_main )
                return true;
        }

        if ( note == "fire" )
        {
            if ( isdefined( self.melee.target ) )
            {
                self animscripts\face::saygenericdialogue( "swing" );
                oldhealth = self.melee.target.health;
                self melee();

                if ( isdefined( self.melee.target ) && self.melee.target.health < oldhealth )
                {
                    if ( isplayer( self.melee.target ) )
                        self.melee.target playsoundtoplayer( "wpn_melee_hit_plr", self.melee.target );

                    melee_standard_resetgiveuptime();
                }
            }
        }
    }
}

melee_standard_updateandvalidatetarget()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( !isdefined( self.melee.target ) )
        return 0;

    if ( !melee_isvalid() )
        return 0;

    dirtotarget = vectornormalize( self.melee.target.origin - self.origin );
    self.melee.startpos = self.melee.target.origin - 40.0 * dirtotarget;
    return melee_updateandvalidatestartpos();
}

distance2dsquared( a, b )
{
    diff = ( a[0] - b[0], a[1] - b[1], 0 );
    return lengthsquared( diff );
}

melee_standard_getinposition()
{
    if ( !melee_standard_updateandvalidatetarget() )
        return false;

    enemydistancesq = distance2dsquared( self.origin, self.melee.target.origin );
    self.a.pose = "stand";

    if ( enemydistancesq <= 4096 )
    {
        self.a.movement = "stop";
        self setflaggedanimknoball( "readyanim", animarray( "stand_2_melee_" + self.melee.meleeanimvarientindex, "combat" ), %body, 1, 0.3, self.moveplaybackrate );
        self animscripts\shared::donotetracks( "readyanim" );
        return true;
    }

    self melee_playchargesound();
    prevenemypos = self.melee.target.origin;
    raisegunanimtraveldist = length( getmovedelta( animarray( "run_2_melee_" + self.melee.meleeanimvarientindex, "combat" ), 0, 1 ) );
    shouldraisegundist = 48.0 + 32 + raisegunanimtraveldist;
    shouldraisegundistsq = shouldraisegundist * shouldraisegundist;
    shouldmeleedist = 64 + 32;
    shouldmeleedistsq = shouldmeleedist * shouldmeleedist;
    raisegunfullduration = getanimlength( animarray( "run_2_melee_" + self.melee.meleeanimvarientindex, "combat" ) ) * 1000 / self.moveplaybackrate;
    raisegunfinishduration = raisegunfullduration - 100;
    raisegunpredictduration = raisegunfullduration - 200;
    raisegunstarttime = 0;
    predictedenemydistsqafterraisegun = undefined;
    runanim = animscripts\run::getrunanim();

    if ( isplayer( self.melee.target ) && isdefined( self.enemy ) && self.melee.target == self.enemy )
        self orientmode( "face enemy" );
    else
        self orientmode( "face point", self.melee.target.origin );

    self setflaggedanimknoball( "chargeanim", runanim, %body, 1, 0.3, self.moveplaybackrate );
    raisinggun = 0;

    while ( true )
    {
        time = gettime();
        willbewithinrangewhengunisraised = isdefined( predictedenemydistsqafterraisegun ) && predictedenemydistsqafterraisegun <= shouldraisegundistsq;

        if ( !raisinggun )
        {
            if ( willbewithinrangewhengunisraised )
            {
                melee_startmovement();
                self setflaggedanimknoballrestart( "chargeanim", animarray( "run_2_melee_" + self.melee.meleeanimvarientindex, "combat" ), %body, 1, 0.2, self.moveplaybackrate );
                raisegunstarttime = time;
                raisinggun = 1;
            }
        }
        else
        {
            withinrangenow = enemydistancesq <= shouldraisegundistsq;

            if ( time - raisegunstarttime >= raisegunfinishduration || !willbewithinrangewhengunisraised && !withinrangenow )
            {
                melee_startmovement();
                self setflaggedanimknoball( "chargeanim", runanim, %body, 1, 0.3, self.moveplaybackrate );
                raisinggun = 0;
            }
        }

        self animscripts\shared::donotetracksfortime( 0.1, "chargeanim" );

        if ( !melee_standard_updateandvalidatetarget() )
        {
            melee_stopmovement();
            return false;
        }

        enemydistancesq = distance2dsquared( self.origin, self.melee.target.origin );
        enemyvel = vectorscale( self.melee.target.origin - prevenemypos, 1 / ( gettime() - time ) );
        prevenemypos = self.melee.target.origin;
        predictedenemyposafterraisegun = self.melee.target.origin + vectorscale( enemyvel, raisegunpredictduration );
        predictedenemydistsqafterraisegun = distance2dsquared( self.origin, predictedenemyposafterraisegun );

        if ( raisinggun && enemydistancesq <= shouldmeleedistsq && ( gettime() - raisegunstarttime >= raisegunfinishduration || !isplayer( self.melee.target ) ) )
            break;

        if ( !raisinggun && gettime() >= self.melee.giveuptime )
        {
            melee_stopmovement();
            return false;
        }
    }

    melee_stopmovement();
    return true;
}

melee_playchargesound()
{
    if ( !isdefined( self.a.nextmeleechargesound ) )
        self.a.nextmeleechargesound = 0;

    if ( isdefined( self.enemy ) && isplayer( self.enemy ) || randomint( 2 ) == 0 )
    {
        if ( gettime() > self.a.nextmeleechargesound )
        {
            self animscripts\face::saygenericdialogue( "attack" );
            self.a.nextmeleechargesound = gettime() + 4000;
        }
    }
}

melee_deathhandler_regular()
{
    self endon( "end_melee" );
    self animscripts\shared::dropallaiweapons();
    return false;
}

melee_endscript_checkdeath()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( !isalive( self ) && isdefined( self.melee.death ) )
    {
        if ( isdefined( self.melee.animateddeath ) )
            self.deathfunction = ::melee_deathhandler_delayed;
        else
            self.deathfunction = ::melee_deathhandler_regular;
    }
}

melee_endscript_checkpositionandmovement()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( !isalive( self ) )
        return;

    if ( isdefined( self.melee.playingmovementanim ) )
        melee_stopmovement();

    neworigin = self getdroptofloorposition();

    if ( isdefined( neworigin ) )
        self forceteleport( neworigin, self.angles );
    else
    {
/#
        println( "Warning: Melee animation might have ended up in solid for entity #" + self getentnum() );
#/
    }
}

melee_endscript_checkweapon()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( isdefined( self.melee.hasknife ) )
        self detach( "weapon_parabolic_knife", "TAG_INHAND" );

    if ( isalive( self ) )
        melee_droppedweaponrestore();
}

melee_endscript_checkstatechanges()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( isalive( self ) )
    {
        if ( isdefined( self.melee.wasallowingpain ) )
        {
            if ( self.melee.wasallowingpain )
                self enable_pain();
            else
                self disable_pain();
        }

        if ( isdefined( self.melee.wasflashbangimmune ) )
            self setflashbangimmunity( self.melee.wasflashbangimmune );
    }
}

melee_endscript()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    self melee_unlink();
    self melee_endscript_checkdeath();
    self melee_endscript_checkpositionandmovement();
    self melee_endscript_checkweapon();
    self melee_endscript_checkstatechanges();

    if ( isdefined( self.melee.partner ) )
        self.melee.partner notify( "partner_end_melee" );

    if ( isdefined( self.meleeendfunc ) )
        self thread [[ self.meleeendfunc ]]();

    self melee_releasemutex( self.melee.target );
}

melee_acquiremutex( target )
{
    assert( isdefined( self ) );
    assert( isdefined( target ) );

    if ( isdefined( self.melee ) )
        return false;

    if ( isdefined( target.melee ) )
        return false;

    self.melee = spawnstruct();

    if ( !isplayer( target ) )
        target.melee = spawnstruct();

    return true;
}

melee_releasemutex( target )
{
    assert( isdefined( self ) );
    self.melee = undefined;

    if ( isdefined( target ) )
        target.melee = undefined;
}

melee_aivsai_main()
{
    if ( !melee_aivsai_getinposition() )
    {
        self.nextmeleechargetime = gettime() + 1500;
        self.nextmeleechargetarget = self.melee.target;
        return;
    }

    target = self.melee.target;
    assert( isalive( self ) && isalive( target ) );
    assert( !isdefined( self.syncedmeleetarget ) );
    assert( !isdefined( target.syncedmeleetarget ) );
    assert( isdefined( self.melee.animname ) );
    assert( animhasnotetrack( self.melee.animname, "sync" ) );
    self melee_aivsai_schedulenotetracklink( target );

    if ( self.melee.winner )
    {
        self.melee.death = undefined;
        target.melee.death = 1;
    }
    else
    {
        target.melee.death = undefined;
        self.melee.death = 1;
    }

    self.melee.partner = target;
    target.melee.partner = self;

    if ( self.weapon == self.sidearm )
    {
        self gun_switchto( self.primaryweapon, "right" );
        self.lastweapon = self.primaryweapon;
    }

    if ( target.weapon == target.sidearm )
    {
        target gun_switchto( target.primaryweapon, "right" );
        target.lastweapon = target.primaryweapon;
    }

    self.melee.weapon = self.weapon;
    self.melee.weaponslot = self getcurrentweaponslotname();
    target.melee.weapon = target.weapon;
    target.melee.weaponslot = target getcurrentweaponslotname();
    self.melee.inprogress = 1;
    target animcustom( ::melee_aivsai_execute, ::melee_endscript );
    target thread melee_aivsai_animcustominterruptionmonitor( self );
    self.melee.target = undefined;
    self melee_aivsai_execute();
}

melee_aivsai_getinposition()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( !melee_isvalid() )
        return 0;

    melee_startmovement();
    self clearanim( %body, 0.2 );
    self setanimknoball( animscripts\run::getrunanim(), %body, 1, 0.2, self.moveplaybackrate );
    self animmode( "zonly_physics" );
    self.keepclaimednode = 1;
    giveuptime = gettime() + 1500;
    assert( isdefined( self.melee.target ) );
    assert( isdefined( self.melee.target.origin ) );
    initialtargetorigin = self.melee.target.origin;
/#
    self notify( "MDBG_att_getInPosition", self.melee.target );
    self.melee.target notify( "MDBG_def_getInPosition", self );
#/

    while ( melee_aivsai_getinposition_updateandvalidatetarget( initialtargetorigin, giveuptime ) )
    {
        if ( melee_aivsai_getinposition_issuccessful( initialtargetorigin ) )
            return melee_aivsai_getinposition_finalize( initialtargetorigin );

        self orientmode( "face point", self.melee.startpos );
        wait 0.05;
    }

    melee_stopmovement();
    return 0;
}

melee_aivsai_schedulenotetracklink( target )
{
    self.melee.syncnotetrackent = target;
    target.melee.syncnotetrackent = undefined;
}

melee_aivsai_execute()
{
    self endon( "killanimscript" );
    self endon( "end_melee" );
    self notify( "melee_aivsai_execute" );
    assert( isdefined( self ) );

    if ( !isdefined( self.melee ) )
        return;

    self animmode( "zonly_physics" );
    self.a.special = "none";
    self.specialdeathfunc = undefined;
    self thread melee_droppedweaponmonitorthread();
    self thread melee_partnerendedmeleemonitorthread();

    if ( isdefined( self.melee.faceyaw ) )
        self orientmode( "face angle", self.melee.faceyaw );
    else
        self orientmode( "face current" );

    self.a.pose = "stand";
    self clearanim( %body, 0.2 );

    if ( isdefined( self.melee.death ) )
        self melee_disableinterruptions();

    self setflaggedanimknoballrestart( "meleeAnim", self.melee.animname, %body, 1, 0.2, self.moveplaybackrate );
    endnote = self animscripts\shared::donotetracks( "meleeAnim", ::melee_handlenotetracks );

    if ( endnote == "melee_death" && isdefined( self.melee.survive ) )
    {
        melee_droppedweaponrestore();
        self setflaggedanimknoballrestart( "meleeAnim", self.melee.surviveanimname, %body, 1, 0.2, self.moveplaybackrate );
        endnote = self animscripts\shared::donotetracks( "meleeAnim", ::melee_handlenotetracks );
    }

    if ( isdefined( self.melee ) && isdefined( self.melee.death ) )
    {
        if ( isdefined( self.overrideactordamage ) )
            self.overrideactordamage = undefined;

        self kill();
    }

    self.keepclaimednode = 0;
}

melee_aivsai_animcustominterruptionmonitor( attacker )
{
    assert( isdefined( attacker ) );
    self endon( "end_melee" );
    self endon( "melee_aivsai_execute" );
    wait 0.1;

    if ( isdefined( attacker ) )
        attacker notify( "end_melee" );

    self notify( "end_melee" );
}

melee_aivsai_getinposition_updateandvalidatetarget( initialtargetorigin, giveuptime )
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( initialtargetorigin ) );

    if ( isdefined( giveuptime ) && giveuptime <= gettime() )
        return false;

    if ( !melee_isvalid() )
        return false;

    target = self.melee.target;
    positiondelta = distancesquared( target.origin, initialtargetorigin );
    assert( isdefined( self.melee.precisepositioning ) );

    if ( self.melee.precisepositioning )
        positionthreshold = 256;
    else
        positionthreshold = 1296;

    if ( positiondelta > positionthreshold )
        return false;

    self.melee.startpos = target.origin + self.melee.startposoffset;

    if ( !melee_updateandvalidatestartpos() )
        return false;

    return true;
}

melee_aivsai_getinposition_issuccessful( initialtargetorigin )
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.startpos ) );
    assert( isdefined( self.melee.target ) );
    assert( isdefined( initialtargetorigin ) );
    dist2dtostartpos = distancesquared( ( self.origin[0], self.origin[1], 0 ), ( self.melee.startpos[0], self.melee.startpos[1], 0 ) );

    if ( dist2dtostartpos < 64 && abs( self.melee.startpos[2] - self.origin[2] ) < 64 )
        return true;

    dist2dfromstartpostotargetsq = distancesquared( ( initialtargetorigin[0], initialtargetorigin[1], 0 ), ( self.melee.startpos[0], self.melee.startpos[1], 0 ) );
    dist2dtotargetsq = distancesquared( ( self.origin[0], self.origin[1], 0 ), ( self.melee.target.origin[0], self.melee.target.origin[1], 0 ) );

    if ( dist2dfromstartpostotargetsq > dist2dtotargetsq && abs( self.melee.target.origin[2] - self.origin[2] ) < 64 )
        return true;

    return false;
}

melee_aivsai_getinposition_finalize( initialtargetorigin )
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.precisepositioning ) );
    assert( isdefined( initialtargetorigin ) );
    melee_stopmovement();

    if ( self.melee.precisepositioning )
    {
        assert( isdefined( self.melee.startpos ) );
        assert( isdefined( self.melee.startangles ) );
        self forceteleport( self.melee.startpos, self.melee.startangles );
        wait 0.05;
    }
    else
    {
        self orientmode( "face angle", self.melee.startangles[1] );
        wait 0.05;
    }

    return melee_aivsai_getinposition_updateandvalidatetarget( initialtargetorigin );
}

melee_disableinterruptions()
{
    self.melee.wasallowingpain = self.allowpain;
    self.melee.wasflashbangimmune = self.flashbangimmunity;
    self disable_pain();
    self setflashbangimmunity( 1 );
}

melee_needsweaponswap()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    return isdefined( self.melee.weapon ) && self.melee.weapon != "none" && self.weapon != self.melee.weapon;
}

melee_droppedweaponrestore()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( self.weapon != "none" && self.lastweapon != "none" )
        return;

    if ( !isdefined( self.melee.weapon ) || self.melee.weapon == "none" )
        return;

    if ( is_true( self.a.meleedontrestoreweapon ) )
        return;

    self gun_switchto( self.melee.weapon, "right" );

    if ( isdefined( self.melee.droppedweaponent ) )
    {
        self.melee.droppedweaponent delete();
        self.melee.droppedweaponent = undefined;
    }
}

melee_droppedweaponmonitorthread()
{
    self endon( "killanimscript" );
    self endon( "end_melee" );
    assert( isdefined( self.melee ) );
    self waittill( "weapon_dropped", droppedweapon );

    if ( isdefined( droppedweapon ) )
    {
        assert( isdefined( self.melee ) );
        self.melee.droppedweaponent = droppedweapon;
    }
}

melee_partnerendedmeleemonitorthread_shouldanimsurvive()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( !isdefined( self.melee.surviveanimname ) )
        return false;

    if ( !isdefined( self.melee.surviveanimallowed ) )
        return false;

    return true;
}

melee_partnerendedmeleemonitorthread()
{
    self endon( "killanimscript" );
    self endon( "end_melee" );
    assert( isdefined( self.melee ) );
    self waittill( "partner_end_melee" );

    if ( isdefined( self.melee.death ) )
    {
        if ( isdefined( self.melee.animateddeath ) || isdefined( self.melee.interruptdeath ) )
        {
            if ( isdefined( self.overrideactordamage ) )
                self.overrideactordamage = undefined;

            self kill();
        }
        else
        {
            self.melee.death = undefined;

            if ( melee_partnerendedmeleemonitorthread_shouldanimsurvive() )
                self.melee.survive = 1;
            else
                self notify( "end_melee" );
        }
    }
    else if ( !isdefined( self.melee.unsynchappened ) )
        self notify( "end_melee" );
}

melee_unlink()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( !isdefined( self.melee.linked ) )
        return;

    if ( isdefined( self.syncedmeleetarget ) )
        self.syncedmeleetarget melee_unlinkinternal();

    self melee_unlinkinternal();
}

melee_unlinkinternal()
{
    assert( isdefined( self ) );
    self unlink();
    self.syncedmeleetarget = undefined;

    if ( !isalive( self ) )
        return;

    assert( isdefined( self.melee.linked ) );
    self.melee.linked = undefined;
    self animmode( "zonly_physics" );
    self orientmode( "face angle", self.angles[1] );
}

melee_handlenotetracks_shoulddieafterunsync()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );

    if ( animhasnotetrack( self.melee.animname, "melee_death" ) )
    {
        if ( isdefined( self.melee.surviveanimname ) )
            return 0;
    }

    return isdefined( self.melee.death );
}

melee_handlenotetracks_unsync()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    self melee_unlink();
    self.melee.unsynchappened = 1;

    if ( isdefined( self.melee.partner ) && isdefined( self.melee.partner.melee ) )
        self.melee.partner.melee.unsynchappened = 1;
}

melee_handlenotetracks_death( interruptanimation )
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.death ) );

    if ( isdefined( interruptanimation ) && interruptanimation )
        self.melee.interruptdeath = 1;
    else
        self.melee.animateddeath = 1;
}

melee_handlenotetracks( note )
{
    if ( issubstr( note, "ps_" ) )
    {
        alias = getsubstr( note, 3 );
        self playsound( alias );
        return;
    }

    if ( note == "sync" )
    {
        if ( isdefined( self.melee.syncnotetrackent ) )
        {
            self melee_aivsai_targetlink( self.melee.syncnotetrackent );
            self.melee.syncnotetrackent = undefined;
        }
    }
    else if ( note == "unsync" )
    {
        self melee_handlenotetracks_unsync();

        if ( melee_handlenotetracks_shoulddieafterunsync() )
            melee_handlenotetracks_death();
    }
    else if ( note == "melee_interact" )
        self.melee.surviveanimallowed = 1;
    else if ( note == "melee_death" )
    {
        if ( isdefined( self.melee.survive ) )
        {
            assert( !isdefined( self.melee.death ) );
            assert( isdefined( self.melee.surviveanimname ) );
            return note;
        }

        assert( isdefined( self.melee.death ) );
        melee_handlenotetracks_death();

        if ( isdefined( self.melee.animateddeath ) )
            return note;
    }
    else if ( note == "attach_knife" )
    {
        self attach( "weapon_parabolic_knife", "TAG_INHAND", 1 );
        self.melee.hasknife = 1;
    }
    else if ( note == "detach_knife" )
    {
        self detach( "weapon_parabolic_knife", "TAG_INHAND" );
        self.melee.hasknife = undefined;
    }
    else if ( note == "stab" )
    {
        assert( isdefined( self.melee.hasknife ) || isdefined( self.hasknifelikeweapon ) );
        self playsound( "melee_knife_hit_body" );

        if ( isdefined( self.special_knife_attack_fx_name ) )
        {
            if ( isdefined( self.melee_weapon_ent ) )
                playfxontag( level._effect[self.special_knife_attack_fx_name], self.melee_weapon_ent, self.special_knife_attack_fx_tag );
            else
                playfxontag( level._effect[self.special_knife_attack_fx_name], self, self.special_knife_attack_fx_tag );
        }
        else
            playfxontag( level._effect["flesh_hit_knife"], self, "tag_origin" );

        if ( isdefined( self.melee.partner ) && isdefined( self.melee.partner.melee ) )
            self.melee.partner melee_handlenotetracks_death( 1 );
    }
    else if ( isdefined( self.meleenotetrackhandler ) )
        [[ self.meleenotetrackhandler ]]( note );
}

melee_deathhandler_delayed()
{
    self endon( "end_melee" );
    self animscripts\shared::donotetracksfortime( 10.0, "meleeAnim" );
    self animscripts\shared::dropallaiweapons();
    self startragdoll();
    return true;
}

melee_aivsai_chooseaction()
{
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.target ) );
    target = self.melee.target;

    if ( !isai( target ) || target.type != "human" )
        return false;

    if ( isdefined( self.meleealwayswin ) && isdefined( target.meleealwayswin ) )
        return false;

    if ( is_true( self.disableaivsaimelee ) )
        return false;

    assert( !isdefined( self.magic_bullet_shield ) || !isdefined( self.melee.target.magic_bullet_shield ) );

    if ( isdefined( self.magic_bullet_shield ) && isdefined( target.magic_bullet_shield ) )
        return false;

    if ( isdefined( self.meleealwayswin ) && isdefined( target.magic_bullet_shield ) || isdefined( target.meleealwayswin ) && isdefined( self.magic_bullet_shield ) )
        return false;

    if ( isdefined( self.specialmeleechooseaction ) )
    {
        if ( ![[ self.specialmeleechooseaction ]]() )
            return false;

        self.melee.precisepositioning = 1;
    }
    else if ( isdefined( target.specialmeleechooseaction ) )
        return false;
    else if ( melee_aivsai_specialcover_canexecute() && melee_aivsai_specialcover_chooseanimationandposition() )
        self.melee.precisepositioning = 1;
    else
    {
        if ( !melee_aivsai_exposed_chooseanimationandposition() )
            return false;

        self.melee.precisepositioning = 0;
    }

    if ( !isdefined( target.melee.faceyaw ) )
        target.melee.faceyaw = target.angles[1];

    self.melee.startposoffset = self.melee.startpos - target.origin;
    return true;
}

melee_aivsai_targetlink( target )
{
    assert( isdefined( self ) );
    assert( isdefined( target ) );

    if ( !isdefined( target.melee ) )
    {
        assert( isdefined( self.melee.survive ) );
        return;
    }

    self melee_playchargesound();

    if ( !isalive( target ) )
        return;

    self.syncedmeleetarget = target;
    target.syncedmeleetarget = self;
    self.melee.linked = 1;
    target.melee.linked = 1;
    self linktoblendtotag( target, "tag_sync", 1, 1 );
}

melee_aivsai_exposed_chooseanimationandposition_flip( anglediff )
{
    flipanglethreshold = 90;

    if ( self.melee.inprogress )
        flipanglethreshold = flipanglethreshold + 50;

    if ( abs( anglediff ) < flipanglethreshold )
        return false;

    target = self.melee.target;
    melee_decide_winner();

    if ( self.melee.winner )
    {
        self.melee.animname = %ai_melee_f_awin_attack;
        target.melee.animname = %ai_melee_f_awin_defend;
        target.melee.surviveanimname = %ai_melee_f_awin_defend_survive;
    }
    else
    {
        self.melee.animname = %ai_melee_f_dwin_attack;
        target.melee.animname = %ai_melee_f_dwin_defend;
    }

    return true;
}

melee_aivsai_exposed_chooseanimationandposition_wrestle( anglediff )
{
    wrestleanglethreshold = 100;

    if ( self.melee.inprogress )
        wrestleanglethreshold = wrestleanglethreshold + 50;

    if ( abs( anglediff ) < wrestleanglethreshold )
        return false;

    target = self.melee.target;

    if ( isdefined( target.magic_bullet_shield ) )
        return false;

    if ( isdefined( target.meleealwayswin ) )
    {
        assert( !isdefined( self.magic_bullet_shield ) );
        return false;
    }

    self.melee.winner = 1;
    self.melee.animname = %ai_melee_r_attack;
    target.melee.animname = %ai_melee_r_defend;
    target.melee.surviveanimname = %ai_melee_r_backdeath2;
    return true;
}

melee_aivsai_exposed_chooseanimationandposition_behind( anglediff )
{
    if ( -90 > anglediff || anglediff > 0 )
        return false;

    target = self.melee.target;

    if ( isdefined( target.magic_bullet_shield ) )
        return false;

    if ( isdefined( target.meleealwayswin ) )
    {
        assert( !isdefined( self.magic_bullet_shield ) );
        return false;
    }

    self.melee.winner = 1;
    self.melee.animname = %ai_melee_sync_attack;
    target.melee.animname = %ai_melee_sync_defend;
    return true;
}

melee_aivsai_exposed_chooseanimationandposition_buildexposedlist()
{
    if ( isdefined( self.meleesequenceoverride ) && [[ self.canexecutemeleesequenceoverride ]]() )
        exposedmelees[0] = self.meleesequenceoverride;
    else if ( isdefined( self.meleeforcedexposedflip ) )
    {
        assert( !isdefined( self.meleeforcedexposedwrestle ) );
        exposedmelees[0] = ::melee_aivsai_exposed_chooseanimationandposition_flip;
    }
    else if ( isdefined( self.meleeforcedexposedwrestle ) )
        exposedmelees[0] = ::melee_aivsai_exposed_chooseanimationandposition_wrestle;
    else if ( isdefined( self.meleeforcedexposedbehind ) )
        exposedmelees[0] = ::melee_aivsai_exposed_chooseanimationandposition_behind;
    else
    {
        flipindex = randomint( 2 );
        wrestleindex = 1 - flipindex;
        exposedmelees[flipindex] = ::melee_aivsai_exposed_chooseanimationandposition_flip;
        exposedmelees[wrestleindex] = ::melee_aivsai_exposed_chooseanimationandposition_wrestle;
        exposedmelees[2] = ::melee_aivsai_exposed_chooseanimationandposition_behind;
    }

    return exposedmelees;
}

melee_aivsai_exposed_chooseanimationandposition()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee.target ) );
    target = self.melee.target;
    angletoenemy = vectortoangles( target.origin - self.origin );
    anglediff = angleclamp180( target.angles[1] - angletoenemy[1] );
    exposedmelees = melee_aivsai_exposed_chooseanimationandposition_buildexposedlist();

    for ( i = 0; i < exposedmelees.size; i++ )
    {
        if ( [[ exposedmelees[i] ]]( anglediff ) )
        {
            assert( isdefined( self.melee.animname ) );
            assert( isdefined( target.melee.animname ) );
            self.melee.startangles = ( 0, angletoenemy[1], 0 );
            self.melee.startpos = getstartorigin( target.origin, target.angles, self.melee.animname );
/#
            self thread draweventpointanddir( self.melee.startpos );
#/

            if ( melee_updateandvalidatestartpos() )
                return true;
        }
    }

    return false;
}

melee_decide_winner()
{
    assert( isdefined( self.melee ) );
    assert( isdefined( self.melee.target ) );
    target = self.melee.target;

    if ( isdefined( self.meleealwayswin ) )
    {
        assert( !isdefined( target.magic_bullet_shield ) );
        self.melee.winner = 1;
        return;
    }
    else if ( isdefined( target.meleealwayswin ) )
    {
        assert( !isdefined( self.magic_bullet_shield ) );
        self.melee.winner = 0;
        return;
    }

    if ( isdefined( self.magic_bullet_shield ) )
    {
        assert( !isdefined( target.magic_bullet_shield ) );
        self.melee.winner = 1;
    }
    else if ( isdefined( target.magic_bullet_shield ) )
        self.melee.winner = 0;
    else
        self.melee.winner = cointoss();
}

melee_aivsai_specialcover_chooseanimationandposition()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee.target ) );
    assert( isdefined( self.melee.target.covernode ) );
    target = self.melee.target;
    melee_decide_winner();

    if ( target.covernode.type == "Cover Left" )
    {
        if ( self.melee.winner )
        {
            self.melee.animname = %ai_cornerstand_left_melee_wina_attacker;
            target.melee.animname = %ai_cornerstand_left_melee_wina_defender;
            target.melee.surviveanimname = %ai_cornerstand_left_melee_wina_defender_survive;
        }
        else
        {
            self.melee.animname = %ai_cornerstand_left_melee_wind_attacker;
            self.melee.surviveanimname = %ai_cornerstand_left_melee_wind_attacker_survive;
            target.melee.animname = %ai_cornerstand_left_melee_wind_defender;
        }
    }
    else
    {
        assert( target.covernode.type == "Cover Right" );

        if ( self.melee.winner )
        {
            self.melee.animname = %ai_cornerstand_right_melee_wina_attacker;
            target.melee.animname = %ai_cornerstand_right_melee_wina_defender;
        }
        else
        {
            self.melee.animname = %ai_cornerstand_right_melee_wind_attacker;
            target.melee.animname = %ai_cornerstand_right_melee_wind_defender;
        }
    }

    self.melee.startpos = getstartorigin( target.covernode.origin, target.covernode.angles, self.melee.animname );
    self.melee.startangles = ( target.covernode.angles[0], angleclamp180( target.covernode.angles[1] + 180 ), target.covernode.angles[2] );
    target.melee.faceyaw = getnodeforwardyaw( target.covernode );
    self.melee.starttotargetcornerangles = target.covernode.angles;

    if ( !melee_updateandvalidatestartpos() )
    {
        self.melee.starttotargetcornerangles = undefined;
        return false;
    }

    return true;
}

melee_aivsai_specialcover_canexecute()
{
    assert( isdefined( self ) );
    assert( isdefined( self.melee.target ) );
    cover = self.melee.target.covernode;

    if ( !isdefined( cover ) )
        return false;

    if ( distancesquared( cover.origin, self.melee.target.origin ) > 16 && isdefined( self.melee.target.a.covermode ) && ( self.melee.target.a.covermode != "hide" && self.melee.target.a.covermode != "lean" ) )
        return false;

    covertoselfangles = vectortoangles( self.origin - cover.origin );
    anglediff = angleclamp180( cover.angles[1] - covertoselfangles[1] );

    if ( cover.type == "Cover Left" )
    {
        if ( anglediff >= -50 && anglediff <= 0 )
            return true;
    }
    else if ( cover.type == "Cover Right" )
    {
        if ( anglediff >= 0 && anglediff <= 50 )
            return true;
    }

    return false;
}

getcurrentweaponslotname()
{
    assert( isdefined( self ) );

    if ( self.weapon == self.secondaryweapon )
        return "secondary";

    if ( self.weapon == self.sidearm )
        return "sidearm";

    return "primary";
}

draweventpointanddir( position )
{
/#
    self endon( "death" );
    current_time = gettime();

    if ( !getdvarint( #"_id_C6C2EDBB" ) )
        return;

    while ( true )
    {
        drawdebugcross( position, 1, ( 1, 0, 0 ), 0.05 );

        if ( gettime() - current_time > 2000 )
            break;

        wait 0.05;
    }
#/
}

debugline( frompoint, topoint, color, durationframes )
{
/#
    self endon( "death" );

    for ( i = 0; i < durationframes * 20; i++ )
    {
        line( frompoint, topoint, color );
        recordline( frompoint, topoint, color, "Animscript", self );
        wait 0.05;
    }
#/
}

drawdebugcross( atpoint, radius, color, durationframes )
{
/#
    self endon( "death" );
    atpoint_high = atpoint + ( 0, 0, radius );
    atpoint_low = atpoint + ( 0, 0, -1 * radius );
    atpoint_left = atpoint + ( 0, radius, 0 );
    atpoint_right = atpoint + ( 0, -1 * radius, 0 );
    atpoint_forward = atpoint + ( radius, 0, 0 );
    atpoint_back = atpoint + ( -1 * radius, 0, 0 );
    thread debugline( atpoint_high, atpoint_low, color, durationframes );
    thread debugline( atpoint_left, atpoint_right, color, durationframes );
    thread debugline( atpoint_forward, atpoint_back, color, durationframes );
#/
}
